좋습니다. **39번 – useScrollPosition 스크롤 위치 추적**으로 진행하겠습니다.

---

## 39. useScrollPosition 스크롤 위치 추적

### 핵심 개념

* 현재 스크롤 좌표(`scrollX`, `scrollY`)를 상태로 제공
* 성능을 위해 `requestAnimationFrame` 기반으로 업데이트(쓰로틀 유사)
* 특정 컨테이너 요소의 스크롤도 지원

---

### 파일 경로 / 파일명

```
src/hooks/useScrollPosition.js
src/App.js
```

---

### 1) 커스텀 훅 – `useScrollPosition.js`

```javascript
import { useEffect, useRef, useState } from 'react';

/**
 * useScrollPosition(target?)
 * - target: 스크롤 대상 (기본 window). DOM 요소의 ref.current를 넘겨도 됨.
 * 반환: { x, y }
 */
export default function useScrollPosition(target) {
  const getScroll = () => {
    if (!target || target === window) {
      return { x: window.scrollX, y: window.scrollY };
    }
    // DOM 요소인 경우
    return { x: target.scrollLeft, y: target.scrollTop };
  };

  const [pos, setPos] = useState(getScroll);
  const ticking = useRef(false); // rAF 중복 방지

  useEffect(() => {
    const el = target && target !== window ? target : window;

    const onScroll = () => {
      if (ticking.current) return;
      ticking.current = true;
      // 다음 페인트 전에 한 번만 업데이트
      requestAnimationFrame(() => {
        ticking.current = false;
        setPos(getScroll());
      });
    };

    // passive로 스크롤 성능 향상
    el.addEventListener('scroll', onScroll, { passive: true });

    // 초기 동기화 (컨테이너 전달 시 마운트 이후 값 반영)
    setPos(getScroll());

    return () => {
      el.removeEventListener('scroll', onScroll);
    };
    // target이 DOM 노드면 참조 안정성 주의. 필요 시 ref.current를 인자로 직접 넣지 말고
    // 상위에서 target을 고정하거나 key로 재마운트 처리하세요.
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [target === window ? 'window' : target]);

  return pos; // { x, y }
}
```

---

### 2) 사용 예제 – 전체 문서 스크롤 추적 (`App.js`)

```javascript
import React from 'react';
import useScrollPosition from './hooks/useScrollPosition';

export default function App() {
  const { x, y } = useScrollPosition(); // window 기준

  const showShadow = y > 8;

  return (
    <div>
      <header
        style={{
          position: 'sticky',
          top: 0,
          padding: '12px 16px',
          background: '#fff',
          borderBottom: showShadow ? '1px solid #eee' : '1px solid transparent',
          boxShadow: showShadow ? '0 6px 14px rgba(0,0,0,0.06)' : 'none',
          transition: 'box-shadow 120ms ease, border-color 120ms ease',
          zIndex: 10,
        }}
      >
        <strong>스크롤 Y: {y}px</strong>
      </header>

      <main style={{ height: '200vh', padding: 16 }}>
        <p>아래로 스크롤해 보세요.</p>
        <p>문서 전체 스크롤 위치가 업데이트됩니다.</p>
      </main>
    </div>
  );
}
```

---

### 3) 특정 스크롤 컨테이너 추적

```javascript
import React, { useRef, useEffect, useState } from 'react';
import useScrollPosition from './hooks/useScrollPosition';

function ScrollBox() {
  const boxRef = useRef(null);
  const [el, setEl] = useState(null);

  // ref.current가 세팅된 뒤 훅에 전달
  useEffect(() => {
    setEl(boxRef.current);
  }, []);

  const { x, y } = useScrollPosition(el);

  return (
    <div>
      <div
        ref={boxRef}
        style={{
          width: 400,
          height: 200,
          overflow: 'auto',
          border: '1px solid #ddd',
          whiteSpace: 'nowrap',
        }}
      >
        <div style={{ width: 1000, height: 600, padding: 16 }}>
          가로/세로로 스크롤 가능한 컨텐츠
        </div>
      </div>
      <p>컨테이너 스크롤: x={x}, y={y}</p>
    </div>
  );
}

export default ScrollBox;
```

---

## 실무 팁

* 매우 긴 리스트라면 스크롤 이벤트 대신 가상 스크롤 라이브러리(react-window 등)와 결합.
* 헤더 고정, 백투탑 버튼 표시, 섹션 인디케이터 등과 쉽게 연동 가능.
* 다중 스크롤 소스가 있을 땐 컨테이너별로 훅을 여러 번 호출하거나, 하나의 훅에서 배열로 관리하는 확장도 가능.

---

다음은 **40번 – useOnlineStatus 온라인/오프라인 상태 감지**로 넘어가겠습니다. 계속 진행할까요?
