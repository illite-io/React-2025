좋습니다. **37번 – useOnClickOutside 바깥 클릭 감지**로 진행하겠습니다.

---

## 37. useOnClickOutside 바깥 클릭 감지

### 목표

* 특정 요소 영역 밖을 클릭/터치하면 콜백 실행
* 모달/드롭다운/컨텍스트 메뉴 닫기에 활용
* 데스크톱(마우스) + 모바일(터치) 모두 대응

---

### 파일 경로 / 파일명

```
src/hooks/useOnClickOutside.js
src/App.js
```

---

### 1) 커스텀 훅 – `useOnClickOutside.js`

```javascript
import { useEffect } from 'react';

/**
 * useOnClickOutside(ref, handler, options?)
 * - ref: 감지할 루트 요소의 ref (예: 모달 래퍼)
 * - handler: 바깥을 눌렀을 때 실행할 함수
 * - options:
 *    - enabled: boolean (기본 true)
 *    - events: 감지할 이벤트 목록 (기본: ['mousedown', 'touchstart'])
 *    - ignore: 클릭을 무시할 요소/selector 목록 (DOM 노드 또는 문자열)
 */
export default function useOnClickOutside(ref, handler, options = {}) {
  const {
    enabled = true,
    events = ['mousedown', 'touchstart'],
    ignore = [], // DOM Node 또는 CSS selector 문자열
  } = options;

  useEffect(() => {
    if (!enabled) return;
    const targetEl = ref?.current;
    if (!targetEl) return;

    const shouldIgnore = (event) => {
      // 1) 옵션으로 넘긴 DOM 노드 무시
      for (const item of ignore) {
        if (!item) continue;
        if (item instanceof Element && item.contains(event.target)) return true;
        // 2) selector 문자열 무시
        if (typeof item === 'string' && event.target.closest?.(item)) return true;
      }
      return false;
    };

    const listener = (event) => {
      // ref가 아직 없거나, 클릭이 ref 내부면 무시
      if (!targetEl || targetEl.contains(event.target)) return;
      // 특정 요소들은 무시
      if (shouldIgnore(event)) return;
      handler(event);
    };

    // 캡처 단계에서 먼저 감지하면 stopPropagation 영향 줄임
    events.forEach((evt) => document.addEventListener(evt, listener, true));

    // 정리
    return () => {
      events.forEach((evt) => document.removeEventListener(evt, listener, true));
    };
  }, [ref, handler, enabled, JSON.stringify(events), JSON.stringify(ignore)]);
}
```

> 비고
>
> * 캡처 단계(`useCapture=true`)로 등록해 내부 컴포넌트에서 `stopPropagation`을 호출하더라도 최대한 감지되도록 합니다.
> * `ignore`로 특정 버튼(예: 트리거 버튼)이나 특정 영역을 클릭해도 닫히지 않게 제어할 수 있습니다.

---

### 2) 사용 예제 – `App.js` (드롭다운 닫기)

```javascript
import React, { useRef, useState } from 'react';
import useOnClickOutside from './hooks/useOnClickOutside';

export default function App() {
  const [open, setOpen] = useState(false);
  const menuRef = useRef(null);
  const triggerRef = useRef(null);

  useOnClickOutside(menuRef, () => setOpen(false), {
    enabled: open,
    // 트리거 버튼 클릭은 "바깥"으로 치지 않도록 무시
    ignore: [triggerRef.current, '[data-keepopen="true"]'],
  });

  return (
    <div style={{ padding: 20 }}>
      <h1>useOnClickOutside 바깥 클릭 감지</h1>

      <button
        ref={triggerRef}
        onClick={() => setOpen((v) => !v)}
        aria-expanded={open}
        aria-haspopup="menu"
      >
        메뉴 토글
      </button>

      {open && (
        <div
          ref={menuRef}
          role="menu"
          style={{
            width: 200,
            marginTop: 8,
            border: '1px solid #ddd',
            borderRadius: 6,
            boxShadow: '0 6px 18px rgba(0,0,0,0.08)',
            padding: 8,
            background: '#fff',
          }}
        >
          <button style={{ width: '100%', textAlign: 'left' }}>메뉴 1</button>
          <button style={{ width: '100%', textAlign: 'left' }}>메뉴 2</button>
          <button style={{ width: '100%', textAlign: 'left' }} data-keepopen="true">
            이 버튼은 눌러도 닫히지 않음
          </button>
        </div>
      )}
    </div>
  );
}
```

---

## 실무 팁

1. 어떤 이벤트를 쓸까

* `mousedown`/`touchstart`는 **누르는 순간** 닫혀 체감이 빠릅니다.
* `click`은 포커스 이동/버튼 활성화 이후여서 약간 늦지만 포커스 로직이 필요한 곳에 유리할 수 있습니다. 필요 시 `events: ['click']`.

2. 포커스 트랩과 조합

* 모달에서는 바깥 클릭 + `Escape` 키로 닫기를 함께 지원하면 접근성이 좋아집니다.

  ```js
  React.useEffect(() => {
    if (!open) return;
    const onKey = (e) => e.key === 'Escape' && setOpen(false);
    document.addEventListener('keydown', onKey);
    return () => document.removeEventListener('keydown', onKey);
  }, [open]);
  ```

3. 중첩 포털/모달

* 포털로 띄운 오버레이도 `document`에서 이벤트를 잡기 때문에 잘 동작합니다.
* 다만 **다중 오버레이**가 겹치는 경우, z-index와 닫기 우선순위를 정하는 관리 레이어를 두는 것이 좋습니다.

4. 성능/정확도

* 이벤트를 문서에 한 번만 등록하는 패턴(싱글턴 리스너)로 확장하면 대규모 페이지에서도 비용을 줄일 수 있습니다.
* 내부 컴포넌트가 `stopPropagation`을 많이 사용한다면 캡처 단계 등록이 안전합니다.

---

다음은 **38번 – useWindowSize 창 크기 추적**으로 넘어가겠습니다. 계속 진행할까요?
