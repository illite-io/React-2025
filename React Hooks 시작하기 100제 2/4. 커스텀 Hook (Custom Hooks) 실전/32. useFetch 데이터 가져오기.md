좋습니다. **32번 – useFetch 데이터 가져오기**로 진행하겠습니다.

---

## 32. useFetch 데이터 가져오기

### 목표

* 공통 `loading / error / data` 상태를 표준화
* `AbortController`로 요청 취소
* 옵션(headers/method/body), 의존성 변경 시 자동 재요청, `refetch()` 제공

---

### 파일 경로 / 파일명

```
src/hooks/useFetch.js
src/App.js
```

---

### 1) 커스텀 훅 – `useFetch.js`

```javascript
import { useCallback, useEffect, useRef, useState } from 'react';

/**
 * useFetch(url, options?, deps?)
 * - url: string | () => string  (함수로 주면 호출 시점에 동적으로 생성)
 * - options: fetch 옵션 (method, headers, body 등)
 * - deps: 의존성 배열 (값이 바뀌면 자동 재요청)
 *
 * 반환: { data, error, loading, refetch }
 */
export default function useFetch(url, options = {}, deps = []) {
  const [data, setData] = useState(null);
  const [error, setError] = useState(null);
  const [loading, setLoading] = useState(false);

  // 최신 options를 유지 (불필요한 재랜더로 인한 재요청 방지)
  const optsRef = useRef(options);
  useEffect(() => {
    optsRef.current = options;
  }, [options]);

  // 진행 중인 요청 취소를 위해 controller를 ref에 보관
  const controllerRef = useRef(null);

  // 실제 요청 함수
  const doFetch = useCallback(async () => {
    // 이전 요청이 있다면 취소
    if (controllerRef.current) controllerRef.current.abort();
    const controller = new AbortController();
    controllerRef.current = controller;

    setLoading(true);
    setError(null);

    try {
      const resolvedUrl = typeof url === 'function' ? url() : url;
      const res = await fetch(resolvedUrl, {
        // 기본 옵션 병합
        method: 'GET',
        headers: { 'Content-Type': 'application/json', ...(optsRef.current.headers || {}) },
        signal: controller.signal,
        // body는 GET이 아닌 경우에만 자동 처리
        ...(optsRef.current.method && optsRef.current.method !== 'GET'
          ? { body: typeof optsRef.current.body === 'string'
              ? optsRef.current.body
              : JSON.stringify(optsRef.current.body) }
          : {}),
        // 나머지 옵션도 전달
        ...optsRef.current,
      });

      if (!res.ok) {
        // 응답 본문이 JSON일 수도, 아닐 수도 있음
        let message = `HTTP ${res.status}`;
        try {
          const maybe = await res.json();
          message = maybe?.message || message;
        } catch (_) {}
        throw new Error(message);
      }

      // JSON 응답 가정 (필요 시 options.parse로 커스터마이즈 가능)
      const json = await res.json();
      setData(json);
    } catch (err) {
      if (err.name === 'AbortError') return; // 취소는 에러 취급하지 않음
      setError(err);
    } finally {
      setLoading(false);
      controllerRef.current = null;
    }
  }, [url, ...deps]); // url(값/함수)과 의존성 변경 시 최신 요청

  // 마운트/의존성 변경 시 자동 호출
  useEffect(() => {
    doFetch();
    // 언마운트 시 진행 중이면 취소
    return () => {
      if (controllerRef.current) controllerRef.current.abort();
    };
  }, [doFetch]);

  // 수동 재요청
  const refetch = useCallback(() => {
    doFetch();
  }, [doFetch]);

  return { data, error, loading, refetch };
}
```

---

### 2) 기본 사용 – `GET` 요청 (의존성 없이 한 번만)

```
src/App.js
```

```javascript
import React from 'react';
import useFetch from './hooks/useFetch';

export default function App() {
  const { data, error, loading, refetch } = useFetch(
    'https://jsonplaceholder.typicode.com/posts?_limit=5'
  );

  if (loading) return <p>로딩 중...</p>;
  if (error) return <p>에러: {error.message}</p>;
  if (!data) return null;

  return (
    <div style={{ padding: 20 }}>
      <h1>useFetch 기본 GET</h1>
      <button onClick={refetch}>다시 불러오기</button>
      <ul>
        {data.map(p => (
          <li key={p.id}>
            <strong>{p.title}</strong>
            <p>{p.body}</p>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

---

### 3) 동적 파라미터 & 의존성으로 자동 재요청

* 검색어가 바뀔 때마다 자동 요청

```javascript
import React, { useState } from 'react';
import useFetch from './hooks/useFetch';

function SearchPosts() {
  const [q, setQ] = useState('qui');

  // url을 함수로 주면 호출 시점에 최신 q 사용
  const { data, loading, error } = useFetch(
    () => `https://jsonplaceholder.typicode.com/comments?postId=1&q=${encodeURIComponent(q)}`,
    {},
    [q] // q가 바뀌면 재요청
  );

  return (
    <div>
      <h2>검색</h2>
      <input
        value={q}
        onChange={(e) => setQ(e.target.value)}
        placeholder="검색어"
        style={{ padding: '6px 8px' }}
      />
      {loading && <p>검색 중...</p>}
      {error && <p>에러: {error.message}</p>}
      <ul>
        {(data || []).map(c => (
          <li key={c.id}>{c.email}: {c.name}</li>
        ))}
      </ul>
    </div>
  );
}

export default function App() {
  return (
    <div style={{ padding: 20 }}>
      <h1>동적 파라미터 자동 재요청</h1>
      <SearchPosts />
    </div>
  );
}
```

---

### 4) POST/PUT 등 바디 포함 요청

```javascript
import React, { useState } from 'react';
import useFetch from './hooks/useFetch';

export default function CreatePost() {
  const [title, setTitle] = useState('');
  const [body, setBody]   = useState('');

  const { data, loading, error, refetch } = useFetch(
    'https://jsonplaceholder.typicode.com/posts',
    {
      method: 'POST',
      body: { title, body, userId: 1 }, // useFetch가 JSON.stringify 처리
      headers: { 'Content-Type': 'application/json' },
    },
    // 주의: 의존성에 title/body를 넣으면 타이핑마다 요청됨.
    // 제출 버튼에서 refetch()를 수동 호출하는 패턴을 사용.
    [] 
  );

  const submit = (e) => {
    e.preventDefault();
    refetch(); // 현재 title/body로 POST 수행
  };

  return (
    <form onSubmit={submit} style={{ padding: 20 }}>
      <h1>POST 요청 예제</h1>
      <div>
        <input value={title} onChange={(e)=>setTitle(e.target.value)} placeholder="제목" />
      </div>
      <div>
        <textarea value={body} onChange={(e)=>setBody(e.target.value)} placeholder="내용" />
      </div>
      <button type="submit" disabled={loading}>작성</button>
      {loading && <p>요청 중...</p>}
      {error && <p>에러: {error.message}</p>}
      {data && <pre>{JSON.stringify(data, null, 2)}</pre>}
    </form>
  );
}
```

---

## 팁 & 베스트 프랙티스

1. **요청 취소(필수)**

* 의존성이 자주 바뀔 때(검색 타이핑 등) 이전 요청을 `AbortController`로 취소하여 **레이스 컨디션/메모리 누수**를 방지합니다.

2. **의존성 설계**

* 자동 재요청이 필요한 값만 `deps`에 넣습니다.
* `POST`처럼 버튼으로 보낼 때는 `deps`를 비워두고 `refetch()`로 수동 요청.

3. **JSON 이외 응답**

* 파일 다운로드 등은 `res.blob()`이 필요합니다. 간단히 확장하려면 `options.parse`를 지원하도록 개선:

  ```js
  // 예: options.parse === 'blob'이면 res.blob() 사용
  ```

4. **공통 베이스 URL, 인증 토큰**

* 실제 앱에서는 `fetch` 래퍼나 `interceptor`(axios 유사 개념)를 만들어 토큰/에러 공통 처리.

5. **디바운스와 조합**

* 검색 입력에는 92번(useDebounce) 훅과 결합하여 서버 부하를 줄이세요.

6. **캐싱이 필요하면**

* 간단 캐시는 `Map(url)->data` 형태로 훅 내부에 두거나, React Query/SWR 같은 라이브러리를 고려.

---

다음은 **33번 – useForm 폼 상태 관리**로 넘어가겠습니다. 계속 진행할까요?
