좋습니다. 이제 **73번 – useModal 모달 상태 관리** 예제를 보겠습니다.

---

## 73. useModal 모달 상태 관리

### 목표

* 열기/닫기 상태와 제어 함수 제공
* ESC 키로 닫기, 바깥 클릭 닫기(옵션)
* 모달 열릴 때 **포커스 트랩**과 **바디 스크롤 잠금** 지원

---

### 파일 경로 / 파일명

```
src/hooks/useModal.js
src/App.js
```

---

### 1) 커스텀 훅 – `useModal.js`

```javascript
import { useCallback, useEffect, useRef, useState } from "react";

/**
 * useModal(options?)
 * - options:
 *   - closeOnEsc: ESC로 닫기 (기본 true)
 *   - closeOnBackdrop: 배경 클릭으로 닫기 (기본 true)
 *   - lockScroll: body 스크롤 잠금 (기본 true)
 *
 * 반환:
 * { isOpen, open, close, toggle, backdropProps, dialogProps }
 */
export default function useModal(options = {}) {
  const {
    closeOnEsc = true,
    closeOnBackdrop = true,
    lockScroll = true,
  } = options;

  const [isOpen, setIsOpen] = useState(false);
  const lastActiveRef = useRef(null);
  const dialogRef = useRef(null);

  const open = useCallback(() => {
    lastActiveRef.current = document.activeElement;
    setIsOpen(true);
  }, []);

  const close = useCallback(() => {
    setIsOpen(false);
    // 닫힐 때 이전 포커스 복원
    setTimeout(() => {
      if (lastActiveRef.current instanceof HTMLElement) {
        lastActiveRef.current.focus?.();
      }
    }, 0);
  }, []);

  const toggle = useCallback(() => (isOpen ? close() : open()), [isOpen, open, close]);

  // ESC 닫기
  useEffect(() => {
    if (!isOpen || !closeOnEsc) return;
    const onKey = (e) => {
      if (e.key === "Escape") {
        e.stopPropagation();
        close();
      }
    };
    document.addEventListener("keydown", onKey, true);
    return () => document.removeEventListener("keydown", onKey, true);
  }, [isOpen, closeOnEsc, close]);

  // 스크롤 잠금
  useEffect(() => {
    if (!isOpen || !lockScroll) return;
    const original = document.body.style.overflow;
    document.body.style.overflow = "hidden";
    return () => {
      document.body.style.overflow = original;
    };
  }, [isOpen, lockScroll]);

  // 간단 포커스 트랩: 모달 열릴 때 내부로 포커스 이동, Tab 순환
  useEffect(() => {
    if (!isOpen) return;
    const root = dialogRef.current;
    if (!root) return;

    // 첫 포커스 대상
    const focusable = root.querySelectorAll(
      'a[href],button:not([disabled]),textarea,input,select,[tabindex]:not([tabindex="-1"])'
    );
    const first = focusable[0];
    const last = focusable[focusable.length - 1];
    first?.focus?.();

    const onKeyDown = (e) => {
      if (e.key !== "Tab") return;
      if (focusable.length === 0) {
        e.preventDefault();
        return;
      }
      if (e.shiftKey && document.activeElement === first) {
        e.preventDefault();
        last?.focus?.();
      } else if (!e.shiftKey && document.activeElement === last) {
        e.preventDefault();
        first?.focus?.();
      }
    };
    root.addEventListener("keydown", onKeyDown);
    return () => root.removeEventListener("keydown", onKeyDown);
  }, [isOpen]);

  // 배경 클릭 닫기 지원
  const backdropProps = {
    onMouseDown: (e) => {
      if (!closeOnBackdrop) return;
      // 바깥(백드롭)을 누른 경우만
      if (e.target === e.currentTarget) close();
    },
  };

  const dialogProps = {
    role: "dialog",
    "aria-modal": true,
    ref: dialogRef,
  };

  return { isOpen, open, close, toggle, backdropProps, dialogProps };
}
```

---

### 2) 사용 예제 – `App.js`

```javascript
import React from "react";
import useModal from "./hooks/useModal";

function Modal({ isOpen, backdropProps, dialogProps, onClose, title, children }) {
  if (!isOpen) return null;
  return (
    <div
      {...backdropProps}
      style={{
        position: "fixed",
        inset: 0,
        background: "rgba(0,0,0,0.4)",
        display: "grid",
        placeItems: "center",
        zIndex: 50,
      }}
      aria-labelledby="modal-title"
    >
      <div
        {...dialogProps}
        style={{
          width: "min(560px, 92vw)",
          background: "#fff",
          borderRadius: 12,
          padding: 16,
          boxShadow: "0 20px 60px rgba(0,0,0,0.2)",
        }}
      >
        <div style={{ display: "flex", alignItems: "center", gap: 8 }}>
          <h2 id="modal-title" style={{ margin: 0, fontSize: 20, fontWeight: 700 }}>
            {title}
          </h2>
          <button
            onClick={onClose}
            aria-label="닫기"
            style={{ marginLeft: "auto" }}
          >
            닫기
          </button>
        </div>
        <div style={{ marginTop: 12 }}>{children}</div>
      </div>
    </div>
  );
}

export default function App() {
  const { isOpen, open, close, toggle, backdropProps, dialogProps } = useModal({
    closeOnEsc: true,
    closeOnBackdrop: true,
    lockScroll: true,
  });

  return (
    <div style={{ padding: 20 }}>
      <h1>useModal 모달 상태 관리</h1>
      <button onClick={open}>모달 열기</button>
      <button onClick={toggle} style={{ marginLeft: 8 }}>토글</button>

      <Modal
        isOpen={isOpen}
        backdropProps={backdropProps}
        dialogProps={dialogProps}
        onClose={close}
        title="모달 제목"
      >
        <p>여기에 내용을 넣으세요.</p>
        <input placeholder="포커스 테스트 입력" />
        <div style={{ marginTop: 12 }}>
          <button onClick={close}>확인</button>
        </div>
      </Modal>
    </div>
  );
}
```

---

## 포인트

* **접근성**: `role="dialog"`, `aria-modal`, 제목 id 연결.
* **포커스 관리**: 열릴 때 내부 첫 포커스, Tab 순환으로 포커스 트랩.
* **UX 옵션**: ESC/백드롭으로 닫기, 스크롤 잠금으로 배경 스크롤 방지.
* **조합**: 37번 `useOnClickOutside`를 이용한 내부-외부 구분, 59번 `useHotkeys`로 ESC 핸들링 강화 가능.

---

다음은 **74번 – useSnackbar 스낵바 알림**으로 넘어가겠습니다. 계속 진행할까요?
