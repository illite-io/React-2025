좋습니다. **78번 – usePagination 페이지네이션 상태 관리**로 진행하겠습니다.

---

## 78. usePagination 페이지네이션 상태 관리

### 목표

* `page`, `pageSize`, `total`을 일관되게 관리
* `next/prev/goTo/setPageSize`와 파생값 `totalPages`, `offset` 제공
* 배열 데이터를 쉽게 잘라 쓰는 `paginate(items)` 도우미 포함

---

### 파일 경로 / 파일명

```
src/hooks/usePagination.js
src/App.js
```

---

### 1) 커스텀 훅 – `usePagination.js`

```javascript
import { useMemo, useState, useCallback } from "react";

/**
 * usePagination({ total, initialPage = 1, initialPageSize = 10 })
 * 반환:
 * { page, pageSize, total, totalPages, offset, limit,
 *   next, prev, goTo, setPageSize, setTotal, paginate }
 */
export default function usePagination({ total = 0, initialPage = 1, initialPageSize = 10 } = {}) {
  const [page, setPage] = useState(initialPage);
  const [pageSize, setPageSize] = useState(initialPageSize);
  const [innerTotal, setInnerTotal] = useState(total);

  const totalPages = useMemo(
    () => Math.max(1, Math.ceil(innerTotal / pageSize || 1)),
    [innerTotal, pageSize]
  );

  const goTo = useCallback((p) => {
    const clamped = Math.min(Math.max(1, p), totalPages);
    setPage(clamped);
  }, [totalPages]);

  const next = useCallback(() => goTo(page + 1), [goTo, page]);
  const prev = useCallback(() => goTo(page - 1), [goTo, page]);

  const setTotal = useCallback((t) => {
    setInnerTotal(t);
    // 총 개수가 줄어들면 현재 페이지 보정
    const newTotalPages = Math.max(1, Math.ceil((t || 0) / pageSize || 1));
    if (page > newTotalPages) setPage(newTotalPages);
  }, [page, pageSize]);

  const offset = useMemo(() => (page - 1) * pageSize, [page, pageSize]);
  const limit  = pageSize;

  // 클라이언트 배열을 잘라주는 도우미
  const paginate = useCallback((items = []) => items.slice(offset, offset + limit), [offset, limit]);

  const _setPageSize = useCallback((size) => {
    const s = Math.max(1, size);
    const start = offset;              // 현재 첫 인덱스를 기준으로
    const newPage = Math.floor(start / s) + 1; // 같은 범위를 보여주도록 보정
    setPageSize(s);
    setPage(newPage);
  }, [offset]);

  return {
    page, pageSize, total: innerTotal, totalPages, offset, limit,
    next, prev, goTo, setPageSize: _setPageSize, setTotal, paginate
  };
}
```

---

### 2) 사용 예제 – `App.js` (클라이언트 배열 페이징)

```javascript
import React, { useMemo, useState } from "react";
import usePagination from "./hooks/usePagination";

const ALL = Array.from({ length: 137 }, (_, i) => ({ id: i + 1, name: `아이템 ${i + 1}` }));

export default function App() {
  const [keyword, setKeyword] = useState("");

  const filtered = useMemo(() => {
    const q = keyword.trim().toLowerCase();
    return q ? ALL.filter(x => x.name.toLowerCase().includes(q)) : ALL;
  }, [keyword]);

  const {
    page, pageSize, total, totalPages, next, prev, goTo, setPageSize, setTotal, paginate
  } = usePagination({ total: filtered.length, initialPage: 1, initialPageSize: 10 });

  // 필터 결과가 바뀌면 total 갱신
  React.useEffect(() => setTotal(filtered.length), [filtered.length, setTotal]);

  const pageItems = paginate(filtered);

  return (
    <div style={{ maxWidth: 640, margin: "40px auto", padding: "0 16px" }}>
      <h1>usePagination 페이지네이션 상태 관리</h1>

      <div style={{ display: "flex", gap: 8, marginBottom: 12 }}>
        <input
          value={keyword}
          onChange={(e) => { setKeyword(e.target.value); goTo(1); }}
          placeholder="검색어"
          style={{ padding: "6px 10px", flex: 1 }}
        />
        <label>
          pageSize:
          <select
            value={pageSize}
            onChange={(e) => setPageSize(Number(e.target.value))}
            style={{ marginLeft: 6 }}
          >
            {[5,10,20,50].map(s => <option key={s} value={s}>{s}</option>)}
          </select>
        </label>
      </div>

      <p style={{ color: "#64748b" }}>
        총 {total}개 / {page} / {totalPages} 페이지
      </p>

      <ul>
        {pageItems.map(item => <li key={item.id}>{item.name}</li>)}
        {pageItems.length === 0 && <li>결과 없음</li>}
      </ul>

      <div style={{ display: "flex", gap: 6, marginTop: 12, alignItems: "center" }}>
        <button onClick={() => goTo(1)} disabled={page === 1}>처음</button>
        <button onClick={prev} disabled={page === 1}>이전</button>
        <span style={{ padding: "0 8px" }}>{page} / {totalPages}</span>
        <button onClick={next} disabled={page === totalPages}>다음</button>
        <button onClick={() => goTo(totalPages)} disabled={page === totalPages}>끝</button>
      </div>
    </div>
  );
}
```

---

### 포인트

* 서버 페이징과 결합 시 `offset/limit`를 그대로 쿼리에 사용하면 됩니다.
* `setPageSize` 시 현재 보던 범위를 유지하도록 **페이지 보정**을 적용했습니다.
* 검색/필터 변경 시 `goTo(1)`로 첫 페이지로 이동하는 패턴이 UX상 자연스럽습니다.
* 데이터가 줄어들어 현재 페이지가 범위를 벗어나면 `setTotal()`이 자동으로 페이지를 마지막으로 보정합니다.

---

다음은 **79번 – useSlider 슬라이더 값 관리**로 넘어갈까요?
