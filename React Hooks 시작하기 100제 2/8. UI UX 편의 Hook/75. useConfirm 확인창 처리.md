좋습니다. 이제 **75번 – useConfirm 확인창 처리** 예제를 보겠습니다.

---

## 75. useConfirm 확인창 처리

### 목표

* 비동기 로직 앞에서 사용자에게 **확인/취소**를 물어보고 결과를 Promise로 반환
* 전역 하나의 컨테이너로 어디서든 호출
* ESC/백드롭 닫기, 포커스 트랩 지원

---

### 파일 경로 / 파일명

```
src/hooks/useConfirm.js
src/ConfirmProvider.js
src/App.js
```

---

### 1) 훅과 컨텍스트 – `useConfirm.js`

```javascript
import { createContext, useContext } from "react";

const ConfirmContext = createContext(null);

// 외부에서 쓰는 훅
export function useConfirm() {
  const ctx = useContext(ConfirmContext);
  if (!ctx) throw new Error("ConfirmProvider 안에서 사용하세요.");
  return ctx.confirm;
}

// Provider에서 value로 내려줄 API 형태 참고용
export function createConfirmApi() {
  let _open;
  const confirm = (options) =>
    new Promise((resolve) => {
      _open?.({ ...options, resolve });
    });
  const registry = {
    mount(openFn) { _open = openFn; },
    unmount() { _open = null; },
  };
  return { confirm, ConfirmContext, registry };
}
```

---

### 2) 프로바이더/컨테이너 – `ConfirmProvider.js`

```javascript
import React, { useEffect, useRef, useState } from "react";
import { createConfirmApi } from "./hooks/useConfirm";

const { confirm, ConfirmContext, registry } = createConfirmApi();

export { confirm }; // 비훅 사용도 가능하게 export

export default function ConfirmProvider({ children }) {
  const [state, setState] = useState({
    open: false,
    title: "",
    message: "",
    okText: "확인",
    cancelText: "취소",
    resolve: null,
  });

  // Provider 마운트 시 opener 주입
  useEffect(() => {
    registry.mount((opts) => {
      setState({ open: true, title: "", message: "", okText: "확인", cancelText: "취소", ...opts });
    });
    return () => registry.unmount();
  }, []);

  const dialogRef = useRef(null);
  const lastActiveRef = useRef(null);

  useEffect(() => {
    if (state.open) {
      lastActiveRef.current = document.activeElement;
      // 첫 포커스
      setTimeout(() => dialogRef.current?.querySelector("button[data-ok]")?.focus(), 0);
      // 키 처리
      const onKey = (e) => {
        if (e.key === "Escape") {
          e.stopPropagation();
          onCancel();
        }
      };
      document.addEventListener("keydown", onKey, true);
      return () => document.removeEventListener("keydown", onKey, true);
    }
  }, [state.open]);

  const close = () => {
    setState((s) => ({ ...s, open: false }));
    setTimeout(() => lastActiveRef.current?.focus?.(), 0);
  };

  const onOk = () => { state.resolve?.(true); close(); };
  const onCancel = () => { state.resolve?.(false); close(); };

  return (
    <ConfirmContext.Provider value={{ confirm }}>
      {children}
      {state.open && (
        <div
          onMouseDown={(e) => e.target === e.currentTarget && onCancel()}
          style={{
            position: "fixed", inset: 0, background: "rgba(0,0,0,0.35)",
            display: "grid", placeItems: "center", zIndex: 60
          }}
          aria-labelledby="confirm-title"
        >
          <div
            ref={dialogRef}
            role="dialog"
            aria-modal="true"
            style={{
              width: "min(420px, 92vw)",
              background: "#fff",
              borderRadius: 12,
              padding: 16,
              boxShadow: "0 16px 44px rgba(0,0,0,0.2)"
            }}
          >
            {state.title && (
              <h2 id="confirm-title" style={{ marginTop: 0 }}>{state.title}</h2>
            )}
            <div style={{ marginTop: 8, color: "#374151" }}>{state.message}</div>
            <div style={{ display: "flex", justifyContent: "flex-end", gap: 8, marginTop: 16 }}>
              <button onClick={onCancel}>{state.cancelText}</button>
              <button data-ok onClick={onOk} style={{ fontWeight: 600 }}>
                {state.okText}
              </button>
            </div>
          </div>
        </div>
      )}
    </ConfirmContext.Provider>
  );
}
```

---

### 3) 사용 예제 – `App.js`

```javascript
import React from "react";
import ConfirmProvider, { confirm } from "./ConfirmProvider";
import { useConfirm } from "./hooks/useConfirm";

function DangerousAction() {
  const ask = useConfirm(); // 훅 형태 사용

  const handleDelete = async () => {
    const ok = await ask({
      title: "삭제 확인",
      message: "정말로 이 항목을 삭제하시겠습니까?",
      okText: "삭제",
      cancelText: "취소",
    });
    if (ok) {
      // 실제 삭제 로직
      alert("삭제되었습니다.");
    }
  };

  return <button onClick={handleDelete}>항목 삭제</button>;
}

function AnotherWay() {
  const handle = async () => {
    // 훅이 아닌 전역 함수로도 호출 가능 (동일 인스턴스)
    const ok = await confirm({
      message: "변경 내용을 저장할까요?",
      okText: "저장",
      cancelText: "나중에",
    });
    if (ok) alert("저장했습니다.");
  };
  return <button onClick={handle} style={{ marginLeft: 8 }}>저장 확인</button>;
}

export default function App() {
  return (
    <ConfirmProvider>
      <div style={{ padding: 20 }}>
        <h1>useConfirm 확인창 처리</h1>
        <DangerousAction />
        <AnotherWay />
      </div>
    </ConfirmProvider>
  );
}
```

---

## 포인트

* `confirm(options) → Promise<boolean>` 형태로 간결한 호출.
* ESC, 백드롭 클릭으로 취소 처리.
* 포커스 트랩/복원으로 접근성 보강.
* 훅/전역 함수 두 방식 모두 지원해 사용성 극대화.

---

### 확장 아이디어

* 버튼 스타일과 상태(파괴적 액션일 때 강조 색상).
* 체크박스 “다시 보지 않기” 옵션 추가 후 localStorage로 스킵.
* 비동기 확인 흐름: 확인 누른 뒤 추가 확인(2차 경고), 입력 확인(예: 리포지터리 이름 입력).

---

다음은 **76번 – useStepper 단계별 진행 관리**로 넘어가겠습니다. 계속 진행할까요?
