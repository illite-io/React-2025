좋습니다. **30번 – useEffect 타이머 사용 및 정리**로 진행하겠습니다.

---

## 30. useEffect 타이머 사용 및 정리

### 목표

* `setTimeout`, `setInterval`을 안전하게 사용하고 **클린업**으로 누수 방지
* **stale closure(오래된 값 캡쳐)** 문제를 피하는 패턴 익히기

---

### 파일 경로 / 파일명

```
src/App.js
```

### 예시 1) setTimeout: 마운트 후 3초 뒤 메시지 표시 → 언마운트 시 취소

```javascript
import React, { useEffect, useState } from 'react';

export default function App() {
  const [msg, setMsg] = useState('대기중...');

  useEffect(() => {
    const timerId = setTimeout(() => {
      setMsg('3초 경과!');
    }, 3000);

    // cleanup: 컴포넌트가 사라지거나 재실행 시 타이머 취소
    return () => clearTimeout(timerId);
  }, []); // 마운트 시 한 번만

  return (
    <div style={{ padding: 20 }}>
      <h1>setTimeout 사용</h1>
      <p>{msg}</p>
    </div>
  );
}
```

#### 포인트

* 효과 재실행/언마운트 시 `clearTimeout`으로 안전하게 취소.

---

### 예시 2) setInterval: 1초 카운터 → stale closure 방지

```javascript
import React, { useEffect, useRef, useState } from 'react';

export default function TimerCounter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    // 함수형 업데이트로 최신 상태 사용 → stale closure 방지
    const id = setInterval(() => {
      setCount(prev => prev + 1);
    }, 1000);

    return () => clearInterval(id);
  }, []); // 마운트 시 한 번만 interval 설정

  return (
    <div style={{ padding: 20 }}>
      <h1>setInterval 카운터</h1>
      <p>초: {count}</p>
    </div>
  );
}
```

#### 포인트

* `setCount(prev => prev + 1)` 형태를 사용하면 의존성 없이도 최신 값으로 안전하게 증가.
* `setCount(count + 1)`처럼 쓰면 `count`가 0으로 캡쳐되는 stale 문제가 생김.

---

### 예시 3) 가변 딜레이(변하는 interval 간격)와 정지/재개

```javascript
import React, { useEffect, useRef, useState } from 'react';

export default function AdjustableInterval() {
  const [delay, setDelay] = useState(1000); // ms
  const [running, setRunning] = useState(true);
  const savedCallback = useRef(() => {}); // 최신 콜백 보관

  // 실행할 콜백을 ref에 보관 (stale closure 방지)
  useEffect(() => {
    savedCallback.current = () => {
      console.log('tick');
    };
  }, []);

  useEffect(() => {
    if (!running) return; // 정지 상태면 설정하지 않음
    const id = setInterval(() => savedCallback.current(), delay);
    return () => clearInterval(id);
  }, [delay, running]);

  return (
    <div style={{ padding: 20 }}>
      <h1>가변 Interval</h1>
      <div style={{ display: 'flex', gap: 8, alignItems: 'center' }}>
        <label>
          딜레이(ms):
          <input
            type="number"
            value={delay}
            onChange={(e) => setDelay(Number(e.target.value))}
            style={{ marginLeft: 6, width: 120 }}
          />
        </label>
        <button onClick={() => setRunning(r => !r)}>
          {running ? '정지' : '재개'}
        </button>
      </div>
    </div>
  );
}
```

#### 포인트

* 콜백 함수 내용을 자주 바꾸거나 외부 상태에 의존한다면, **ref에 최신 콜백을 저장**하고 interval에서는 그 ref만 호출.
* 딜레이/실행 여부가 바뀔 때만 interval을 재설정.

---

### 예시 4) 탭 비활성화 시 타이머 일시중지 (가시성 API)

```javascript
import React, { useEffect, useRef, useState } from 'react';

export default function PausableTimer() {
  const [count, setCount] = useState(0);
  const intervalRef = useRef(null);

  const start = () => {
    if (intervalRef.current) return;
    intervalRef.current = setInterval(() => {
      setCount(prev => prev + 1);
    }, 1000);
  };

  const stop = () => {
    if (!intervalRef.current) return;
    clearInterval(intervalRef.current);
    intervalRef.current = null;
  };

  useEffect(() => {
    start();
    const onVisibility = () => {
      if (document.hidden) stop();
      else start();
    };
    document.addEventListener('visibilitychange', onVisibility);
    return () => {
      document.removeEventListener('visibilitychange', onVisibility);
      stop();
    };
  }, []);

  return (
    <div style={{ padding: 20 }}>
      <h1>가시성 기반 타이머</h1>
      <p>초: {count}</p>
    </div>
  );
}
```

#### 포인트

* 백그라운드 탭에서 불필요한 타이머 실행을 멈춰 **배터리/자원 절약**.

---

## 체크리스트와 베스트 프랙티스

1. 항상 **클린업**

* `useEffect`에서 타이머를 만들었다면 `return () => clearXxx(id)`로 반드시 정리.

2. **stale closure 방지**

* 상태를 읽어 증가/감소할 땐 `setState(prev => prev + 1)`같은 **함수형 업데이트** 사용.
* 복잡한 콜백은 `useRef`에 최신 버전을 저장하고 타이머에서는 그 ref만 호출.

3. 의존성 설계

* 딜레이나 실행 여부가 바뀔 때만 재설정되도록 의존성 배열을 설계.
* 불필요하게 의존성을 추가해 매 렌더마다 타이머를 새로 만들지 않기.

4. 사용자 환경 고려

* 비활성 탭, 페이지 전환, 컴포넌트 언마운트 등 다양한 상황에서 타이머가 **남지 않도록** 주의.

---

다음은 **31번 – useToggle 불리언 값 토글**로 넘어가겠습니다. 계속 진행할까요?
