좋습니다. **22번 – useLayoutEffect DOM 변경 직후 실행**으로 진행하겠습니다.

---

## 22. useLayoutEffect DOM 변경 직후 실행

### 핵심 개념

* `useEffect`는 **화면 페인팅(그리기) 이후** 비동기로 실행됩니다.
* `useLayoutEffect`는 **DOM 업데이트 직후, 페인팅 이전(동기)** 에 실행되어 **레이아웃 측정/동기적 스타일 조정**에 유리합니다.
* 잘못 사용하면 **UI 멈춤/지연**을 유발할 수 있으므로 **정말 필요한 경우에만** 사용합니다.

---

### 파일 경로 / 파일명

```
src/App.js
```

### 예시 1) 요소 크기 측정 후 동기 보정(깜빡임 방지)

```javascript
import React, { useLayoutEffect, useRef, useState } from 'react';

export default function App() {
  const boxRef = useRef(null);
  const [boxWidth, setBoxWidth] = useState(0);
  const [ready, setReady] = useState(false);

  // DOM이 갱신된 직후, 페인트 전에 크기를 측정하고 스타일을 보정
  useLayoutEffect(() => {
    const el = boxRef.current;
    if (!el) return;

    // 레이아웃 측정
    const rect = el.getBoundingClientRect();
    setBoxWidth(rect.width);

    // 초기 렌더 시 깜빡임을 줄이기 위해 동기적으로 표시 전 처리
    setReady(true);
  }, []);

  return (
    <div style={{ padding: 20 }}>
      <h1>useLayoutEffect: 레이아웃 측정 & 보정</h1>

      {/* 준비 전까지는 가시성 숨김으로 초기 깜빡임 방지 */}
      <div
        ref={boxRef}
        style={{
          width: '40%',
          minWidth: 240,
          border: '1px solid #ddd',
          padding: 16,
          visibility: ready ? 'visible' : 'hidden',
        }}
      >
        <p>이 박스의 실제 렌더 너비: <strong>{boxWidth}px</strong></p>
        <p>윈도우 리사이즈에 대응하려면 이벤트 리스너 + 측정 로직을 추가하세요.</p>
      </div>
    </div>
  );
}
```

#### 포인트

* `getBoundingClientRect()` 같은 **레이아웃 읽기**는 `useLayoutEffect`에서 수행하면 페인트 전 동기 실행되어 **측정 값 기반 스타일 보정 시 깜빡임(FOUC)** 을 줄일 수 있습니다.
* 초기 표시를 `visibility: hidden`로 두고 보정 후 `visible`로 바꾸는 방식은 **초기 레이아웃 점프**를 최소화합니다.

---

### 예시 2) 스크롤 위치 제어(페인트 전 동기 스크롤)

```javascript
import React, { useLayoutEffect, useRef, useState } from 'react';

export default function Chat() {
  const listRef = useRef(null);
  const [messages, setMessages] = useState(() =>
    Array.from({ length: 30 }, (_, i) => `메시지 ${i + 1}`)
  );

  // 새 메시지 추가 시 스크롤을 맨 아래로 이동 (페인트 전)
  useLayoutEffect(() => {
    const el = listRef.current;
    if (!el) return;
    el.scrollTop = el.scrollHeight; // 동기 스크롤 → 깜빡임 최소화
  }, [messages]);

  const addMessage = () => {
    setMessages(prev => [...prev, `새 메시지 ${prev.length + 1}`]);
  };

  return (
    <div style={{ padding: 20 }}>
      <h2>useLayoutEffect: 스크롤 제어</h2>
      <div
        ref={listRef}
        style={{
          height: 200,
          overflowY: 'auto',
          border: '1px solid #ddd',
          padding: 8,
        }}
      >
        {messages.map((m, idx) => (
          <div key={idx} style={{ padding: '4px 0' }}>{m}</div>
        ))}
      </div>
      <button onClick={addMessage} style={{ marginTop: 8 }}>메시지 추가</button>
    </div>
  );
}
```

#### 포인트

* 채팅/로그 뷰에서 **새 항목 추가 시 자동 스크롤**을 페인트 전에 동기적으로 맞추면 스크롤 점프가 덜 보입니다.

---

## useEffect vs useLayoutEffect 정리

| 구분              | 실행 시점                      | 용도                     | 주의사항                 |
| --------------- | -------------------------- | ---------------------- | -------------------- |
| useEffect       | 페인트 **후**(비동기)             | 데이터 패칭, 로그, 비차단 부가 작업  | 레이아웃 측정/즉시 보정에는 부적합  |
| useLayoutEffect | DOM 업데이트 **직후, 페인트 전**(동기) | 레이아웃 측정, 동기 스크롤/스타일 보정 | 길게 실행하면 **UI 멈춤** 가능 |

---

## 자주 하는 실수와 대처

1. **불필요하게 useLayoutEffect 남발**

* 대부분의 사이드 이펙트는 `useEffect`로 충분합니다.
* **레이아웃 읽기/쓰기(측정/동기 보정)** 가 필요한 순간에만 제한적으로 사용하세요.

2. **리플로우 폭탄**

* `getBoundingClientRect`, `scrollHeight` 등은 **리플로우**를 일으킬 수 있습니다.
* 여러 요소를 측정해야 한다면 **한 번에 읽고**(read), 그 다음에 **한 번에 쓰기**(write)로 묶어 레이아웃 스래싱을 줄이세요.

3. **SSR 경고**

* React 18+에서 **서버 사이드 렌더링 환경**은 `useLayoutEffect`를 실행할 수 없습니다.
* 빌드 시 경고가 뜬다면 “isomorphic layout effect” 패턴을 사용하세요:

  ```javascript
  import { useEffect, useLayoutEffect } from 'react';
  const useIsomorphicLayoutEffect =
    typeof window !== 'undefined' ? useLayoutEffect : useEffect;
  ```

  * 브라우저에서는 `useLayoutEffect`, 서버에서는 `useEffect`로 대체.

---

## 선택 가이드

* **데이터 패칭/이벤트 구독/로깅** → `useEffect`
* **요소 크기/위치 측정 후 동기 스타일 보정** → `useLayoutEffect`
* **스크롤 위치 강제/캐럿 위치 보정/포커스 직후 레이아웃 맞춤** → `useLayoutEffect`

---

다음은 **23번 – useDebugValue 커스텀 Hook 디버깅**으로 넘어가겠습니다. 계속 진행할까요?
