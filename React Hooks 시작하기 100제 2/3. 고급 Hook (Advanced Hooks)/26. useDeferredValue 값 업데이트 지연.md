좋습니다. **26번 – useDeferredValue 값 업데이트 지연**으로 진행하겠습니다.

---

## 26. useDeferredValue 값 업데이트 지연

### 핵심 개념

* `useDeferredValue(value)`는 **주어진 값의 최신 반영을 약간 늦춰**(낮은 우선순위로) 렌더링 부담을 줄입니다.
* 타이핑 등 **즉각 반응해야 하는 UI**는 그대로 두되, 그 값으로 **비싼 연산(필터/정렬/검색 렌더)** 을 돌리는 부분만 늦춰서 부드럽게 만듭니다.
* `useTransition`이 “업데이트 블록”을 낮은 우선순위로 돌리는 것이라면, `useDeferredValue`는 “특정 값”만 늦춘다고 보면 됩니다.

---

### 파일 경로 / 파일명

```
src/App.js
```

### 예시) 대규모 리스트 검색에서 입력은 즉시, 필터링은 지연

```javascript
import React, { useMemo, useState, useDeferredValue } from 'react';

// 큰 데이터셋 생성
function createItems(size = 20000) {
  return Array.from({ length: size }, (_, i) => `Item ${i + 1}`);
}

export default function App() {
  const [input, setInput] = useState('');
  const items = useMemo(() => createItems(), []);

  // 입력 값은 즉시 반영 (input)
  // 하지만 실제 필터링에 쓰는 값은 지연(deferredInput)
  const deferredInput = useDeferredValue(input);

  // 비싼 계산: 필터링 (deferredInput이 바뀔 때만 재계산)
  const filtered = useMemo(() => {
    const q = deferredInput.trim().toLowerCase();
    if (!q) return items.slice(0, 200); // 초기에는 200개만 미리보기
    // 일부러 비용이 크다고 가정
    const res = items.filter((v) => v.toLowerCase().includes(q));
    return res.slice(0, 500); // 화면 성능 고려해 상위 500개만 표시
  }, [items, deferredInput]);

  // 지연 여부 감지: 지연 중에는 deferredInput !== input 인 경우가 흔함
  const isStale = deferredInput !== input;

  return (
    <div style={{ maxWidth: 800, margin: '40px auto', padding: '0 16px' }}>
      <h1>useDeferredValue로 검색 지연 적용</h1>

      <div style={{ marginBottom: 12 }}>
        <input
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="검색어 입력 (대규모 리스트)"
          style={{ padding: '8px 10px', width: 320 }}
        />
        {isStale && (
          <span style={{ marginLeft: 10, color: '#1e80ff' }}>
            필터링 중...
          </span>
        )}
      </div>

      <p style={{ color: '#666' }}>
        전체 {items.length.toLocaleString()}개 / 표시 {filtered.length.toLocaleString()}개
      </p>

      <ul style={{ maxHeight: 360, overflowY: 'auto', border: '1px solid #eee', padding: 8 }}>
        {filtered.map((v, i) => (
          <li key={i} style={{ padding: '4px 0', borderBottom: '1px solid #f6f6f6' }}>
            {v}
          </li>
        ))}
      </ul>
    </div>
  );
}
```

---

### 동작 설명

1. 사용자가 입력창에 타이핑하면 `input`은 **즉시** 업데이트되어 타이핑이 끊기지 않습니다.
2. 리스트 필터링은 `deferredInput`을 기준으로 수행되어, 입력 변화보다 **약간 늦게** 반영됩니다.
3. `deferredInput !== input` 동안 상단에 “필터링 중...” 같은 보조 UI를 띄워 사용자가 지연을 인지하도록 할 수 있습니다.
4. 비싼 필터 계산은 `useMemo`로 감싸고 의존성을 `deferredInput`으로 한정해 불필요한 재계산을 줄입니다.

---

### useTransition vs useDeferredValue 언제 쓰나

* **useTransition**: 특정 **업데이트 묶음**(startTransition 콜백 내부)을 낮은 우선순위로 처리하고 싶을 때. 예) 대규모 리스트 생성/렌더 전체를 지연.
* **useDeferredValue**: 특정 **값 하나**의 반영만 늦추고 싶을 때. 예) 입력값은 즉시, 그 값으로 필터링하는 계산/렌더만 늦춤.

둘을 함께 써야 할 때도 있습니다. 예를 들어:

* 검색어 입력은 `useDeferredValue`로 늦추고,
* 검색 결과의 “비싼 렌더 단계”는 `useTransition`으로 감싸서 추가로 부하를 낮추는 식.

---

### 자주 하는 실수와 팁

1. **모든 값에 무턱대고 적용**

   * UI 반응성이 중요한 값(입력, 포커스 등)에는 **적용 X**. 보통은 비싼 연산의 **입력값**에만 적용.
2. **의존성 설정 누락**

   * 비싼 계산 `useMemo`의 의존성에 **지연된 값**(예: `deferredInput`)을 넣지 않으면, 여전히 즉시 재계산되어 의미가 줄어듭니다.
3. **지연 상태 시 사용자 피드백 부족**

   * `deferredInput !== input` 동안 로딩 뱃지나 스켈레톤을 보여 사용자 경험 개선.

---

다음은 **27번 – useSyncExternalStore 외부 스토어 구독**으로 넘어가겠습니다. 계속 진행할까요?
