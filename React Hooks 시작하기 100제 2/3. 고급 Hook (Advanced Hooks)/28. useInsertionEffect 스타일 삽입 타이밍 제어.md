좋습니다. **28번 – useInsertionEffect 스타일 삽입 타이밍 제어**로 진행하겠습니다.

---

## 28. useInsertionEffect 스타일 삽입 타이밍 제어

### 핵심 개념

* `useInsertionEffect`는 **DOM 변경 → 스타일 계산 직전** 타이밍에 동기 실행됩니다.
* 주 용도: **CSS-in-JS 라이브러리의 스타일 삽입 순서 보장**(FOUC/깜빡임 방지).
* 일반 앱 로직에는 거의 필요 없습니다. 스타일 삽입 시점 제어가 필요한 특수 케이스에서만 사용하세요.

> 주의: **렌더 블로킹**입니다. 무거운 연산, 비동기 호출, 읽기/쓰기 혼합을 넣지 마세요.

---

### 파일 경로 / 파일명

```
src/App.js
```

### 예시 1) 스타일 태그를 안전한 우선순위로 삽입

```javascript
import React, { useInsertionEffect, useRef } from 'react';

function useStyleTag(cssText) {
  const styleRef = useRef(null);

  useInsertionEffect(() => {
    // 1) <style> 생성
    const styleEl = document.createElement('style');
    styleEl.setAttribute('data-app', 'dynamic'); // 디버깅용
    styleEl.appendChild(document.createTextNode(cssText));

    // 2) head 최상단에 삽입 → 다른 스타일보다 먼저 적용되도록 보장
    const head = document.head;
    head.insertBefore(styleEl, head.firstChild);
    styleRef.current = styleEl;

    // 3) 클린업: 컴포넌트 언마운트 시 제거
    return () => {
      if (styleRef.current?.parentNode) {
        styleRef.current.parentNode.removeChild(styleRef.current);
        styleRef.current = null;
      }
    };
  }, [cssText]); // 삽입할 CSS가 바뀌면 교체

  return null;
}

export default function App() {
  // 다크 테마 기본 스타일을 먼저 깔고 싶다고 가정
  useStyleTag(`
    :root { --bg: #111; --fg: #f5f5f5; --accent: #4ea1ff; }
    body { background: var(--bg); color: var(--fg); }
    .btn { padding: 8px 12px; border: 1px solid var(--accent); }
    .btn:hover { background: var(--accent); color: #000; }
  `);

  return (
    <div style={{ padding: 20 }}>
      <h1>useInsertionEffect로 스타일 삽입</h1>
      <button className="btn">버튼</button>
    </div>
  );
}
```

#### 포인트

* `head.firstChild` 앞에 삽입하여 **우선 적용**을 보장합니다.
* `useEffect`나 `useLayoutEffect`로 삽입하면 초기 페인트 이후 적용되어 **깜빡임**이 발생할 수 있습니다.

---

### 예시 2) 테마 토글 시 토큰만 교체(FOUC 최소화)

```
src/App.js
```

```javascript
import React, { useInsertionEffect, useRef, useState } from 'react';

function useThemeTokens(theme) {
  const styleRef = useRef(null);

  useInsertionEffect(() => {
    const tokens = theme === 'dark'
      ? `:root { --bg:#0e0e0e; --fg:#f2f2f2; --muted:#999; --accent:#58a6ff; }`
      : `:root { --bg:#ffffff; --fg:#222; --muted:#666; --accent:#2563eb; }`;

    const el = styleRef.current || document.createElement('style');
    el.setAttribute('data-theme-tokens', '');
    el.textContent = tokens;

    if (!styleRef.current) {
      document.head.insertBefore(el, document.head.firstChild);
      styleRef.current = el;
    }
  }, [theme]);

  // 언마운트 시 제거
  React.useEffect(() => {
    return () => {
      if (styleRef.current?.parentNode) {
        styleRef.current.parentNode.removeChild(styleRef.current);
        styleRef.current = null;
      }
    };
  }, []);
}

export default function App() {
  const [theme, setTheme] = useState('dark');
  useThemeTokens(theme);

  return (
    <div style={{ padding: 20, background: 'var(--bg)', color: 'var(--fg)', minHeight: '100vh' }}>
      <h1>토큰 기반 테마: {theme}</h1>
      <p style={{ color: 'var(--muted)' }}>FOUC 없이 토큰이 먼저 적용됩니다.</p>
      <button
        style={{ padding: '8px 12px', border: '1px solid var(--accent)' }}
        onClick={() => setTheme(t => (t === 'dark' ? 'light' : 'dark'))}
      >
        테마 전환
      </button>
    </div>
  );
}
```

#### 포인트

* 토큰 스타일을 **항상 head 최상단**에 유지하여 테마 전환 시 **스타일 우선순위 문제**를 최소화합니다.
* 토큰만 교체하므로 컴포넌트 스타일은 `var(--token)`를 사용해 자동 반영.

---

## 언제 써야 하나 / 언제 쓰지 말아야 하나

### 적합

* CSS-in-JS(Styled Components, Emotion 등) **런타임 삽입 순서 보정**이 필요한 경우
* 디자인 시스템에서 **토큰/리셋 CSS**를 항상 가장 먼저 적용해야 하는 경우
* SSR + CSR 전환(hydration)에서 **초기 페인트 깜빡임**을 반드시 줄여야 하는 경우

### 비권장

* 데이터 패칭, 이벤트 구독, 로깅 등 일반 사이드이펙트
* 무거운 계산, DOM 측정/쓰기 혼합(레이아웃 스래싱 유발)
* 사용자 상호작용과 직접 관련 없는 작업

---

## 다른 Hook와의 비교

| Hook                   | 실행 시점              | 주 용도                  |
| ---------------------- | ------------------ | --------------------- |
| useEffect              | 페인트 후(비동기)         | 데이터 패칭, 구독, 로깅        |
| useLayoutEffect        | 페인트 전(동기)          | 레이아웃 측정/동기 보정, 스크롤 강제 |
| **useInsertionEffect** | 스타일 계산 직전(더 이른 동기) | **스타일 삽입/순서 보장**      |

> 오직 **스타일 삽입 타이밍**에 초점을 맞춘 특수용입니다.

---

## SSR 고려사항

* 서버 환경에는 DOM이 없으므로, `typeof window !== 'undefined'` 체크 또는 안전하게 훅 내부에서 `document` 접근.
* 라이브러리 제작 시, 클라이언트 전용 경로에서만 `useInsertionEffect`를 사용하고 서버에서는 no-op로 대체하는 패턴이 일반적입니다.

---

다음은 **29번 – useEffect 이벤트 리스너 등록/해제**로 넘어가겠습니다. 계속 진행할까요?
