좋습니다. 이제 **87번 – useNotification 알림 관리** 예제를 보겠습니다.

---

## 87. useNotification 알림 관리

### 목표

* 브라우저 **Web Notifications API**로 데스크톱 알림 표시
* 권한 상태 추적 및 요청(`permission: default/denied/granted`)
* 탭 비활성/백그라운드에서도 동작(브라우저 정책 범위 내)
* 알림 클릭/닫힘 이벤트 핸들링, 포커스 복귀 등

---

### 파일 경로 / 파일명

```
src/hooks/useNotification.js
src/App.js
```

---

### 1) 커스텀 훅 – `useNotification.js`

```javascript
import { useCallback, useEffect, useState } from "react";

/**
 * useNotification()
 * 반환: {
 *   supported,               // 브라우저 지원 여부
 *   permission,              // 'default' | 'granted' | 'denied'
 *   requestPermission,       // 권한 요청
 *   show,                    // 알림 표시: show(title, options)
 *   canNotify,               // 실제 표시 가능 여부(permission==='granted')
 * }
 *
 * options 예시:
 *   { body, icon, tag, requireInteraction, vibrate, data, silent }
 * 이벤트:
 *   onClick, onClose, onError (옵션)
 */
export default function useNotification() {
  const supported = typeof window !== "undefined" && "Notification" in window;
  const [permission, setPermission] = useState(
    supported ? Notification.permission : "denied"
  );

  // 권한 변화 감지(일부 브라우저는 이벤트 미지원이므로 폴링은 생략)
  useEffect(() => {
    if (!supported) return;
    setPermission(Notification.permission);
  }, [supported]);

  const requestPermission = useCallback(async () => {
    if (!supported) return "denied";
    // 이미 결정된 상태면 그대로 반환
    if (Notification.permission !== "default") {
      setPermission(Notification.permission);
      return Notification.permission;
    }
    const result = await Notification.requestPermission();
    setPermission(result);
    return result;
  }, [supported]);

  const show = useCallback(
    async (title, opts = {}) => {
      if (!supported) {
        console.warn("Notifications not supported. Consider in-app fallback.");
        return null;
      }
      // 권한 없으면 요청 시도
      let perm = Notification.permission;
      if (perm === "default") {
        perm = await Notification.requestPermission();
        setPermission(perm);
      }
      if (perm !== "granted") {
        console.warn("Notification permission not granted.");
        return null;
      }

      const {
        onClick,
        onClose,
        onError,
        ...options
      } = opts;

      const n = new Notification(title, {
        // 표준 옵션
        body: options.body,
        icon: options.icon,
        tag: options.tag, // 같은 tag면 이전 알림 대체
        requireInteraction: options.requireInteraction, // 수동 닫힐 때까지 유지
        vibrate: options.vibrate, // 일부 환경 한정
        data: options.data,
        silent: options.silent,
      });

      if (onClick) {
        n.addEventListener("click", (e) => {
          try { onClick(e, n); } finally { window.focus?.(); n.close?.(); }
        });
      }
      if (onClose) n.addEventListener("close", (e) => onClose(e, n));
      if (onError) n.addEventListener("error", (e) => onError(e, n));

      return n;
    },
    [supported]
  );

  return {
    supported,
    permission,
    requestPermission,
    show,
    canNotify: supported && permission === "granted",
  };
}
```

---

### 2) 사용 예제 – `App.js`

```javascript
import React, { useState } from "react";
import useNotification from "./hooks/useNotification";

export default function App() {
  const { supported, permission, requestPermission, show, canNotify } = useNotification();
  const [count, setCount] = useState(0);

  const notify = async () => {
    await show("알림 예제", {
      body: `현재 카운트: ${count}`,
      tag: "demo-counter",
      requireInteraction: false,
      onClick: () => {
        // 알림 클릭 시 앱 창에 포커스, 상세 화면으로 이동 같은 동작 가능
        console.log("알림 클릭");
      },
      onClose: () => console.log("알림 닫힘"),
      onError: (e) => console.error("알림 에러", e),
    });
  };

  return (
    <div style={{ padding: 20 }}>
      <h1>useNotification 알림 관리</h1>
      <p>지원 여부: {String(supported)}</p>
      <p>권한 상태: {permission}</p>
      <div style={{ display: "flex", gap: 8, marginBottom: 12 }}>
        <button onClick={requestPermission}>권한 요청</button>
        <button onClick={notify} disabled={!canNotify}>알림 보내기</button>
      </div>

      <div style={{ display: "flex", gap: 8, alignItems: "center" }}>
        <button onClick={() => setCount((n) => n + 1)}>카운트 증가</button>
        <span>{count}</span>
      </div>

      {!supported && (
        <p style={{ color: "#dc2626", marginTop: 12 }}>
          이 브라우저는 데스크톱 알림을 지원하지 않습니다. 인앱 스낵바 등으로 대체하세요.
        </p>
      )}
    </div>
  );
}
```

---

## 동작/설계 포인트

* **권한 흐름**: `default → requestPermission() → granted/denied`. 대부분 사용자 제스처(버튼 클릭) 안에서 요청해야 차단되지 않습니다.
* **중복 알림**: 같은 `tag` 값을 사용하면 이전 알림이 대체되어 스팸을 줄일 수 있습니다.
* **클릭 UX**: 클릭 시 `window.focus()`로 앱 창 활성화 후 라우팅하면 자연스럽습니다.
* **포그라운드 대체**: 탭이 열려 있고 사용자 시야 안이라면 굳이 시스템 알림 대신 74번 `useSnackbar`로 대체하는 전략이 좋습니다.

## 확장 아이디어

* **Service Worker + Notification API**로 푸시(웹 푸시)까지 확장: 서버에서 푸시 트리거, SW에서 `self.registration.showNotification`.
* **권한 상태 유지**: 사용자가 `denied`면 알림 토글을 숨기거나 대체 UI를 안내.
* **일괄 닫기/관리**: `new Notification` 객체를 배열에 모아두고 `.close()`로 정리.

---

다음은 **88번 – useGeoLocation 위치 정보 가져오기**로 넘어가겠습니다. 계속 진행할까요?
