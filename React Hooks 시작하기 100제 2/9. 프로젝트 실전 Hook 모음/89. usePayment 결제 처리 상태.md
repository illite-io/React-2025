좋습니다. 이제 **89번 – usePayment 결제 처리 상태** 예제를 보겠습니다.

---

## 89. usePayment 결제 처리 상태

### 목표

* 결제 플로우의 상태(`idle → initiating → waiting_approval → approved/failed/canceled`) 관리
* 결제창(리다이렉트/팝업/SDK) 열기, 콜백 처리, 취소/재시도
* 서버 검증(웹훅/서버확인) 전후로 낙관적 UI 제어

---

### 파일 경로 / 파일명

```
src/hooks/usePayment.js
src/App.js
```

---

### 1) 커스텀 훅 – `usePayment.js`

```javascript
import { useCallback, useRef, useState } from "react";

/**
 * usePayment(provider)
 * - provider: 결제 제공자 어댑터(필수)
 *   {
 *     // 결제 세션 생성 (서버 호출) → { sessionId, redirectUrl? }
 *     createSession: (payload) => Promise<{ sessionId: string, redirectUrl?: string }>,
 *     // 사용자의 승인 완료 후 서버에 최종 확인 → { ok, txId?, reason? }
 *     confirm: (sessionId, extra?) => Promise<{ ok: boolean, txId?: string, reason?: string }>,
 *     // (선택) 팝업/SDK 열기. 없으면 redirectUrl 기반 리다이렉트로 처리
 *     openApproval?: (session) => Promise<"approved"|"canceled"|"failed">,
 *     // (선택) 취소 처리
 *     cancel?: (sessionId) => Promise<void>,
 *   }
 *
 * 반환:
 * { status, error, txId, sessionId, start, confirm, cancel, reset, setMeta, meta }
 */
export default function usePayment(provider) {
  const [status, setStatus] = useState("idle");
  const [error, setError] = useState(null);
  const [txId, setTxId] = useState(null);
  const [sessionId, setSessionId] = useState(null);
  const [meta, setMeta] = useState({}); // 금액/주문ID/PG명 등

  const pendingRef = useRef(false);

  // 1) 결제 시작: 세션 생성 → 승인 대기
  const start = useCallback(async (payload) => {
    if (!provider?.createSession) throw new Error("provider.createSession 필요");
    if (pendingRef.current) return;
    pendingRef.current = true;

    setStatus("initiating");
    setError(null);
    setTxId(null);

    try {
      const session = await provider.createSession(payload);
      setSessionId(session.sessionId);
      setStatus("waiting_approval");

      // 팝업/SDK 방식
      if (provider.openApproval) {
        const result = await provider.openApproval(session);
        if (result === "canceled") {
          setStatus("canceled");
          return { ok: false, reason: "user_canceled" };
        }
        if (result === "failed") {
          setStatus("failed");
          setError("approval_failed");
          return { ok: false, reason: "approval_failed" };
        }
        // approved → confirm 단계로 넘기지 않고 앱에서 바로 confirm 호출하도록 반환
        return { ok: true, sessionId: session.sessionId, requiresConfirm: true };
      }

      // 리다이렉트 방식: 호출자(페이지)에서 location.href로 이동하도록 URL 반환
      if (session.redirectUrl) {
        return { ok: true, redirectUrl: session.redirectUrl, sessionId: session.sessionId };
      }

      // 위 둘 다 없으면 승인 없이 바로 confirm 가능한 케이스(가상결제 등)
      return { ok: true, sessionId: session.sessionId, requiresConfirm: true };
    } catch (e) {
      setStatus("failed");
      setError(e?.message || "create_session_failed");
      return { ok: false, reason: "create_session_failed" };
    } finally {
      pendingRef.current = false;
    }
  }, [provider]);

  // 2) 승인 후 서버 확인(웹훅 완료/쿼리 수신 후) → 최종 확정
  const confirm = useCallback(async (extra) => {
    if (!provider?.confirm) throw new Error("provider.confirm 필요");
    if (!sessionId) throw new Error("세션 없음");
    setStatus("confirming");
    try {
      const res = await provider.confirm(sessionId, extra);
      if (res.ok) {
        setStatus("approved");
        setTxId(res.txId || null);
        return { ok: true, txId: res.txId };
      } else {
        setStatus("failed");
        setError(res.reason || "confirm_failed");
        return { ok: false, reason: res.reason || "confirm_failed" };
      }
    } catch (e) {
      setStatus("failed");
      setError(e?.message || "confirm_error");
      return { ok: false, reason: "confirm_error" };
    }
  }, [provider, sessionId]);

  // 3) 취소
  const cancel = useCallback(async () => {
    if (!sessionId) return;
    try {
      await provider.cancel?.(sessionId);
    } finally {
      setStatus("canceled");
    }
  }, [provider, sessionId]);

  const reset = useCallback(() => {
    setStatus("idle");
    setError(null);
    setTxId(null);
    setSessionId(null);
  }, []);

  return {
    status, error, txId, sessionId,
    start, confirm, cancel, reset,
    meta, setMeta,
  };
}
```

---

### 2) 사용 예제 – `App.js` (모의 PG 어댑터 포함)

```javascript
import React, { useMemo, useState } from "react";
import usePayment from "./hooks/usePayment";

// 모의 PG 어댑터: 서버 호출 대신 setTimeout으로 시뮬레이션
const fakeProvider = {
  async createSession(payload) {
    await sleep(300);
    // 서버에서 주문/금액 검증 후 세션 발급한다고 가정
    return {
      sessionId: "sess_" + Math.random().toString(36).slice(2, 8),
      // 팝업/리다이렉트 없이 바로 승인창 OK로 가정 → openApproval 사용
    };
  },
  async openApproval(session) {
    // 결제창(팝업/SDK) 시뮬레이션
    await sleep(600);
    if (Math.random() < 0.1) return "canceled";
    if (Math.random() < 0.1) return "failed";
    return "approved";
  },
  async confirm(sessionId) {
    // 서버에서 PG의 승인 결과를 검증(서명/금액/상태 등)
    await sleep(400);
    return { ok: true, txId: "tx_" + Date.now() };
  },
  async cancel() { await sleep(200); },
};

function sleep(ms) { return new Promise((r) => setTimeout(r, ms)); }

export default function App() {
  const provider = useMemo(() => fakeProvider, []);
  const { status, error, txId, start, confirm, cancel, reset } = usePayment(provider);
  const [amount, setAmount] = useState(49000);

  const begin = async () => {
    const res = await start({
      orderId: "ORD-" + Math.random().toString(36).slice(2, 6).toUpperCase(),
      amount,
      currency: "KRW",
      method: "card",
    });
    // openApproval을 썼으니 승인되면 confirm 수행
    if (res?.requiresConfirm) {
      await confirm();
    } else if (res?.redirectUrl) {
      // redirect 방식이라면:
      // window.location.href = res.redirectUrl;
      alert("Redirect to: " + res.redirectUrl);
    }
  };

  return (
    <div style={{ padding: 20, maxWidth: 640, margin: "0 auto" }}>
      <h1>usePayment 결제 처리 상태</h1>

      <div style={{ display: "flex", gap: 8, alignItems: "center", marginBottom: 12 }}>
        <label>금액:
          <input
            type="number"
            value={amount}
            onChange={(e) => setAmount(Number(e.target.value || 0))}
            style={{ marginLeft: 6, width: 120 }}
          />
        </label>
        <button onClick={begin} disabled={["initiating","waiting_approval","confirming"].includes(status)}>
          결제 시작
        </button>
        <button onClick={confirm} disabled={status !== "waiting_approval" && status !== "confirming"}>
          서버 확인(confirm)
        </button>
        <button onClick={cancel} disabled={status !== "waiting_approval"}>
          취소
        </button>
        <button onClick={reset}>리셋</button>
      </div>

      <div style={{ border: "1px solid #e5e7eb", borderRadius: 8, padding: 12 }}>
        <p><strong>상태:</strong> {status}</p>
        {txId && <p><strong>거래ID:</strong> {txId}</p>}
        {error && <p style={{ color: "crimson" }}><strong>에러:</strong> {error}</p>}
        <p style={{ color: "#64748b" }}>
          흐름: idle → initiating → waiting_approval → confirming → approved/failed/canceled
        </p>
      </div>
    </div>
  );
}
```

---

## 설계/확장 포인트

* **승인 단계 분리**: 실제 PG는 ①세션 생성(서버) ②사용자 승인(팝업/리다이렉트/앱카드) ③서버 검증(확정) 구조가 일반적입니다. 훅에서 이를 분리해 어떤 PG도 어댑터만 바꾸면 재사용 가능합니다.
* **리다이렉트 콜백 처리**: 리다이렉트 방식은 결제 후 `return_url`(쿼리/해시)에 세션/토큰이 도착합니다. 라우트 진입 시 `confirm(sessionId, query)`를 호출해 최종 확정합니다.
* **웹훅 동기화**: 서버가 PG 웹훅을 받아 상태를 확정했다면, 프론트는 `confirm` 없이 서버 상태를 **폴링(62번)** 하거나 **SSE/WebSocket(64\~65번)** 으로 동기화하는 패턴도 좋습니다.
* **취소/에러 처리**: 사용자 취소는 `canceled`, 결제창 오류/타임아웃은 `failed`로 명확히 구분해 CS/리트라잇 정책을 달리하세요.
* **보안**: 금액·주문ID는 **반드시 서버에서** 검증하고, 클라이언트 결과만 믿지 않습니다. 승인 성공 UI를 보여도, 서버 `confirm()` 성공 이후에 최종 완료로 표시하는 것이 안전합니다.
* **다중 PG**: `provider`를 주입식으로 만들어 토스/아임포트/Stripe/결제대행사 SDK 어댑터를 쉽게 교체할 수 있습니다.

---

다음은 **90번 – useSchedule 일정 관리**로 넘어가겠습니다. 계속 진행할까요?
