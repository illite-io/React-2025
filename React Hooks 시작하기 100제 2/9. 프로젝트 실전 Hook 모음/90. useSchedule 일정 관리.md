좋습니다. 이제 **90번 – useSchedule 일정 관리** 예제를 보겠습니다.

---

## 90. useSchedule 일정 관리

### 목표

* 일정(이벤트) 배열을 상태로 관리
* 일정 추가/수정/삭제
* 기간별 필터링, 정렬 제공
* localStorage 동기화(옵션)

---

### 파일 경로 / 파일명

```
src/hooks/useSchedule.js
src/App.js
```

---

### 1) 커스텀 훅 – `useSchedule.js`

```javascript
import { useCallback, useEffect, useMemo, useState } from "react";

/**
 * event 구조 예시:
 * { id, title, start, end, description?, allDay? }
 */
export default function useSchedule({ storageKey = "schedule.events" } = {}) {
  const [events, setEvents] = useState(() => {
    try {
      const raw = localStorage.getItem(storageKey);
      return raw ? JSON.parse(raw) : [];
    } catch {
      return [];
    }
  });

  // 저장소 동기화
  useEffect(() => {
    try {
      localStorage.setItem(storageKey, JSON.stringify(events));
    } catch {}
  }, [events, storageKey]);

  const add = useCallback((evt) => {
    setEvents((prev) => [...prev, { ...evt, id: evt.id ?? Date.now().toString() }]);
  }, []);

  const update = useCallback((id, patch) => {
    setEvents((prev) => prev.map((e) => (e.id === id ? { ...e, ...patch } : e)));
  }, []);

  const remove = useCallback((id) => {
    setEvents((prev) => prev.filter((e) => e.id !== id));
  }, []);

  const clear = useCallback(() => setEvents([]), []);

  const upcoming = useMemo(() => {
    const now = Date.now();
    return events.filter((e) => new Date(e.start).getTime() >= now)
                 .sort((a, b) => new Date(a.start) - new Date(b.start));
  }, [events]);

  const past = useMemo(() => {
    const now = Date.now();
    return events.filter((e) => new Date(e.end || e.start).getTime() < now)
                 .sort((a, b) => new Date(b.start) - new Date(a.start));
  }, [events]);

  const between = useCallback((start, end) => {
    const s = new Date(start).getTime();
    const e = new Date(end).getTime();
    return events.filter((ev) => {
      const st = new Date(ev.start).getTime();
      const en = new Date(ev.end || ev.start).getTime();
      return en >= s && st <= e;
    });
  }, [events]);

  return { events, add, update, remove, clear, upcoming, past, between };
}
```

---

### 2) 사용 예제 – `App.js`

```javascript
import React, { useState } from "react";
import useSchedule from "./hooks/useSchedule";

export default function App() {
  const { events, add, update, remove, upcoming, past, clear } = useSchedule();
  const [title, setTitle] = useState("");
  const [start, setStart] = useState("");
  const [end, setEnd] = useState("");

  const addEvent = () => {
    if (!title || !start) return;
    add({ title, start, end: end || start });
    setTitle(""); setStart(""); setEnd("");
  };

  return (
    <div style={{ padding: 20, maxWidth: 700, margin: "0 auto" }}>
      <h1>useSchedule 일정 관리</h1>

      <div style={{ display: "flex", gap: 8, marginBottom: 16 }}>
        <input
          placeholder="제목"
          value={title}
          onChange={(e) => setTitle(e.target.value)}
        />
        <input type="datetime-local" value={start} onChange={(e) => setStart(e.target.value)} />
        <input type="datetime-local" value={end} onChange={(e) => setEnd(e.target.value)} />
        <button onClick={addEvent}>추가</button>
        <button onClick={clear}>모두 삭제</button>
      </div>

      <h2>전체 일정</h2>
      {events.length === 0 && <p>등록된 일정이 없습니다.</p>}
      <ul>
        {events.map((e) => (
          <li key={e.id}>
            <strong>{e.title}</strong> ({e.start} ~ {e.end})
            <button onClick={() => update(e.id, { title: e.title + " (수정됨)" })} style={{ marginLeft: 6 }}>
              수정
            </button>
            <button onClick={() => remove(e.id)}>삭제</button>
          </li>
        ))}
      </ul>

      <h2 style={{ marginTop: 20 }}>다가오는 일정</h2>
      <ul>
        {upcoming.map((e) => (
          <li key={e.id}>{e.title} - {new Date(e.start).toLocaleString()}</li>
        ))}
        {upcoming.length === 0 && <li>없음</li>}
      </ul>

      <h2 style={{ marginTop: 20 }}>지난 일정</h2>
      <ul>
        {past.map((e) => (
          <li key={e.id}>{e.title} - {new Date(e.start).toLocaleString()}</li>
        ))}
        {past.length === 0 && <li>없음</li>}
      </ul>
    </div>
  );
}
```

---

### 동작 방식

1. `events` 상태 배열에 일정 저장
2. `add`, `update`, `remove`, `clear`로 CRUD 가능
3. `upcoming`, `past` 파생값으로 빠른 분류
4. `between(start, end)`으로 기간 검색

---

### 활용 아이디어

* 캘린더 UI와 결합하여 표시
* 알림 기능과 연동 (87번 `useNotification` 활용)
* 외부 API(Google Calendar, Outlook)와 동기화

---

다음은 **91번 – useOptimisticUpdate 낙관적 UI 업데이트**로 넘어가겠습니다. 계속 진행할까요?
