좋습니다. 이제 **86번 – useChat 채팅 메시지 관리** 예제를 보겠습니다.

---

## 86. useChat 채팅 메시지 관리

### 목표

* 채팅 메시지 배열 상태 관리
* 전송/수신 메시지 구분
* 낙관적 업데이트(보내는 중 → 성공/실패 처리)
* WebSocket·SSE 등과 쉽게 연동 가능

---

### 파일 경로 / 파일명

```
src/hooks/useChat.js
src/App.js
```

---

### 1) 커스텀 훅 – `useChat.js`

```javascript
import { useCallback, useState } from "react";

/**
 * useChat()
 * message: { id, text, sender, status }
 * - sender: "me" | "other" | "system"
 * - status: "pending" | "sent" | "failed"
 */
export default function useChat() {
  const [messages, setMessages] = useState([]);

  // 메시지 전송 (낙관적 업데이트)
  const sendMessage = useCallback((text) => {
    const id = "msg_" + Date.now();
    const newMsg = { id, text, sender: "me", status: "pending" };
    setMessages((prev) => [...prev, newMsg]);

    // 네트워크 전송 시뮬레이션
    fakeSend(text)
      .then(() => {
        setMessages((prev) =>
          prev.map((m) => (m.id === id ? { ...m, status: "sent" } : m))
        );
      })
      .catch(() => {
        setMessages((prev) =>
          prev.map((m) => (m.id === id ? { ...m, status: "failed" } : m))
        );
      });

    return id;
  }, []);

  // 외부 수신 메시지 추가
  const receiveMessage = useCallback((text) => {
    const id = "msg_" + Date.now();
    const newMsg = { id, text, sender: "other", status: "sent" };
    setMessages((prev) => [...prev, newMsg]);
  }, []);

  // 메시지 삭제
  const removeMessage = useCallback((id) => {
    setMessages((prev) => prev.filter((m) => m.id !== id));
  }, []);

  // 메시지 초기화
  const clear = useCallback(() => setMessages([]), []);

  return { messages, sendMessage, receiveMessage, removeMessage, clear };
}

// 가짜 전송 API (랜덤 성공/실패)
function fakeSend(text) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      Math.random() < 0.85 ? resolve() : reject(new Error("네트워크 오류"));
    }, 400);
  });
}
```

---

### 2) 사용 예제 – `App.js`

```javascript
import React, { useState } from "react";
import useChat from "./hooks/useChat";

export default function App() {
  const { messages, sendMessage, receiveMessage, clear } = useChat();
  const [input, setInput] = useState("");

  const handleSend = () => {
    if (input.trim()) {
      sendMessage(input.trim());
      setInput("");
    }
  };

  // 수신 시뮬레이션 버튼
  const simulateReceive = () => {
    receiveMessage("안녕하세요! (상대방)");
  };

  return (
    <div style={{ padding: 20, maxWidth: 600, margin: "0 auto" }}>
      <h1>useChat 채팅 메시지 관리</h1>

      <div
        style={{
          border: "1px solid #e5e7eb",
          borderRadius: 8,
          padding: 12,
          height: 300,
          overflowY: "auto",
          marginBottom: 12,
          background: "#f9fafb",
        }}
      >
        {messages.map((m) => (
          <div
            key={m.id}
            style={{
              display: "flex",
              justifyContent: m.sender === "me" ? "flex-end" : "flex-start",
              marginBottom: 8,
            }}
          >
            <div
              style={{
                padding: "8px 12px",
                borderRadius: 16,
                background:
                  m.sender === "me"
                    ? m.status === "failed"
                      ? "#fecaca"
                      : "#2563eb"
                    : "#e5e7eb",
                color: m.sender === "me" ? "white" : "#111827",
              }}
            >
              {m.text}
              {m.sender === "me" && (
                <small style={{ marginLeft: 6, fontSize: 10 }}>
                  {m.status === "pending"
                    ? "..."
                    : m.status === "sent"
                    ? "✓"
                    : "에러"}
                </small>
              )}
            </div>
          </div>
        ))}
        {messages.length === 0 && <p style={{ color: "#9ca3af" }}>메시지가 없습니다.</p>}
      </div>

      <div style={{ display: "flex", gap: 6 }}>
        <input
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="메시지 입력"
          style={{ flex: 1, padding: 8 }}
          onKeyDown={(e) => e.key === "Enter" && handleSend()}
        />
        <button onClick={handleSend}>전송</button>
        <button onClick={simulateReceive}>수신</button>
        <button onClick={clear}>초기화</button>
      </div>
    </div>
  );
}
```

---

### 동작 방식

1. `sendMessage()` → 메시지를 `pending` 상태로 추가 → 전송 성공 시 `sent`, 실패 시 `failed`
2. `receiveMessage()` → 상대방 메시지를 즉시 추가
3. 메시지 배열(`messages`)은 상태 기반으로 UI에 바로 반영
4. 실패 메시지에 대해 재전송 로직을 추가할 수도 있음

---

### 활용 아이디어

* WebSocket 연결하여 `receiveMessage()`를 서버 push 이벤트에 바인딩
* 실패 메시지를 클릭하면 `sendMessage()` 재시도
* 채팅방별 상태 분리: `useChat(roomId)` 형태로 확장

---

다음은 **87번 – useNotification 알림 관리** 예제로 넘어가시겠습니까?
