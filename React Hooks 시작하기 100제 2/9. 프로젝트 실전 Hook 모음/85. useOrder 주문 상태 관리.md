좋습니다. 이제 **85번 – useOrder 주문 상태 관리** 예제를 보겠습니다.

---

## 85. useOrder 주문 상태 관리

### 목표

* 주문 생성 → 결제요청 → 결제확인 → 준비 → 배송 → 완료의 **상태 머신**
* 취소/환불 등 예외 흐름 포함
* 서버 호출 래핑(`actions.*`)과 낙관적 업데이트 기본 패턴

---

### 파일 경로 / 파일명

```
src/hooks/useOrder.js
src/App.js
```

---

### 1) 커스텀 훅 – `useOrder.js`

```javascript
import { useCallback, useMemo, useReducer } from "react";

/**
 * 주문 상태 타입
 * created       : 장바구니로부터 생성되었지만 결제 전
 * payment_pending: 결제 창 대기/진행 중
 * paid          : 결제 완료(승인됨)
 * preparing     : 상품 준비/포장
 * shipping      : 배송 중(운송장 할당)
 * delivered     : 배송 완료(수령)
 * canceled      : 결제 전/후 취소(정책에 따라 다름)
 * refunded      : 환불 완료
 * failed        : 결제 실패 등 오류 상태
 */

const initialOrder = {
  id: null,
  status: "created",
  items: [],          // [{id, name, price, qty}]
  amount: 0,          // 총 결제 금액
  currency: "KRW",
  payment: null,      // {method, txnId}
  shipment: null,     // {carrier, trackingNo}
  history: [],        // [{at, status, meta?}]
  error: null,
};

function calcAmount(items) {
  return items.reduce((sum, it) => sum + (it.price ?? 0) * (it.qty ?? 1), 0);
}

function stamp(status, meta) {
  return { at: Date.now(), status, ...(meta ? { meta } : {}) };
}

function reducer(state, action) {
  switch (action.type) {
    case "INIT": {
      const items = action.items || [];
      return {
        ...initialOrder,
        id: action.id ?? `ord_${Math.random().toString(36).slice(2, 8)}`,
        items,
        amount: calcAmount(items),
        history: [stamp("created", { items: items.length })],
      };
    }
    case "SET_ERROR":
      return { ...state, error: action.error ?? "unknown" };

    case "PAYMENT_START":
      return {
        ...state,
        status: "payment_pending",
        error: null,
        history: [...state.history, stamp("payment_pending", action.meta)],
      };

    case "PAYMENT_SUCCESS":
      return {
        ...state,
        status: "paid",
        payment: { method: action.method, txnId: action.txnId },
        error: null,
        history: [...state.history, stamp("paid", { method: action.method })],
      };

    case "PAYMENT_FAILED":
      return {
        ...state,
        status: "failed",
        error: action.error || "결제 실패",
        history: [...state.history, stamp("failed", { error: action.error })],
      };

    case "PREPARING":
      return {
        ...state,
        status: "preparing",
        history: [...state.history, stamp("preparing")],
      };

    case "SHIP":
      return {
        ...state,
        status: "shipping",
        shipment: { carrier: action.carrier, trackingNo: action.trackingNo },
        history: [...state.history, stamp("shipping", { carrier: action.carrier })],
      };

    case "DELIVERED":
      return {
        ...state,
        status: "delivered",
        history: [...state.history, stamp("delivered")],
      };

    case "CANCEL":
      return {
        ...state,
        status: "canceled",
        history: [...state.history, stamp("canceled", action.meta)],
      };

    case "REFUND":
      return {
        ...state,
        status: "refunded",
        history: [...state.history, stamp("refunded", action.meta)],
      };

    default:
      return state;
  }
}

/**
 * useOrder(actions?)
 * actions: 네트워크 호출을 감싸는 선택적 구현
 * {
 *   createOrder(items) -> Promise<{id}>
 *   requestPayment(order) -> Promise<{txnId, method}>
 *   verifyPayment(txnId) -> Promise<boolean>
 *   startFulfillment(order) -> Promise<void>
 *   createShipment(order) -> Promise<{carrier, trackingNo}>
 *   markDelivered(order) -> Promise<void>
 *   cancelOrder(order) -> Promise<void>
 *   refund(order) -> Promise<void>
 * }
 */
export default function useOrder(actions = {}) {
  const [state, dispatch] = useReducer(reducer, initialOrder);

  const can = useMemo(() => {
    const s = state.status;
    return {
      pay: s === "created" || s === "failed",
      cancel: ["created", "payment_pending", "paid", "preparing"].includes(s),
      prepare: s === "paid",
      ship: s === "preparing",
      delivered: s === "shipping",
      refund: ["paid", "preparing", "shipping", "delivered"].includes(s),
    };
  }, [state.status]);

  const create = useCallback(async (items) => {
    const id = await (actions.createOrder?.(items).then(r => r?.id).catch(() => null));
    dispatch({ type: "INIT", items, id });
    return id;
  }, [actions]);

  const pay = useCallback(async () => {
    if (!can.pay) return;
    dispatch({ type: "PAYMENT_START" });

    try {
      const req = await actions.requestPayment?.(state);
      if (!req?.txnId) throw new Error("결제 시작 실패");

      // 낙관적: 바로 성공 처리 후 검증
      dispatch({ type: "PAYMENT_SUCCESS", txnId: req.txnId, method: req.method || "card" });

      const ok = await (actions.verifyPayment?.(req.txnId) ?? true);
      if (!ok) throw new Error("결제 검증 실패");
      return true;
    } catch (e) {
      dispatch({ type: "PAYMENT_FAILED", error: e?.message });
      return false;
    }
  }, [actions, can.pay, state]);

  const prepare = useCallback(async () => {
    if (!can.prepare) return;
    await actions.startFulfillment?.(state).catch((e) =>
      dispatch({ type: "SET_ERROR", error: e?.message })
    );
    dispatch({ type: "PREPARING" });
  }, [actions, can.prepare, state]);

  const ship = useCallback(async () => {
    if (!can.ship) return;
    try {
      const sp = await actions.createShipment?.(state);
      dispatch({ type: "SHIP", carrier: sp?.carrier || "CJ", trackingNo: sp?.trackingNo || "TBD" });
    } catch (e) {
      dispatch({ type: "SET_ERROR", error: e?.message });
    }
  }, [actions, can.ship, state]);

  const delivered = useCallback(async () => {
    if (!can.delivered) return;
    await actions.markDelivered?.(state).catch((e) =>
      dispatch({ type: "SET_ERROR", error: e?.message })
    );
    dispatch({ type: "DELIVERED" });
  }, [actions, can.delivered, state]);

  const cancel = useCallback(async (reason = "user_request") => {
    if (!can.cancel) return;
    await actions.cancelOrder?.(state).catch((e) =>
      dispatch({ type: "SET_ERROR", error: e?.message })
    );
    dispatch({ type: "CANCEL", meta: { reason } });
  }, [actions, can.cancel, state]);

  const refund = useCallback(async (reason = "user_request") => {
    if (!can.refund) return;
    await actions.refund?.(state).catch((e) =>
      dispatch({ type: "SET_ERROR", error: e?.message })
    );
    dispatch({ type: "REFUND", meta: { reason } });
  }, [actions, can.refund, state]);

  return {
    order: state,
    can,
    create,
    pay,
    prepare,
    ship,
    delivered,
    cancel,
    refund,
  };
}
```

---

### 2) 사용 예제 – `App.js` (모의 API와 상태 흐름)

```javascript
import React, { useMemo } from "react";
import useOrder from "./hooks/useOrder";

// 모의 비동기 API
const api = {
  async createOrder(items) {
    await wait(300);
    return { id: "ORD-" + Math.random().toString(36).slice(2, 8).toUpperCase() };
  },
  async requestPayment(order) {
    await wait(500);
    // 15% 실패 시뮬레이션
    if (Math.random() < 0.15) throw new Error("결제 창 오류");
    return { txnId: "TXN_" + Date.now(), method: "card" };
  },
  async verifyPayment(txnId) {
    await wait(300);
    return true; // 실제에선 서버사이드 검증
  },
  async startFulfillment() { await wait(200); },
  async createShipment() {
    await wait(300);
    return { carrier: "CJ", trackingNo: "1234-5678-9012" };
  },
  async markDelivered() { await wait(200); },
  async cancelOrder() { await wait(150); },
  async refund() { await wait(200); },
};

function wait(ms) { return new Promise(r => setTimeout(r, ms)); }

const cartItems = [
  { id: "sku1", name: "무지 티셔츠", price: 15000, qty: 2 },
  { id: "sku2", name: "슬랙스", price: 39000, qty: 1 },
];

export default function App() {
  const actions = useMemo(() => api, []);
  const { order, can, create, pay, prepare, ship, delivered, cancel, refund } = useOrder(actions);

  const initOrder = async () => {
    await create(cartItems);
  };

  return (
    <div style={{ padding: 20, maxWidth: 780, margin: "0 auto" }}>
      <h1>useOrder 주문 상태 관리</h1>

      <div style={{ display: "flex", gap: 8, marginBottom: 12 }}>
        <button onClick={initOrder}>주문 생성</button>
        <button onClick={pay} disabled={!can.pay}>결제하기</button>
        <button onClick={prepare} disabled={!can.prepare}>준비 시작</button>
        <button onClick={ship} disabled={!can.ship}>배송 시작</button>
        <button onClick={delivered} disabled={!can.delivered}>배송 완료</button>
        <button onClick={() => cancel("user_request")} disabled={!can.cancel}>주문 취소</button>
        <button onClick={() => refund("post_purchase")} disabled={!can.refund}>환불</button>
      </div>

      <section style={{ display: "grid", gridTemplateColumns: "1fr 1fr", gap: 16 }}>
        <div style={{ border: "1px solid #e5e7eb", borderRadius: 8, padding: 12 }}>
          <h3>주문 요약</h3>
          <p><strong>ID:</strong> {order.id || "-"}</p>
          <p><strong>상태:</strong> {order.status}</p>
          <p><strong>금액:</strong> {order.amount.toLocaleString()} {order.currency}</p>
          {order.payment && (
            <p><strong>결제:</strong> {order.payment.method} / {order.payment.txnId}</p>
          )}
          {order.shipment && (
            <p><strong>배송:</strong> {order.shipment.carrier} / {order.shipment.trackingNo}</p>
          )}
          {order.error && <p style={{ color: "crimson" }}><strong>에러:</strong> {order.error}</p>}
        </div>

        <div style={{ border: "1px solid #e5e7eb", borderRadius: 8, padding: 12 }}>
          <h3>아이템</h3>
          <ul>
            {order.items.map((it) => (
              <li key={it.id}>
                {it.name} × {it.qty} — {(it.price * it.qty).toLocaleString()}원
              </li>
            ))}
            {order.items.length === 0 && <li>없음</li>}
          </ul>
        </div>
      </section>

      <div style={{ marginTop: 16, border: "1px solid #f1f5f9", borderRadius: 8, padding: 12 }}>
        <h3>이력</h3>
        <ol>
          {order.history.map((h, i) => (
            <li key={i}>
              {new Date(h.at).toLocaleString()} — {h.status}
              {h.meta ? ` (${JSON.stringify(h.meta)})` : ""}
            </li>
          ))}
        </ol>
      </div>
    </div>
  );
}
```

---

## 동작/설계 포인트

* **상태 전이 가드**: `can.pay/cancel/ship...`으로 버튼 활성 조건을 단일화.
* **낙관적 처리 + 검증**: `PAYMENT_SUCCESS` 후 `verifyPayment()` 실패 시 `PAYMENT_FAILED`로 전환하는 변형도 가능.
* **이력 추적**: 모든 전이를 `history`에 스탬핑해 디버깅/CS 처리에 유용.
* **오류 수집**: 네트워크 예외를 `SET_ERROR`로 중앙화, UI와 알림 연동 용이.
* **확장성**: 반품(Return) 흐름, 부분환불(Partial Refund), 교환(Exchange) 등 추가 전이도 reducer에 쉽게 확장.

---

### 실무 팁

* 결제 콜백(웹훅) 기반 시스템에서는 **서버 권위 상태**를 주기적으로 폴링(62번)하거나 WebSocket/SSE(64\~65번)로 푸시받아 동기화.
* 운송장 번호 생성이 지연될 수 있으므로 `shipping_requested` 중간 상태를 두면 사용자 기대치를 관리하기 좋습니다.
* 주문 취소/환불 정책에 따라 **상태 전이 허용 범위**를 환경설정으로 외부화하여 테넌트별 정책 차이를 흡수.

---

다음은 **86번 – useChat 채팅 메시지 관리**로 이어가겠습니다. 계속 진행할까요?
