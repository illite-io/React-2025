좋습니다. 이제 **81번 – useAuth 로그인 상태 관리** 예제를 보겠습니다.

---

## 81. useAuth 로그인 상태 관리

### 목표

* 인증 토큰/사용자 정보를 안전하게 보관
* 로그인/로그아웃/프로필 갱신 함수 제공
* 새로고침 이후에도 로그인 유지(localStorage)
* 토큰 기반 API 호출 유틸 포함

---

### 파일 경로 / 파일명

```
src/hooks/useAuth.js
src/AuthProvider.js
src/App.js
```

---

### 1) 훅 – `useAuth.js`

```javascript
import { createContext, useCallback, useContext, useEffect, useMemo, useState } from "react";

const AuthContext = createContext(null);

export function AuthProvider({ children, storageKey = "auth" }) {
  const [token, setToken] = useState(null);
  const [user, setUser]   = useState(null);
  const [loading, setLoading] = useState(true);

  // 초기 복원
  useEffect(() => {
    const raw = localStorage.getItem(storageKey);
    if (raw) {
      try {
        const parsed = JSON.parse(raw);
        setToken(parsed.token ?? null);
        setUser(parsed.user ?? null);
      } catch {}
    }
    setLoading(false);
  }, [storageKey]);

  // 저장 동기화
  useEffect(() => {
    localStorage.setItem(storageKey, JSON.stringify({ token, user }));
  }, [token, user, storageKey]);

  // 로그인
  const login = useCallback(async (credentials) => {
    // 예시: 실제로는 /api/login 호출
    // const res = await fetch("/api/login", { method:"POST", body: JSON.stringify(credentials) })
    // const { token, user } = await res.json();
    const fakeToken = "demo-token-" + Date.now();
    const fakeUser  = { id: 1, name: credentials.username || "Guest" };
    setToken(fakeToken);
    setUser(fakeUser);
    return { token: fakeToken, user: fakeUser };
  }, []);

  // 로그아웃
  const logout = useCallback(() => {
    setToken(null);
    setUser(null);
    localStorage.removeItem(storageKey);
  }, [storageKey]);

  // 프로필 새로고침(서버에서 최신 사용자 정보 취득)
  const refreshProfile = useCallback(async () => {
    if (!token) return null;
    // 예시: /api/me
    // const me = await fetch("/api/me", { headers: { Authorization: `Bearer ${token}` } }).then(r=>r.json());
    const me = { ...user, refreshedAt: Date.now() };
    setUser(me);
    return me;
  }, [token, user]);

  // 인증 요청 헬퍼
  const authedFetch = useCallback(async (url, options = {}) => {
    const headers = new Headers(options.headers || {});
    if (token) headers.set("Authorization", `Bearer ${token}`);
    const res = await fetch(url, { ...options, headers });
    if (res.status === 401) {
      // 토큰 만료 처리 등
      // 필요 시 refresh token 플로우를 여기에 추가
      logout();
      throw new Error("Unauthorized");
    }
    return res;
  }, [token, logout]);

  const value = useMemo(() => ({
    token, user, loading,
    isAuthenticated: Boolean(token),
    login, logout, refreshProfile, authedFetch,
    setUser, setToken,   // 고급: 외부에서 강제 동기화가 필요할 경우
  }), [token, user, loading, login, logout, refreshProfile, authedFetch]);

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
}

export default function useAuth() {
  const ctx = useContext(AuthContext);
  if (!ctx) throw new Error("AuthProvider 안에서 사용해야 합니다.");
  return ctx;
}
```

---

### 2) 프로바이더 래퍼 – `AuthProvider.js`

```javascript
import React from "react";
import { AuthProvider } from "./hooks/useAuth";

export default function AppAuthProvider({ children }) {
  return <AuthProvider storageKey="myapp.auth">{children}</AuthProvider>;
}
```

---

### 3) 사용 예제 – `App.js`

```javascript
import React, { useState } from "react";
import AppAuthProvider from "./AuthProvider";
import useAuth from "./hooks/useAuth";

function LoginPanel() {
  const { login, loading, isAuthenticated, user, logout, refreshProfile, authedFetch } = useAuth();
  const [username, setUsername] = useState("nextstep");
  const [password, setPassword] = useState("");

  const onLogin = async () => {
    await login({ username, password });
  };

  const callApi = async () => {
    // Authorization 헤더 자동 주입
    const res = await authedFetch("https://jsonplaceholder.typicode.com/todos/1");
    const json = await res.json();
    alert("API 응답: " + JSON.stringify(json));
  };

  if (loading) return <p>초기화 중...</p>;

  return (
    <div style={{ border: "1px solid #e5e7eb", borderRadius: 8, padding: 16 }}>
      {!isAuthenticated ? (
        <>
          <h3>로그인</h3>
          <input
            placeholder="아이디"
            value={username}
            onChange={(e) => setUsername(e.target.value)}
            style={{ display: "block", marginBottom: 8 }}
          />
          <input
            placeholder="비밀번호"
            type="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            style={{ display: "block", marginBottom: 12 }}
          />
          <button onClick={onLogin}>로그인</button>
        </>
      ) : (
        <>
          <h3>안녕하세요, {user?.name}님</h3>
          <div style={{ display: "flex", gap: 8, marginTop: 8 }}>
            <button onClick={callApi}>인증 API 호출</button>
            <button onClick={refreshProfile}>프로필 새로고침</button>
            <button onClick={logout}>로그아웃</button>
          </div>
          <pre style={{ marginTop: 12, background: "#f8fafc", padding: 12 }}>
            {JSON.stringify({ user }, null, 2)}
          </pre>
        </>
      )}
    </div>
  );
}

export default function App() {
  return (
    <AppAuthProvider>
      <div style={{ padding: 20 }}>
        <h1>useAuth 로그인 상태 관리</h1>
        <LoginPanel />
      </div>
    </AppAuthProvider>
  );
}
```

---

## 포인트

* **영속성**: 토큰/사용자 정보를 `localStorage`에 저장해 새로고침 후에도 유지.
* **API 헬퍼**: `authedFetch`로 Authorization 자동 주입 및 401 처리.
* **프로필 동기화**: `refreshProfile()`로 서버의 최신 사용자 정보 반영.
* **상태 신뢰성**: 초기 복원 완료 전에는 `loading`으로 가드.

## 확장 아이디어

* **토큰 갱신(Refresh Token)** 플로우 추가: 401 시 `/auth/refresh` 호출 후 재시도.
* **역할/권한**: `roles`, `permissions`를 user에 포함하고 `usePermission`(82번)과 결합.
* **보안 강화**: 민감한 토큰은 메모리+HTTPOnly 쿠키 조합 고려, XSS에 강함.
* **서버 상태 동기화**: 로그아웃 시 서버 세션 무효화 API 호출.

---

다음은 **82번 – usePermission 권한 관리**로 넘어가겠습니다. 계속 진행할까요?
