좋습니다. **54번 – useLongPress 롱프레스 이벤트**로 진행하겠습니다.

---

## 54. useLongPress 롱프레스 이벤트

### 목표

* 마우스/터치 입력에서 **일정 시간 이상 누름**을 감지
* 짧은 탭/클릭과 롱프레스를 구분
* 모바일/데스크톱 공통 처리

---

### 파일 경로 / 파일명

```
src/hooks/useLongPress.js
src/App.js
```

---

### 1) 커스텀 훅 – `useLongPress.js`

```javascript
import { useCallback, useRef } from 'react';

/**
 * useLongPress(onLongPress, { onClick, delay, disabled }?)
 * - onLongPress: 롱프레스 시 호출
 * - onClick: 롱프레스가 아니면(짧은 탭/클릭) 호출 (선택)
 * - delay: 롱프레스 기준 시간(ms), 기본 500
 * - disabled: 비활성화 여부
 *
 * 반환: 바인딩할 이벤트 핸들러 props (onMouseDown, onMouseUp, onMouseLeave, onTouchStart, onTouchEnd, onTouchCancel)
 */
export default function useLongPress(onLongPress, opts = {}) {
  const { onClick, delay = 500, disabled = false } = opts;

  const timerRef = useRef(null);
  const longPressedRef = useRef(false); // 롱프레스 발생 여부
  const targetRef = useRef(null);       // 이벤트 타겟(선택적으로 사용할 수 있음)

  const clear = useCallback(() => {
    if (timerRef.current) {
      clearTimeout(timerRef.current);
      timerRef.current = null;
    }
  }, []);

  const start = useCallback((event) => {
    if (disabled) return;
    longPressedRef.current = false;
    targetRef.current = event.currentTarget;

    // 터치 스크롤 등 기본 동작 방해 최소화를 위해 passive는 외부에서 제어
    timerRef.current = setTimeout(() => {
      longPressedRef.current = true;
      onLongPress?.(event);
    }, delay);
  }, [delay, disabled, onLongPress]);

  const end = useCallback((event) => {
    if (disabled) return;
    clear();

    // 롱프레스가 발생하지 않았다면 일반 클릭 처리
    if (!longPressedRef.current) {
      onClick?.(event);
    }
  }, [clear, disabled, onClick]);

  const cancel = useCallback(() => {
    clear();
  }, [clear]);

  return {
    onMouseDown: start,
    onMouseUp: end,
    onMouseLeave: cancel,
    onTouchStart: start,
    onTouchEnd: end,
    onTouchCancel: cancel,
  };
}
```

---

### 2) 사용 예제 – `App.js`

```javascript
import React, { useState } from 'react';
import useLongPress from './hooks/useLongPress';

export default function App() {
  const [log, setLog] = useState([]);

  const bind = useLongPress(
    (e) => setLog((prev) => [`롱프레스: ${new Date().toLocaleTimeString()}`, ...prev]),
    {
      onClick: (e) => setLog((prev) => [`클릭: ${new Date().toLocaleTimeString()}`, ...prev]),
      delay: 600,
    }
  );

  return (
    <div style={{ padding: 20 }}>
      <h1>useLongPress 롱프레스 이벤트</h1>

      <button
        {...bind}
        style={{
          width: 220,
          height: 80,
          borderRadius: 10,
          border: '1px solid #ccc',
          background: '#f7f7f7',
          fontSize: 16,
        }}
      >
        길게 누르거나 짧게 클릭
      </button>

      <ul style={{ marginTop: 16 }}>
        {log.map((l, i) => (
          <li key={i}>{l}</li>
        ))}
      </ul>
    </div>
  );
}
```

---

## 동작 요약

* `press 시작` 시 타이머를 설정하고, `delay` 경과 시 `onLongPress` 호출.
* 손/마우스를 떼는 시점에 롱프레스가 발생하지 않았으면 `onClick` 실행.
* `mouseleave`, `touchcancel` 등에서는 타이머만 취소.

---

## 실무 팁

* 길게 누르는 동안 **시각적 피드백(진행 링/프로그레스 바)** 을 주면 UX가 좋아집니다.
* 드래그/스크롤과 충돌하는 경우가 있으면, `onTouchStart` 시점에 컨테이너의 스크롤을 잠그거나, 일정 이동 거리 이상이면 롱프레스를 취소하는 로직을 추가하세요.
* 접근성: 동일 동작을 **키보드(Enter/Space)** 로도 트리거할 수 있게 보완하면 좋습니다.

---

다음은 **55번 – useDrag 드래그 상태 관리**로 넘어가겠습니다. 계속 진행할까요?
