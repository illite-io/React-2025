좋습니다. **6번 – useState 상태 초기화 함수 사용**으로 진행하겠습니다.

---

## 6. useState 상태 초기화 함수 사용

### 언제 쓰나

* **초기값 계산 비용이 큰 경우**: 초기 렌더링 시에만 한 번 계산하고 싶을 때
* **리셋(초기값으로 되돌리기)**: 버튼 클릭 등으로 상태를 초기 상태로 되돌리고 싶을 때

---

### 파일 경로 / 파일명

```
src/App.js
```

### 예시 1) 지연 초기화(Lazy Initialization)로 무거운 초기값 한 번만 계산

```javascript
import React, { useState } from 'react';

// 비용이 큰 초기 계산 가정 (예: 대용량 배열 생성, 복잡한 파싱)
function expensiveInit() {
  console.log('[expensiveInit] 최초 한 번만 실행됩니다.');
  const data = [];
  for (let i = 0; i < 100000; i++) {
    data.push({ id: i, value: i * 2 });
  }
  // 초기 카운트는 데이터 합의 일부 규칙이라 가정
  return data.length; // 100000
}

export default function App() {
  // 함수 형태로 전달하면 최초 마운트 시에만 expensiveInit()가 실행됨
  const [count, setCount] = useState(() => expensiveInit());

  const increment = () => setCount(prev => prev + 1);

  // 초기값으로 리셋
  const reset = () => {
    // 초기화 함수를 다시 실행하고 싶다면 함수 호출 결과를 넣을 수 있음
    setCount(() => expensiveInit());
  };

  return (
    <div>
      <h1>useState 지연 초기화 + 리셋</h1>
      <p>count: {count}</p>
      <button onClick={increment}>+1</button>
      <button onClick={reset}>초기화</button>
    </div>
  );
}
```

#### 포인트

* `useState(() => expensiveInit())`처럼 **함수**를 넘기면, 초기 렌더링 때 **한 번만** 실행되어 결과가 초기값으로 사용됩니다.
* 버튼의 `reset`에서도 `setCount(() => expensiveInit())`처럼 함수 형태를 쓰면 **그 시점에 다시 계산**해서 초기화할 수 있습니다.

---

### 예시 2) 파라미터로 초기값을 만들고 리셋하기

* 실무에서는 라우트 파라미터나 부모 prop을 기반으로 초기값을 만들고, 리셋 시 **동일 규칙**으로 다시 계산하는 패턴이 자주 필요합니다.

```javascript
import React, { useState } from 'react';

// 외부 입력(예: prop, 쿼리스트링 등)으로 초기값 계산
function makeInitialValue(seed) {
  console.log('[makeInitialValue] seed 기반 초기값 계산');
  return seed * 10;
}

export default function App() {
  const seed = 7; // 예: props나 URL에서 들어왔다고 가정

  // 지연 초기화: 최초 마운트 시 seed를 사용해 초기값 계산
  const [value, setValue] = useState(() => makeInitialValue(seed));

  const inc = () => setValue(prev => prev + 1);

  const resetFromSeed = () => {
    // 현재 seed 규칙으로 다시 초기값 계산
    setValue(() => makeInitialValue(seed));
  };

  return (
    <div>
      <h1>seed 기반 초기화 + 리셋</h1>
      <p>value: {value}</p>
      <button onClick={inc}>+1</button>
      <button onClick={resetFromSeed}>seed 기준 초기화</button>
    </div>
  );
}
```

#### 포인트

* 초기화 로직을 **함수로 분리**해두면, 초기 마운트와 리셋 시 **같은 규칙**을 재사용하기 좋습니다.

---

### 자주 하는 실수와 해결책

1. **무거운 초기화 함수를 값으로 직접 호출**

```javascript
// ❌ 이렇게 하면 렌더링마다 expensiveInit()가 실행됨
const [state, setState] = useState(expensiveInit());
```

* 해결: **함수 형태**로 감싸기

```javascript
// ✅ 최초 마운트 한 번만 실행
const [state, setState] = useState(() => expensiveInit());
```

2. **props/파라미터가 바뀌어도 자동 초기화될 거라 기대**

* `useState`의 초기화 함수는 **마운트 시 한 번**만 실행됩니다.
* prop/파라미터 변경 시 자동으로 다시 초기화되지 않습니다.

해결 방법 A: **key 리렌더링 트릭**

```jsx
// 부모에서 변경되는 key를 주면 컴포넌트가 언마운트/마운트 되어 초기화가 다시 일어남
<Child key={seed} seed={seed} />
```

해결 방법 B: **useEffect로 감지 후 setState**

```javascript
import React, { useEffect, useState } from 'react';

function makeInitialValue(seed) { /* ... */ }

export default function App({ seed }) {
  const [value, setValue] = useState(() => makeInitialValue(seed));

  useEffect(() => {
    // seed가 바뀔 때마다 초기화 규칙 재적용
    setValue(makeInitialValue(seed));
  }, [seed]);

  return <div>{value}</div>;
}
```

---

### 실행 흐름 요약

1. 지연 초기화: `useState(() => fn())` 형태로 전달한 함수 `fn`은 **처음 렌더링에서만** 호출되어 초기값을 만든다.
2. 일반 업데이트: `setState(prev => ...)`로 상태 변경.
3. 리셋: 동일 초기화 함수를 다시 호출해 초기 상태로 복귀할 수 있다.
4. 외부 입력(seed/props) 변경 시 자동 초기화를 원하면 `key`를 바꾸거나 `useEffect`로 감지해 `setState`를 호출한다.

---

다음은 **7번 – useEffect 기초 마운트 시 콘솔 출력**으로 넘어가겠습니다. 계속 진행할까요?
