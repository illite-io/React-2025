좋습니다. **10번 – useEffect API 데이터 fetch** 예제로 진행하겠습니다.

---

## 10. useEffect API 데이터 fetch

### 목표

* 마운트 시 한 번 데이터 받아오기
* 로딩/에러 상태 처리
* 언마운트/의존성 변경 시 **요청 취소(AbortController)** 로 메모리 누수 방지

---

### 파일 경로 / 파일명

```
src/App.js
```

### 예시 1) 마운트 시 한 번만 데이터 가져오기

```javascript
import React, { useEffect, useState } from 'react';

export default function App() {
  const [posts, setPosts] = useState([]);     // 응답 데이터
  const [loading, setLoading] = useState(true); // 로딩 상태
  const [error, setError] = useState(null);     // 에러 상태

  useEffect(() => {
    // AbortController는 언마운트 시 fetch를 안전하게 취소하기 위해 사용
    const controller = new AbortController();

    async function fetchPosts() {
      try {
        setLoading(true);
        setError(null);

        const res = await fetch('https://jsonplaceholder.typicode.com/posts?_limit=5', {
          signal: controller.signal,
        });

        if (!res.ok) {
          throw new Error(`HTTP ${res.status}`);
        }

        const data = await res.json();
        setPosts(data);
      } catch (err) {
        // 사용자가 화면을 이동하는 등으로 요청이 취소된 경우
        if (err.name === 'AbortError') return;
        setError(err.message || '알 수 없는 오류');
      } finally {
        setLoading(false);
      }
    }

    fetchPosts();

    // cleanup: 컴포넌트가 언마운트되면 네트워크 요청 취소
    return () => controller.abort();
  }, []); // 마운트 시 한 번만 실행

  if (loading) return <p>로딩 중...</p>;
  if (error) return <p>에러: {error}</p>;

  return (
    <div>
      <h1>게시글 5개</h1>
      <ul>
        {posts.map(p => (
          <li key={p.id}>
            <strong>{p.title}</strong>
            <p>{p.body}</p>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

#### 핵심 포인트

* `AbortController`를 사용하면 언마운트 시 `controller.abort()`로 진행 중인 fetch를 취소해 **setState 경합/경고**를 예방.
* `try/catch/finally`로 로딩/에러 상태를 일관되게 관리.

---

### 예시 2) 의존성(id) 변경 시마다 재요청 + 이전 요청 취소

검색, 상세 보기 등에서 **파라미터가 바뀔 때** 재요청하는 패턴입니다.

```javascript
import React, { useEffect, useState } from 'react';

function PostDetail({ id }) {
  const [post, setPost] = useState(null);
  const [loading, setLoading] = useState(false);
  const [err, setErr] = useState(null);

  useEffect(() => {
    if (!id) return;

    const controller = new AbortController();

    async function fetchPost() {
      try {
        setLoading(true);
        setErr(null);

        const res = await fetch(`https://jsonplaceholder.typicode.com/posts/${id}`, {
          signal: controller.signal,
        });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);

        const data = await res.json();
        setPost(data);
      } catch (e) {
        if (e.name === 'AbortError') return; // 이전 요청 취소 시
        setErr(e.message || '오류');
      } finally {
        setLoading(false);
      }
    }

    fetchPost();

    // id가 바뀌거나 컴포넌트가 사라질 때, 진행 중인 요청 취소
    return () => controller.abort();
  }, [id]);

  if (!id) return <p>id가 없습니다.</p>;
  if (loading) return <p>로딩 중...</p>;
  if (err) return <p>에러: {err}</p>;
  if (!post) return null;

  return (
    <article>
      <h2>{post.title}</h2>
      <p>{post.body}</p>
    </article>
  );
}

export default function App() {
  const [id, setId] = useState(1);

  const next = () => setId(prev => (prev < 10 ? prev + 1 : 1));
  const prev = () => setId(prev => (prev > 1 ? prev - 1 : 10));

  return (
    <div>
      <h1>게시글 상세 (의존성 기반 fetch)</h1>
      <div>
        <button onClick={prev}>이전</button>
        <span style={{ margin: '0 8px' }}>현재 id: {id}</span>
        <button onClick={next}>다음</button>
      </div>
      <PostDetail id={id} />
    </div>
  );
}
```

#### 핵심 포인트

* `useEffect`의 의존성 배열에 `id`를 넣어, `id`가 바뀔 때마다 재요청.
* 이전 요청이 끝나기 전에 `id`가 바뀌면 **cleanup에서 abort**되어 레이스 컨디션 방지.

---

### 자주 하는 실수와 팁

1. **useEffect 내부에서 직접 async 사용**

```javascript
// ❌ 이렇게 하면 useEffect 콜백이 Promise를 반환하여 경고 원인
useEffect(async () => { ... }, []);
```

* 해결: **내부에 async 함수 정의 후 호출**

```javascript
useEffect(() => {
  async function run() { /* ... */ }
  run();
}, []);
```

2. **의존성 배열 누락**

* fetch에 사용하는 값(예: 검색어, id 등)을 의존성 배열에 넣지 않으면 **오래된 값**으로 요청하는 버그 가능.

3. **불필요한 재요청**

* 검색창 타이핑마다 즉시 요청하면 비효율. `useDebounce`와 조합해 최적화(이후 92번에서 다룸).

4. **중복 setState**

* 응답 처리 중 컴포넌트가 언마운트되면 setState 경고. **AbortController**로 정리.

---

원하시면 다음 **11번 전에 한 번 정리**하고, 곧바로 **11번 – useContext Context API 기본**으로 넘어가겠습니다. 계속 진행할까요?
