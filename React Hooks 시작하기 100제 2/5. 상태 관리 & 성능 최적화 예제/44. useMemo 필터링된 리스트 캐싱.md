좋습니다. 이제 **44번 – useMemo 필터링된 리스트 캐싱** 예제를 보겠습니다.

---

## 44. useMemo 필터링된 리스트 캐싱

### 핵심 개념

* 무거운 필터링/정렬 연산은 매 렌더링 때마다 실행하면 성능 저하
* `useMemo`를 사용해 **의존 값이 바뀔 때만** 연산을 수행하고, 나머지 경우에는 캐시된 값을 재사용

---

### 파일 경로 / 파일명

```
src/App.js
```

---

### 코드 예제 – 필터링된 리스트 캐싱

```javascript
import React, { useMemo, useState } from "react";

const products = [
  { id: 1, name: "노트북", price: 1500 },
  { id: 2, name: "키보드", price: 50 },
  { id: 3, name: "마우스", price: 30 },
  { id: 4, name: "모니터", price: 300 },
  { id: 5, name: "헤드셋", price: 120 },
];

export default function App() {
  const [minPrice, setMinPrice] = useState(0);
  const [keyword, setKeyword] = useState("");

  // useMemo로 필터링 결과 캐싱
  const filteredProducts = useMemo(() => {
    console.log("⚡ 필터링 연산 실행됨"); // 확인용
    return products.filter(
      (p) =>
        p.price >= minPrice &&
        p.name.toLowerCase().includes(keyword.toLowerCase())
    );
  }, [minPrice, keyword]); // minPrice 또는 keyword가 바뀔 때만 다시 실행

  return (
    <div style={{ padding: 20 }}>
      <h1>useMemo 필터링된 리스트 캐싱</h1>

      <div style={{ marginBottom: 10 }}>
        <label>
          최소 가격:{" "}
          <input
            type="number"
            value={minPrice}
            onChange={(e) => setMinPrice(Number(e.target.value))}
          />
        </label>
      </div>

      <div style={{ marginBottom: 10 }}>
        <label>
          검색어:{" "}
          <input
            type="text"
            value={keyword}
            onChange={(e) => setKeyword(e.target.value)}
          />
        </label>
      </div>

      <ul>
        {filteredProducts.map((p) => (
          <li key={p.id}>
            {p.name} - ${p.price}
          </li>
        ))}
      </ul>
    </div>
  );
}
```

---

### 실행 흐름

1. `minPrice`, `keyword` 입력값 변경 시 → `filteredProducts` 재계산
2. 그 외 상태 업데이트 → 이전 결과를 **캐시 재사용**
3. 콘솔에서 "⚡ 필터링 연산 실행됨" 메시지로 최적화 확인 가능

---

### 활용 아이디어

* 쇼핑몰 상품 리스트 필터링
* 테이블에서 조건 검색 + 정렬
* 대규모 데이터 리스트 최적화

---

👉 다음은 **45번 – useRef 무한 스크롤 구현** 예제로 넘어가겠습니다. 계속 진행할까요?
