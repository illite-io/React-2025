좋습니다. **43번 – useCallback API 호출 최적화**로 진행하겠습니다.

---

## 43. useCallback API 호출 최적화

### 목표

* 동일 파라미터로 **불필요한 재요청**을 줄이기
* 자식에 전달하는 `fetch` 핸들러 **참조 안정화**로 리렌더 최소화
* `AbortController`로 레이스 컨디션/누수 방지

---

### 파일 경로 / 파일명

```
src/App.js
```

### 예시 1) 의존성 기반으로 `fetchData`를 메모이제이션

```javascript
import React, { useCallback, useEffect, useRef, useState } from 'react';

function ResultList({ items, onReload }) {
  // onReload가 useCallback으로 고정되면 불필요한 리렌더 감소
  return (
    <div>
      <button onClick={onReload}>다시 불러오기</button>
      <ul>
        {items.map(p => <li key={p.id}>{p.title}</li>)}
      </ul>
    </div>
  );
}

export default function App() {
  const [q, setQ] = useState('react');  // 검색어
  const [posts, setPosts] = useState([]);
  const [loading, setLoading] = useState(false);
  const [err, setErr] = useState(null);

  // 진행 중 요청 취소용
  const controllerRef = useRef(null);

  // 핵심: q가 바뀔 때만 새 fetch 함수를 생성
  const fetchData = useCallback(async () => {
    // 이전 요청 취소
    controllerRef.current?.abort();
    const controller = new AbortController();
    controllerRef.current = controller;

    try {
      setLoading(true);
      setErr(null);
      const url = `https://jsonplaceholder.typicode.com/posts?_limit=5&q=${encodeURIComponent(q)}`;
      const res = await fetch(url, { signal: controller.signal });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const json = await res.json();
      setPosts(json);
    } catch (e) {
      if (e.name !== 'AbortError') setErr(e.message || '오류');
    } finally {
      setLoading(false);
      controllerRef.current = null;
    }
  }, [q]);

  // 마운트 & q 변경 시 자동 요청
  useEffect(() => {
    fetchData();
    return () => controllerRef.current?.abort();
  }, [fetchData]);

  return (
    <div style={{ padding: 20 }}>
      <h1>useCallback으로 API 호출 최적화</h1>

      <input
        value={q}
        onChange={(e) => setQ(e.target.value)}
        placeholder="검색어"
        style={{ padding: '6px 8px', width: 240 }}
      />
      {loading && <p>로딩 중...</p>}
      {err && <p style={{ color: 'crimson' }}>에러: {err}</p>}
      {!loading && !err && <ResultList items={posts} onReload={fetchData} />}
    </div>
  );
}
```

#### 포인트

* `fetchData`는 `q`가 바뀔 때만 새로 만들어져 자식 `ResultList`에 **안정된 참조** 전달.
* 진행 중 요청을 `abort()`하여 **레ース 컨디션** 방지.

---

### 예시 2) 간단 캐시(Map)로 동일 파라미터 중복 호출 방지

```javascript
import React, { useCallback, useEffect, useRef, useState } from 'react';

const cache = new Map(); // key:url → data

export default function CachedSearch() {
  const [q, setQ] = useState('sunt');
  const [data, setData] = useState([]);
  const [loading, setLoading] = useState(false);

  const controllerRef = useRef(null);

  const search = useCallback(async () => {
    const url = `https://jsonplaceholder.typicode.com/comments?postId=1&q=${encodeURIComponent(q)}`;

    // 캐시 적중 시 네트워크 스킵
    if (cache.has(url)) {
      setData(cache.get(url));
      return;
    }

    controllerRef.current?.abort();
    const controller = new AbortController();
    controllerRef.current = controller;

    try {
      setLoading(true);
      const res = await fetch(url, { signal: controller.signal });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const json = await res.json();
      cache.set(url, json);   // 캐싱
      setData(json);
    } finally {
      setLoading(false);
      controllerRef.current = null;
    }
  }, [q]);

  useEffect(() => {
    search();
    return () => controllerRef.current?.abort();
  }, [search]);

  return (
    <div style={{ padding: 20 }}>
      <h2>캐시 + useCallback</h2>
      <input
        value={q}
        onChange={(e) => setQ(e.target.value)}
        placeholder="검색어"
        style={{ padding: '6px 8px', width: 240 }}
      />
      {loading ? <p>로딩...</p> : <p>결과 {data.length}개</p>}
    </div>
  );
}
```

#### 포인트

* 동일 파라미터로 반복 호출 시 `Map` 캐시로 즉시 응답.
* 실제 서비스에서는 TTL(유효기간)이나 캐시 무효화 전략을 추가.

---

## 베스트 프랙티스 체크리스트

* `fetch` 함수는 **useCallback**으로 감싸고, **필요한 의존성만** 넣기.
* 진행 중 요청은 **AbortController**로 반드시 취소.
* 자식에게 넘길 핸들러(재요청 버튼 등)는 **안정된 참조**로 전달해 리렌더 최소화.
* 중복 호출 방지를 위해 **간단 캐시** 또는 **요청 합치기**(동일 키에 대해 인플라이트 공유) 고려.
* 입력 타이핑과 함께 호출한다면 92번의 **useDebounce**와 조합.

---

다음은 **44번 – useMemo 필터링된 리스트 캐싱**으로 넘어가겠습니다. 계속 진행할까요?
