좋습니다. **41번 – useReducer 다중 상태 관리**로 진행하겠습니다.

---

## 41. useReducer 다중 상태 관리

### 목표

* 서로 연관된 여러 상태를 **하나의 reducer**로 일관되게 관리
* 복잡한 업데이트(로딩/성공/실패, 폼 값/검증/에러 등)를 **액션 타입**으로 명확화

---

### 파일 경로 / 파일명

```
src/App.js
```

### 예시) 검색 + 페이징 + 로딩/에러를 하나의 reducer로

```javascript
import React, { useEffect, useReducer } from 'react';

// 액션 타입
const SET_QUERY = 'SET_QUERY';
const SET_PAGE = 'SET_PAGE';
const FETCH_START = 'FETCH_START';
const FETCH_SUCCESS = 'FETCH_SUCCESS';
const FETCH_ERROR = 'FETCH_ERROR';
const RESET = 'RESET';

// 상태 구조
const initialState = {
  query: '',
  page: 1,
  pageSize: 10,
  items: [],
  total: 0,
  loading: false,
  error: null,
};

// 리듀서
function reducer(state, action) {
  switch (action.type) {
    case SET_QUERY:
      return { ...state, query: action.payload, page: 1 }; // 검색어 변경 시 페이지 초기화
    case SET_PAGE:
      return { ...state, page: action.payload };
    case FETCH_START:
      return { ...state, loading: true, error: null };
    case FETCH_SUCCESS:
      return {
        ...state,
        loading: false,
        items: action.payload.items,
        total: action.payload.total,
      };
    case FETCH_ERROR:
      return { ...state, loading: false, error: action.payload };
    case RESET:
      return initialState;
    default:
      return state;
  }
}

// 서버 흉내: 검색어와 페이지로 결과 생성
function mockFetch({ query, page, pageSize }) {
  return new Promise((resolve) => {
    const base = Array.from({ length: 200 }, (_, i) => ({
      id: i + 1,
      title: `Item ${i + 1}`,
    }));
    const filtered = query
      ? base.filter((x) => x.title.toLowerCase().includes(query.toLowerCase()))
      : base;
    const start = (page - 1) * pageSize;
    const items = filtered.slice(start, start + pageSize);
    setTimeout(() => resolve({ items, total: filtered.length }), 400);
  });
}

export default function App() {
  const [state, dispatch] = useReducer(reducer, initialState);
  const { query, page, pageSize, items, total, loading, error } = state;

  // 데이터 패칭: query/page 변경될 때마다
  useEffect(() => {
    let cancelled = false;
    dispatch({ type: FETCH_START });
    mockFetch({ query, page, pageSize })
      .then((data) => {
        if (cancelled) return;
        dispatch({ type: FETCH_SUCCESS, payload: data });
      })
      .catch((e) => {
        if (cancelled) return;
        dispatch({ type: FETCH_ERROR, payload: e.message || '에러' });
      });
    return () => { cancelled = true; };
  }, [query, page, pageSize]);

  const totalPages = Math.max(1, Math.ceil(total / pageSize));

  return (
    <div style={{ maxWidth: 720, margin: '40px auto', padding: '0 16px' }}>
      <h1>useReducer로 다중 상태 관리</h1>

      {/* 검색 입력 */}
      <div style={{ display: 'flex', gap: 8, marginBottom: 12 }}>
        <input
          value={query}
          onChange={(e) => dispatch({ type: SET_QUERY, payload: e.target.value })}
          placeholder="검색어"
          style={{ flex: 1, padding: '8px 10px' }}
        />
        <button onClick={() => dispatch({ type: RESET })}>리셋</button>
      </div>

      {/* 상태 표시 */}
      <div style={{ marginBottom: 8, color: '#555' }}>
        총 {total.toLocaleString()}개 / 페이지 {page} / {totalPages}
      </div>

      {/* 리스트 */}
      {loading && <p>로딩 중...</p>}
      {error && <p style={{ color: 'crimson' }}>에러: {error}</p>}
      {!loading && !error && (
        <ul style={{ listStyle: 'none', padding: 0, margin: 0 }}>
          {items.map((item) => (
            <li key={item.id} style={{ padding: '6px 0', borderBottom: '1px solid #f1f1f1' }}>
              {item.title}
            </li>
          ))}
          {items.length === 0 && <li>결과가 없습니다.</li>}
        </ul>
      )}

      {/* 페이지네이션 */}
      <div style={{ display: 'flex', gap: 6, marginTop: 12 }}>
        <button
          onClick={() => dispatch({ type: SET_PAGE, payload: Math.max(1, page - 1) })}
          disabled={page === 1 || loading}
        >
          이전
        </button>
        <button
          onClick={() => dispatch({ type: SET_PAGE, payload: Math.min(totalPages, page + 1) })}
          disabled={page === totalPages || loading}
        >
          다음
        </button>
      </div>
    </div>
  );
}
```

---

### 핵심 포인트

* **관련 상태를 한 묶음으로**: 검색어/페이지/로딩/에러/결과를 한 리듀서에서 관리하면 로직 흐름이 명확합니다.
* **액션으로 의도를 표현**: `FETCH_START/ SUCCESS/ ERROR`로 네트워크 사이클을 표준화.
* **파생 값은 계산으로**: `totalPages`처럼 파생 값은 렌더에서 계산하거나 `useMemo`로 별도 캐싱.

---

### 변형 아이디어

* 폼 상태: `{ values, touched, errors, submitting }`를 한 리듀서로
* 위자드(멀티스텝): `{ step, data, canNext, canPrev }` + 검증 액션
* 대시보드: 여러 위젯의 로딩/데이터/에러를 위젯별 key로 묶은 리듀서

---

다음은 **42번 – useState + useEffect 로딩 상태 표시**로 넘어가겠습니다. 계속 진행할까요?
