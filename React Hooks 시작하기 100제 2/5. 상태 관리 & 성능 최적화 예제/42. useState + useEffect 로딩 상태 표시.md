좋습니다. 이제 **42번 – useState + useEffect 로딩 상태 표시** 예제를 보겠습니다.

---

## 42. useState + useEffect 로딩 상태 표시

### 핵심 개념

* API 요청이나 비동기 작업을 실행할 때 `loading` 상태를 관리해야 함
* `useState`로 `loading`, `data`, `error`를 관리
* `useEffect`에서 요청을 트리거하고, 상태 전환을 수행

---

### 파일 경로 / 파일명

```
src/App.js
```

---

### 코드 예제 – API 요청 시 로딩 상태 표시

```javascript
import React, { useState, useEffect } from "react";

// 가짜 API 호출 함수 (2초 후 데이터 반환)
function mockFetch() {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(["사과", "바나나", "포도", "오렌지"]);
    }, 2000);
  });
}

export default function App() {
  const [data, setData] = useState([]);      // API 데이터
  const [loading, setLoading] = useState(true); // 로딩 상태
  const [error, setError] = useState(null);     // 에러 상태

  useEffect(() => {
    setLoading(true);   // 요청 시작 → 로딩 true
    setError(null);     // 에러 초기화

    mockFetch()
      .then((result) => {
        setData(result);
        setLoading(false); // 성공 → 로딩 false
      })
      .catch((e) => {
        setError("데이터를 가져오는 중 오류가 발생했습니다.");
        setLoading(false); // 실패 → 로딩 false
      });
  }, []); // 컴포넌트 마운트 시 한 번 실행

  return (
    <div style={{ padding: 20 }}>
      <h1>useState + useEffect 로딩 상태 표시</h1>

      {loading && <p>⏳ 데이터를 불러오는 중입니다...</p>}
      {error && <p style={{ color: "red" }}>{error}</p>}
      {!loading && !error && (
        <ul>
          {data.map((item, idx) => (
            <li key={idx}>{item}</li>
          ))}
        </ul>
      )}
    </div>
  );
}
```

---

### 실행 흐름

1. `useEffect` 실행 → `loading = true`
2. `mockFetch` 호출 (2초 지연)
3. 성공 시 → `data` 업데이트, `loading = false`
4. 실패 시 → `error` 설정, `loading = false`

---

### 활용 아이디어

* 실시간 뉴스/주식 차트 로딩 상태 표시
* 버튼 클릭 후 로딩 스피너 표시
* 검색창 입력 시 결과 가져오기 전에 "검색 중..." 문구 출력

---

👉 다음은 **43번 – useCallback API 호출 최적화** 예제로 넘어가겠습니다. 진행할까요?
