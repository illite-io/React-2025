좋습니다. **49번 – useRef 캐러셀 구현**으로 진행하겠습니다.

---

## 49. useRef 캐러셀 구현

### 목표

* `useRef`로 **스크롤 컨테이너**와 **현재 인덱스/타이머**를 제어
* 버튼/키보드/드래그 제스처로 슬라이드 이동
* 반응형, 무한 루프(옵션), 오토플레이(옵션)

---

### 파일 경로 / 파일명

```
src/App.js
```

### 예시) 스크롤 스냅 기반 캐러셀 (간단, 성능 좋음)

```javascript
import React, { useEffect, useRef, useState } from 'react';

const slides = [
  { id: 1, color: '#0ea5e9', text: '슬라이드 1' },
  { id: 2, color: '#22c55e', text: '슬라이드 2' },
  { id: 3, color: '#f59e0b', text: '슬라이드 3' },
  { id: 4, color: '#ef4444', text: '슬라이드 4' },
];

export default function App() {
  const viewportRef = useRef(null);    // 스크롤 컨테이너
  const indexRef = useRef(0);          // 현재 인덱스(리렌더 없이 트래킹)
  const [index, setIndex] = useState(0); // 화면 표시에만 쓰는 상태
  const autoplayRef = useRef(null);    // 오토플레이 타이머
  const isDraggingRef = useRef(false); // 드래그 중 여부
  const startXRef = useRef(0);         // 드래그 시작 위치
  const scrollStartRef = useRef(0);    // 드래그 시작 시 스크롤 위치

  const slideTo = (i) => {
    const el = viewportRef.current;
    if (!el) return;
    const clamped = Math.max(0, Math.min(i, slides.length - 1));
    const child = el.children[clamped];
    if (!child) return;
    child.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'start' });
    indexRef.current = clamped;
    setIndex(clamped);
  };

  const next = () => slideTo(indexRef.current + 1);
  const prev = () => slideTo(indexRef.current - 1);

  // 뷰포트 스크롤에 맞춰 현재 인덱스 동기화 (사용자가 스와이프/휠로 넘길 때)
  useEffect(() => {
    const el = viewportRef.current;
    if (!el) return;
    let rAF = 0;
    const onScroll = () => {
      cancelAnimationFrame(rAF);
      rAF = requestAnimationFrame(() => {
        const { scrollLeft, clientWidth } = el;
        const i = Math.round(scrollLeft / clientWidth);
        if (i !== indexRef.current) {
          indexRef.current = i;
          setIndex(i);
        }
      });
    };
    el.addEventListener('scroll', onScroll, { passive: true });
    return () => {
      el.removeEventListener('scroll', onScroll);
      cancelAnimationFrame(rAF);
    };
  }, []);

  // 키보드 네비게이션
  useEffect(() => {
    const onKey = (e) => {
      if (e.key === 'ArrowRight') next();
      if (e.key === 'ArrowLeft') prev();
    };
    window.addEventListener('keydown', onKey);
    return () => window.removeEventListener('keydown', onKey);
  }, []);

  // 오토플레이 (옵션)
  useEffect(() => {
    // 3초마다 다음 슬라이드, 마지막에서 멈춤(무한 루프 원하면 모듈로 연산)
    autoplayRef.current = setInterval(() => {
      if (indexRef.current < slides.length - 1) next();
      else slideTo(0); // 무한 루프
    }, 3000);
    return () => clearInterval(autoplayRef.current);
  }, []);

  // 드래그(마우스)로 넘기기
  useEffect(() => {
    const el = viewportRef.current;
    if (!el) return;

    const onDown = (e) => {
      isDraggingRef.current = true;
      startXRef.current = e.pageX;
      scrollStartRef.current = el.scrollLeft;
      el.style.cursor = 'grabbing';
      e.preventDefault();
    };
    const onMove = (e) => {
      if (!isDraggingRef.current) return;
      const dx = e.pageX - startXRef.current;
      el.scrollLeft = scrollStartRef.current - dx;
    };
    const onUp = () => {
      if (!isDraggingRef.current) return;
      isDraggingRef.current = false;
      el.style.cursor = 'grab';
      // 드래그 종료 후 가장 가까운 슬라이드로 스냅
      const i = Math.round(el.scrollLeft / el.clientWidth);
      slideTo(i);
    };

    el.addEventListener('mousedown', onDown);
    window.addEventListener('mousemove', onMove);
    window.addEventListener('mouseup', onUp);
    el.style.cursor = 'grab';

    return () => {
      el.removeEventListener('mousedown', onDown);
      window.removeEventListener('mousemove', onMove);
      window.removeEventListener('mouseup', onUp);
      el.style.cursor = '';
    };
  }, []);

  // 터치 스와이프
  useEffect(() => {
    const el = viewportRef.current;
    if (!el) return;

    const onStart = (e) => {
      isDraggingRef.current = true;
      startXRef.current = e.touches[0].pageX;
      scrollStartRef.current = el.scrollLeft;
    };
    const onMove = (e) => {
      if (!isDraggingRef.current) return;
      const dx = e.touches[0].pageX - startXRef.current;
      el.scrollLeft = scrollStartRef.current - dx;
    };
    const onEnd = () => {
      if (!isDraggingRef.current) return;
      isDraggingRef.current = false;
      const i = Math.round(el.scrollLeft / el.clientWidth);
      slideTo(i);
    };

    el.addEventListener('touchstart', onStart, { passive: true });
    el.addEventListener('touchmove', onMove, { passive: true });
    el.addEventListener('touchend', onEnd);
    el.addEventListener('touchcancel', onEnd);
    return () => {
      el.removeEventListener('touchstart', onStart);
      el.removeEventListener('touchmove', onMove);
      el.removeEventListener('touchend', onEnd);
      el.removeEventListener('touchcancel', onEnd);
    };
  }, []);

  return (
    <div style={{ maxWidth: 720, margin: '40px auto', padding: '0 16px' }}>
      <h1>useRef 캐러셀</h1>

      {/* 뷰포트 */}
      <div
        ref={viewportRef}
        role="region"
        aria-roledescription="carousel"
        aria-label="이미지 캐러셀"
        style={{
          width: '100%',
          overflowX: 'auto',
          scrollSnapType: 'x mandatory',
          display: 'grid',
          gridAutoFlow: 'column',
          gridAutoColumns: '100%',
          borderRadius: 12,
        }}
      >
        {slides.map((s) => (
          <div
            key={s.id}
            aria-roledescription="slide"
            aria-label={`${s.id} / ${slides.length}`}
            style={{
              height: 280,
              scrollSnapAlign: 'start',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              fontSize: 28,
              fontWeight: 700,
              color: '#fff',
              userSelect: 'none',
              background: s.color,
            }}
          >
            {s.text}
          </div>
        ))}
      </div>

      {/* 컨트롤 */}
      <div style={{ display: 'flex', alignItems: 'center', gap: 8, marginTop: 12 }}>
        <button onClick={prev} aria-label="이전 슬라이드">이전</button>
        <button onClick={next} aria-label="다음 슬라이드">다음</button>
        <div style={{ marginLeft: 'auto', display: 'flex', gap: 6 }}>
          {slides.map((_, i) => (
            <button
              key={i}
              onClick={() => slideTo(i)}
              aria-label={`${i + 1}번으로 이동`}
              aria-current={i === index ? 'true' : undefined}
              style={{
                width: 10, height: 10, borderRadius: '50%',
                border: 'none',
                background: i === index ? '#111' : '#ccc'
              }}
            />
          ))}
        </div>
      </div>
    </div>
  );
}
```

---

### 핵심 포인트

* **DOM 제어에 useRef**: 컨테이너 스크롤 제어, 드래그 상태 등은 리렌더 없이 `ref.current`로 관리하면 부드럽습니다.
* **표시용 상태 최소화**: 현재 인덱스만 `useState`로. 나머지 제어용 값은 `useRef`.
* **스크롤 스냅**: CSS `scroll-snap-type/align`으로 간결하고 매끄러운 스와이프 UX.
* **rAF 동기화**: 스크롤 이벤트를 `requestAnimationFrame`으로 샘플링해 성능 안정화.
* **접근성**: `aria-roledescription="carousel"`, 슬라이드에 `aria-label`, 포커스 가능한 점 네비게이션.

---

### 확장 아이디어

* **무한 루프(가짜 클론)**: 앞뒤로 슬라이드를 복제해 끝에서 처음/처음에서 끝으로 점프 후 스냅.
* **가상화**: 매우 많은 슬라이드면 가상 리스트와 결합.
* **자동 일시정지**: 포인터 오버/포커스 시 `clearInterval`로 일시정지 후 포커스 아웃에서 재개.
* **반응형 높이**: 이미지 로딩 완료 시 `useLayoutEffect`로 실제 높이를 측정해 컨테이너 높이 애니메이션.

---

다음은 **50번 – useState 다중 입력폼 처리**로 넘어가겠습니다. 계속 진행할까요?
