좋습니다. **47번 – useDeferredValue 검색 최적화**로 진행하겠습니다.

---

## 47. useDeferredValue 검색 최적화

### 목표

* 입력은 즉시 반응시키고, 그 입력을 사용한 **비싼 필터링/렌더링만 늦춰** 부하를 줄입니다.
* `useTransition`은 “업데이트 묶음”을 늦추고, `useDeferredValue`는 “특정 값”만 늦춥니다.

---

### 파일 경로 / 파일명

```
src/App.js
```

### 예시) 대용량 데이터 검색: 입력은 즉시, 필터는 지연

```javascript
import React, { useMemo, useState, useDeferredValue } from 'react';

// 큰 리스트 생성
const bigList = Array.from({ length: 20000 }, (_, i) => ({
  id: i + 1,
  name: `항목 ${i + 1}`,
  desc: `설명 텍스트 ${i + 1}`,
}));

export default function App() {
  const [query, setQuery] = useState('');

  // 사용자가 타이핑하는 값은 즉시 갱신
  // 하지만 비싼 연산에 쓰는 값은 지연
  const deferredQuery = useDeferredValue(query);

  // 지연된 쿼리 기준으로 비싼 필터링 수행
  const results = useMemo(() => {
    const q = deferredQuery.trim().toLowerCase();
    if (!q) return bigList.slice(0, 300); // 초기엔 300개만 미리보기
    // 비용 큰 작업 가정
    const filtered = bigList.filter(
      (item) =>
        item.name.toLowerCase().includes(q) ||
        item.desc.toLowerCase().includes(q)
    );
    return filtered.slice(0, 1000); // 표시 상한
  }, [deferredQuery]);

  const isStale = deferredQuery !== query; // 지연 반영 중인지 판단

  return (
    <div style={{ maxWidth: 840, margin: '40px auto', padding: '0 16px' }}>
      <h1>useDeferredValue로 검색 최적화</h1>

      <div style={{ display: 'flex', gap: 8, alignItems: 'center', marginBottom: 12 }}>
        <input
          value={query}
          onChange={(e) => setQuery(e.target.value)}
          placeholder="검색어 입력 (대용량 리스트)"
          style={{ flex: 1, padding: '8px 10px' }}
        />
        {isStale && <span style={{ color: '#1e80ff' }}>필터링 중…</span>}
      </div>

      <p style={{ color: '#666' }}>
        전체 {bigList.length.toLocaleString()}개 / 표시 {results.length.toLocaleString()}개
      </p>

      <ul style={{ maxHeight: 420, overflow: 'auto', border: '1px solid #eee', padding: 8 }}>
        {results.map((item) => (
          <li key={item.id} style={{ padding: '6px 0', borderBottom: '1px solid #f6f6f6' }}>
            <strong>{item.name}</strong>
            <div style={{ color: '#666', fontSize: 13 }}>{item.desc}</div>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

---

### 포인트

* 입력창은 `query`로 즉시 렌더링되어 타이핑이 매끄럽습니다.
* 무거운 필터 계산은 `deferredQuery`가 갱신될 때만 실행되므로 CPU 스파이크가 줄어듭니다.
* `isStale` 표기(“필터링 중…”)로 사용자가 지연을 인지할 수 있습니다.
* 렌더 비용을 줄이기 위해 결과 개수에 상한을 두는 것도 중요합니다.

---

### useTransition과 함께 쓰는 패턴

* 결과 목록 자체 렌더가 매우 무거운 경우:

  * 값 지연: `useDeferredValue(query)`
  * 리스트 상태 갱신: `startTransition(() => setList(...))`
* 즉, 입력은 즉시, 값은 지연, 렌더는 낮은 우선순위로 처리하여 3중으로 부하를 분산합니다.

---

다음은 **48번 – useEffect 비동기 요청 취소**로 넘어가겠습니다. 계속 진행할까요?
