좋습니다. **45번 – useRef 무한 스크롤 구현**으로 진행하겠습니다.

---

## 45. useRef 무한 스크롤 구현

### 목표

* `useRef`로 **관찰 대상(sentinel)** 또는 **스크롤 컨테이너**를 참조
* `IntersectionObserver`로 마지막 요소가 보이면 다음 페이지 로드
* 클린업과 중복 호출 방지

---

### 파일 경로 / 파일명

```
src/App.js
```

### 예시 1) `IntersectionObserver` + sentinel 방식(권장)

```javascript
import React, { useCallback, useEffect, useRef, useState } from 'react';

// 서버 흉내: 페이지마다 20개씩 반환
const fetchPage = (page, size = 20) =>
  new Promise((resolve) => {
    setTimeout(() => {
      const start = (page - 1) * size;
      const items = Array.from({ length: size }, (_, i) => ({
        id: start + i + 1,
        text: `아이템 #${start + i + 1}`,
      }));
      const hasMore = page < 10; // 총 10페이지 가정
      resolve({ items, hasMore });
    }, 500);
  });

export default function App() {
  const [page, setPage] = useState(1);
  const [list, setList] = useState([]);
  const [hasMore, setHasMore] = useState(true);
  const [loading, setLoading] = useState(false);

  // 관찰용 sentinel
  const sentinelRef = useRef(null);
  // 중복 로드 방지용 플래그
  const loadingRef = useRef(false);
  // IntersectionObserver 인스턴스 보관
  const observerRef = useRef(null);

  const load = useCallback(async () => {
    if (!hasMore || loadingRef.current) return;
    loadingRef.current = true;
    setLoading(true);

    const { items, hasMore: nextHasMore } = await fetchPage(page);
    setList(prev => [...prev, ...items]);
    setHasMore(nextHasMore);
    setPage(prev => prev + 1);

    setLoading(false);
    loadingRef.current = false;
  }, [page, hasMore]);

  useEffect(() => {
    if (!sentinelRef.current) return;

    // 기존 옵저버 해제
    observerRef.current?.disconnect();

    // 새 옵저버 생성
    const ob = new IntersectionObserver(
      (entries) => {
        const entry = entries[0];
        if (entry.isIntersecting) {
          // sentinel이 보이면 다음 페이지 로드
          load();
        }
      },
      {
        root: null,          // viewport 기준
        rootMargin: '200px', // 근접 시점부터 미리 로드
        threshold: 0,
      }
    );

    ob.observe(sentinelRef.current);
    observerRef.current = ob;

    return () => ob.disconnect();
  }, [load]);

  // 초기 1페이지 불러오기
  useEffect(() => {
    if (list.length === 0) load();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  return (
    <div style={{ maxWidth: 560, margin: '40px auto', padding: '0 16px' }}>
      <h1>useRef + IntersectionObserver 무한 스크롤</h1>

      <ul style={{ listStyle: 'none', padding: 0, margin: 0 }}>
        {list.map(item => (
          <li key={item.id} style={{ padding: '10px 0', borderBottom: '1px solid #eee' }}>
            {item.text}
          </li>
        ))}
      </ul>

      {/* sentinel: 리스트 끝에 배치 */}
      <div ref={sentinelRef} style={{ height: 1 }} />

      {loading && <p style={{ color: '#666' }}>불러오는 중...</p>}
      {!hasMore && <p style={{ color: '#888', marginTop: 8 }}>더 이상 데이터가 없습니다.</p>}
    </div>
  );
}
```

#### 포인트

* `sentinelRef`가 뷰포트 근처에 들어오면 `load()` 호출.
* `loadingRef.current`로 **중복 호출 방지**.
* `rootMargin`으로 **미리 로드** 시점을 앞당겨 끊김 최소화.
* 옵저버는 `useEffect`에서 생성/해제하여 누수 방지.

---

### 예시 2) 스크롤 컨테이너 내부에서 감지

* 스크롤 가능한 박스 안에서만 무한 스크롤을 하고 싶을 때.

```javascript
import React, { useCallback, useEffect, useRef, useState } from 'react';

const fetchPage = (page, size = 30) =>
  new Promise((resolve) => {
    setTimeout(() => {
      const start = (page - 1) * size;
      const items = Array.from({ length: size }, (_, i) => ({
        id: start + i + 1,
        text: `행 #${start + i + 1}`,
      }));
      const hasMore = page < 5;
      resolve({ items, hasMore });
    }, 400);
  });

export default function ScrollBox() {
  const [rows, setRows] = useState([]);
  const [page, setPage] = useState(1);
  const [hasMore, setHasMore] = useState(true);
  const [loading, setLoading] = useState(false);

  const boxRef = useRef(null);
  const sentinelRef = useRef(null);
  const loadingRef = useRef(false);
  const observerRef = useRef(null);

  const load = useCallback(async () => {
    if (!hasMore || loadingRef.current) return;
    loadingRef.current = true;
    setLoading(true);
    const { items, hasMore: next } = await fetchPage(page);
    setRows(prev => [...prev, ...items]);
    setHasMore(next);
    setPage(p => p + 1);
    setLoading(false);
    loadingRef.current = false;
  }, [page, hasMore]);

  useEffect(() => {
    if (!boxRef.current || !sentinelRef.current) return;

    observerRef.current?.disconnect();
    const ob = new IntersectionObserver(
      (entries) => {
        if (entries[0].isIntersecting) load();
      },
      {
        root: boxRef.current, // 컨테이너 기준
        rootMargin: '150px',
        threshold: 0,
      }
    );
    ob.observe(sentinelRef.current);
    observerRef.current = ob;

    return () => ob.disconnect();
  }, [load]);

  useEffect(() => {
    if (rows.length === 0) load();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  return (
    <div style={{ padding: 20 }}>
      <h2>컨테이너 내부 무한 스크롤</h2>
      <div
        ref={boxRef}
        style={{
          height: 300,
          overflow: 'auto',
          border: '1px solid #ddd',
          borderRadius: 6,
          padding: '0 10px',
        }}
      >
        <ul style={{ listStyle: 'none', padding: 0, margin: 0 }}>
          {rows.map(r => (
            <li key={r.id} style={{ padding: '8px 0', borderBottom: '1px solid #f1f1f1' }}>
              {r.text}
            </li>
          ))}
        </ul>
        <div ref={sentinelRef} style={{ height: 1 }} />
        {loading && <p style={{ color: '#666' }}>로딩...</p>}
      </div>
      {!hasMore && <p style={{ color: '#888', marginTop: 8 }}>끝까지 불러왔습니다.</p>}
    </div>
  );
}
```

---

## 실무 팁

1. 로딩 중복 방지

* 네트워크 지연/관찰 이벤트 중복 시 `loadingRef.current` 같은 **가변 ref 플래그**로 한 번에 하나의 로드만 허용.

2. 프리패치 범위 조절

* `rootMargin`을 적절히 키우면 사용자가 끝에 도달하기 **이전**에 미리 다음 페이지를 불러와 끊김이 줄어듭니다.

3. 에러/재시도 UX

* `try/catch`로 에러 상태를 노출하고, “다시 시도” 버튼에서 같은 `load()`를 호출.

4. 키 충돌 및 중복 데이터

* 서버 페이징 키(id, cursor)를 기반으로 **중복 합치기**를 가드.

5. 가상 스크롤과 결합

* 데이터가 매우 크면 `react-window`/`react-virtualized`로 **가상화**해 렌더 오버헤드를 줄이세요.
  무한 스크롤은 데이터 페치 레이어, 가상 스크롤은 렌더 레이어로 역할을 분리.

---

다음은 **46번 – useTransition 대규모 리스트 렌더링 최적화**로 넘어가겠습니다. 계속 진행할까요?
