좋습니다. **18번 – useMemo 무거운 연산 최적화**로 진행하겠습니다.

---

## 18. useMemo 무거운 연산 최적화

### 목표

* 큰 리스트의 **검색/필터/정렬/집계**처럼 비용이 큰 계산을 `useMemo`로 캐싱
* 의존성이 바뀔 때만 재계산하여 렌더링 성능 개선

---

### 파일 경로 / 파일명

```
src/App.js
```

### 예시 1) 대규모 리스트 필터 + 정렬 + 집계 최적화

```javascript
import React, { useMemo, useState } from 'react';

// 더미 데이터 2만 건 생성(초기 한 번)
function createProducts(size = 20000) {
  const categories = ['book', 'electronics', 'fashion', 'grocery'];
  const arr = new Array(size).fill(0).map((_, i) => ({
    id: i + 1,
    name: `Item ${i + 1}`,
    price: Math.floor(Math.random() * 100000), // 0~99999
    stock: Math.floor(Math.random() * 500),    // 재고
    category: categories[i % categories.length],
    rating: (Math.random() * 5).toFixed(1),
  }));
  return arr;
}

export default function App() {
  // 초기 큰 배열: 지연 초기화로 최초 렌더에서만 생성
  const [products] = useState(() => createProducts());
  const [query, setQuery] = useState('');
  const [minPrice, setMinPrice] = useState(0);
  const [onlyInStock, setOnlyInStock] = useState(false);
  const [sortKey, setSortKey] = useState('price'); // price | rating | stock
  const [sortDir, setSortDir] = useState('asc');   // asc | desc

  // 무거운 파이프라인: filter → sort → slice → aggregate
  const { view, totalCount, totalValue, avgPrice } = useMemo(() => {
    // 1) 필터링
    const q = query.trim().toLowerCase();
    let filtered = products;

    if (q) {
      // 이름에 쿼리가 포함되는지
      filtered = filtered.filter(p => p.name.toLowerCase().includes(q));
    }
    if (minPrice > 0) {
      filtered = filtered.filter(p => p.price >= Number(minPrice));
    }
    if (onlyInStock) {
      filtered = filtered.filter(p => p.stock > 0);
    }

    // 2) 정렬 (원본 불변성 유지 위해 복사 후 정렬)
    const sorted = [...filtered].sort((a, b) => {
      const dir = sortDir === 'asc' ? 1 : -1;
      if (sortKey === 'price') return (a.price - b.price) * dir;
      if (sortKey === 'rating') return (parseFloat(a.rating) - parseFloat(b.rating)) * dir;
      if (sortKey === 'stock') return (a.stock - b.stock) * dir;
      return 0;
    });

    // 3) 화면에 보여줄 일부만 잘라서 전달(페이징/무한스크롤의 첫 페이지 가정)
    const view = sorted.slice(0, 50);

    // 4) 집계(총합/평균 등)
    const totalCount = filtered.length;
    const totalValue = filtered.reduce((sum, p) => sum + p.price, 0);
    const avgPrice = totalCount ? Math.round(totalValue / totalCount) : 0;

    return { view, totalCount, totalValue, avgPrice };
  }, [products, query, minPrice, onlyInStock, sortKey, sortDir]);

  // 메모: products는 useState 지연 초기화로 참조가 안정적이므로 불필요한 재계산 없음
  // 의존성 중 하나라도 바뀌면 위의 무거운 연산이 그때만 수행됨

  return (
    <div style={{ maxWidth: 900, margin: '40px auto', padding: '0 16px' }}>
      <h1>useMemo로 무거운 리스트 연산 최적화</h1>

      {/* 컨트롤 바 */}
      <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr 1fr 1fr 1fr 1fr', gap: 8, marginBottom: 12 }}>
        <input
          placeholder="검색어 (name)"
          value={query}
          onChange={(e) => setQuery(e.target.value)}
        />
        <input
          type="number"
          min="0"
          placeholder="최소가격"
          value={minPrice}
          onChange={(e) => setMinPrice(e.target.value)}
        />
        <label style={{ display: 'flex', alignItems: 'center', gap: 6 }}>
          <input
            type="checkbox"
            checked={onlyInStock}
            onChange={(e) => setOnlyInStock(e.target.checked)}
          />
          재고상품만
        </label>
        <select value={sortKey} onChange={(e) => setSortKey(e.target.value)}>
          <option value="price">가격</option>
          <option value="rating">평점</option>
          <option value="stock">재고</option>
        </select>
        <select value={sortDir} onChange={(e) => setSortDir(e.target.value)}>
          <option value="asc">오름차순</option>
          <option value="desc">내림차순</option>
        </select>
        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'flex-end', color: '#555' }}>
          총 {totalCount.toLocaleString()}개 / 평균가 {avgPrice.toLocaleString()}원
        </div>
      </div>

      {/* 리스트(최대 50개만 미리보기) */}
      <table width="100%" cellPadding="6" style={{ borderCollapse: 'collapse' }}>
        <thead>
          <tr style={{ borderBottom: '1px solid #ddd', textAlign: 'left' }}>
            <th>ID</th>
            <th>이름</th>
            <th>카테고리</th>
            <th>가격</th>
            <th>재고</th>
            <th>평점</th>
          </tr>
        </thead>
        <tbody>
          {view.map(p => (
            <tr key={p.id} style={{ borderBottom: '1px solid #f0f0f0' }}>
              <td>{p.id}</td>
              <td>{p.name}</td>
              <td>{p.category}</td>
              <td>{p.price.toLocaleString()}원</td>
              <td>{p.stock}</td>
              <td>{p.rating}</td>
            </tr>
          ))}
        </tbody>
      </table>

      <p style={{ marginTop: 8, color: '#777' }}>
        표시 중: {view.length}개 / 총합: {totalValue.toLocaleString()}원
      </p>
    </div>
  );
}
```

#### 포인트

* `useState(() => createProducts())`로 **대용량 초기 데이터**를 최초 한 번만 생성.
* 필터/정렬/집계가 **의존성**이 바뀔 때만 실행되도록 `useMemo`로 감쌉니다.
* 정렬 시 원본 불변성 유지: `const sorted = [...filtered].sort(...)`.
* 렌더 비용을 낮추기 위해 \*\*첫 페이지(50개)\*\*만 먼저 보여주고, 실제 앱에서는 무한스크롤/가상 스크롤과 결합.

---

### 예시 2) 파생 값(Selector) 메모이제이션 분리

* 동일한 원본 데이터에서 **여러 파생 값**을 사용할 때도 각각 `useMemo`로 분리하여 필요할 때만 재계산.

```
src/hooks/useProductSelectors.js
```

```javascript
import { useMemo } from 'react';

export function useProductSelectors(products) {
  const totalCount = products.length;

  const totalValue = useMemo(
    () => products.reduce((sum, p) => sum + p.price, 0),
    [products]
  );

  const avgPrice = useMemo(
    () => (totalCount ? Math.round(totalValue / totalCount) : 0),
    [totalCount, totalValue]
  );

  // 카테고리별 집계
  const byCategory = useMemo(() => {
    const map = new Map();
    for (const p of products) {
      const stat = map.get(p.category) || { count: 0, sum: 0 };
      stat.count += 1;
      stat.sum += p.price;
      map.set(p.category, stat);
    }
    return Array.from(map, ([category, { count, sum }]) => ({
      category,
      count,
      avg: Math.round(sum / count),
    }));
  }, [products]);

  return { totalCount, totalValue, avgPrice, byCategory };
}
```

> 이렇게 훅으로 분리하면 화면 컴포넌트가 단순해지고, 필요 집계가 추가되어도 재사용 가능.

---

## 성능 최적화 체크리스트

1. **무거운 계산은 useMemo로 감싸기**

* 의존성 정확히 선언: 누락 시 오래된 값 사용, 과다 선언 시 불필요 재계산.

2. **초기 대용량 데이터는 지연 초기화**

* `useState(() => bigInit())` 패턴으로 최초 렌더 한 번만 생성.

3. **정렬/필터에서 불변성 유지**

* 원본 배열을 복사(`[...]`) 후 정렬/가공. 직접 변형하면 버그 및 예상치 못한 렌더.

4. **가상 스크롤/페이징 병행**

* 데이터가 매우 클 때는 `react-window`, `react-virtualized` 같은 가상 리스트를 고려.

5. **불필요한 함수/객체 재생성 방지**

* 핸들러는 `useCallback`, 파생 객체는 `useMemo`로 참조 안정화 → 자식 리렌더 최소화.

6. **Web Worker 고려**

* 계산 자체가 너무 무거우면 UI 스레드를 막지 않도록 Web Worker로 오프로딩.

---

다음은 **19번 – useRef DOM 요소 접근**으로 넘어가겠습니다. 계속 진행할까요?
