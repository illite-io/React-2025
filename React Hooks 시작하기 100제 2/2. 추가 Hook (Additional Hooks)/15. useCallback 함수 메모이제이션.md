좋습니다. 이제 **15번 – useCallback 함수 메모이제이션** 예제를 보겠습니다.

---

## 15. useCallback 함수 메모이제이션

### 목표

* 함수가 매번 새로 만들어져 불필요한 렌더링을 유발하는 문제 방지
* 자식 컴포넌트에 함수를 props로 전달할 때 성능 최적화

---

### 파일 경로 / 파일명

```
src/App.js
```

### 예시 코드

```javascript
import React, { useState, useCallback } from 'react';

// 자식 컴포넌트
const Child = React.memo(({ onClick }) => {
  console.log("Child 렌더링");
  return (
    <button onClick={onClick}>자식 버튼</button>
  );
});

export default function App() {
  const [count, setCount] = useState(0);
  const [text, setText] = useState("");

  // useCallback으로 함수 메모이제이션
  const handleClick = useCallback(() => {
    alert("Child 버튼 클릭됨!");
  }, []); 
  // [] → 의존성이 없으므로 최초 마운트 시에만 함수 생성

  return (
    <div>
      <h1>useCallback 예제</h1>
      <p>카운트: {count}</p>
      <button onClick={() => setCount(count + 1)}>카운트 +1</button>

      <br /><br />
      <input 
        type="text" 
        value={text} 
        onChange={(e) => setText(e.target.value)} 
        placeholder="텍스트 입력"
      />

      <Child onClick={handleClick} />
    </div>
  );
}
```

---

### 코드 설명

1. **문제 상황**

   * 보통 `onClick={() => ...}` 같은 함수를 정의하면 **렌더링마다 새 함수 객체가 생성**됨
   * 자식 컴포넌트에 props로 전달되면, `React.memo`로 감싸도 **props가 바뀐 걸로 인식** → 불필요한 리렌더링

2. **해결 방법 – useCallback**

   ```javascript
   const memoizedFn = useCallback(() => {
     // 함수 내용
   }, [의존성]);
   ```

   * 지정한 의존성이 바뀌지 않는 한, 동일한 함수 객체를 재사용
   * 자식에게 같은 참조를 전달하므로 불필요한 리렌더링 방지

3. **예제 흐름**

   * `count`가 바뀌어 App은 리렌더링됨
   * `handleClick`은 `useCallback([])` 덕분에 같은 참조 유지
   * 따라서 `Child`는 리렌더링 되지 않음 (`console.log("Child 렌더링")`이 안 찍힘)

---

### 실행 흐름

1. 페이지 처음 로드 → `Child` 렌더링됨
2. "카운트 +1" 클릭 → App만 리렌더링, `Child`는 그대로
3. input에 값 입력 → App 리렌더링, `Child`는 그대로
4. `Child` 버튼 클릭 → alert 실행

---

다음은 **16번 – useCallback 자식 컴포넌트 렌더링 최적화** 예제로 넘어가겠습니다. 진행할까요?
