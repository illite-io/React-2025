좋습니다. **14번 – useReducer Todo 리스트 관리**로 넘어가겠습니다.

---

## 14. useReducer Todo 리스트 관리

### 목표

* `useReducer`로 Todo 항목 추가/완료 토글/수정/삭제/완료 항목 일괄 삭제까지 처리
* 액션 타입을 명확히 정의하고 불변성 유지

---

### 파일 경로 / 파일명

```
src/App.js
```

### 예시 코드

```javascript
import React, { useReducer, useRef, useState } from 'react';

/** 액션 타입 상수 */
const ADD = 'ADD';
const TOGGLE = 'TOGGLE';
const REMOVE = 'REMOVE';
const EDIT = 'EDIT';
const CLEAR_COMPLETED = 'CLEAR_COMPLETED';

/** 고유 id 생성 유틸 (충돌 낮춤) */
function generateId() {
  return `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
}

/** 상태 구조
 * {
 *   todos: [{ id, text, completed }]
 * }
 */
const initialState = {
  todos: [],
};

/** reducer: 상태 변경 규칙을 한곳에 모음 */
function reducer(state, action) {
  switch (action.type) {
    case ADD: {
      const text = action.payload.text?.trim();
      if (!text) return state; // 공백 방지
      const newTodo = { id: generateId(), text, completed: false };
      return { ...state, todos: [newTodo, ...state.todos] };
    }
    case TOGGLE: {
      const id = action.payload.id;
      return {
        ...state,
        todos: state.todos.map(t =>
          t.id === id ? { ...t, completed: !t.completed } : t
        ),
      };
    }
    case REMOVE: {
      const id = action.payload.id;
      return { ...state, todos: state.todos.filter(t => t.id !== id) };
    }
    case EDIT: {
      const { id, text } = action.payload;
      const next = text.trim();
      if (!next) {
        // 빈 문자열로 수정 시 삭제 처리(선택)
        return { ...state, todos: state.todos.filter(t => t.id !== id) };
      }
      return {
        ...state,
        todos: state.todos.map(t =>
          t.id === id ? { ...t, text: next } : t
        ),
      };
    }
    case CLEAR_COMPLETED: {
      return { ...state, todos: state.todos.filter(t => !t.completed) };
    }
    default:
      return state;
  }
}

/** 단일 Todo 아이템 컴포넌트 */
function TodoItem({ todo, onToggle, onRemove, onEdit }) {
  const [isEditing, setIsEditing] = useState(false);
  const [draft, setDraft] = useState(todo.text);
  const inputRef = useRef(null);

  const handleStartEdit = () => {
    setIsEditing(true);
    // 다음 tick에 포커스 이동
    setTimeout(() => inputRef.current?.focus(), 0);
  };

  const handleConfirmEdit = () => {
    onEdit(todo.id, draft);
    setIsEditing(false);
  };

  const handleKeyDown = (e) => {
    if (e.key === 'Enter') handleConfirmEdit();
    if (e.key === 'Escape') {
      setDraft(todo.text);
      setIsEditing(false);
    }
  };

  return (
    <li
      style={{
        display: 'flex',
        alignItems: 'center',
        gap: 8,
        padding: '6px 0',
      }}
    >
      <input
        type="checkbox"
        checked={todo.completed}
        onChange={() => onToggle(todo.id)}
        aria-label="완료 토글"
      />

      {isEditing ? (
        <input
          ref={inputRef}
          value={draft}
          onChange={(e) => setDraft(e.target.value)}
          onKeyDown={handleKeyDown}
          onBlur={handleConfirmEdit}
          style={{ flex: 1, padding: '6px 8px' }}
          aria-label="할 일 편집"
        />
      ) : (
        <span
          onDoubleClick={handleStartEdit}
          style={{
            flex: 1,
            textDecoration: todo.completed ? 'line-through' : 'none',
            color: todo.completed ? '#888' : '#222',
            cursor: 'text',
          }}
          title="더블클릭하여 편집"
        >
          {todo.text}
        </span>
      )}

      <button onClick={handleStartEdit}>수정</button>
      <button onClick={() => onRemove(todo.id)}>삭제</button>
    </li>
  );
}

/** 메인 App */
export default function App() {
  const [state, dispatch] = useReducer(reducer, initialState);
  const [input, setInput] = useState('');
  const inputRef = useRef(null);

  const addTodo = () => {
    dispatch({ type: ADD, payload: { text: input } });
    setInput('');
    inputRef.current?.focus();
  };

  const handleKeyDown = (e) => {
    if (e.key === 'Enter') addTodo();
  };

  const onToggle = (id) => dispatch({ type: TOGGLE, payload: { id } });
  const onRemove = (id) => dispatch({ type: REMOVE, payload: { id } });
  const onEdit = (id, text) => dispatch({ type: EDIT, payload: { id, text } });
  const clearCompleted = () => dispatch({ type: CLEAR_COMPLETED });

  const total = state.todos.length;
  const completed = state.todos.filter(t => t.completed).length;
  const active = total - completed;

  return (
    <div style={{ maxWidth: 520, margin: '40px auto', padding: '0 16px' }}>
      <h1>useReducer로 Todo 관리</h1>

      {/* 입력 영역 */}
      <div style={{ display: 'flex', gap: 8, marginBottom: 12 }}>
        <input
          ref={inputRef}
          value={input}
          onChange={(e) => setInput(e.target.value)}
          onKeyDown={handleKeyDown}
          placeholder="할 일을 입력하고 Enter"
          style={{ flex: 1, padding: '8px 10px' }}
          aria-label="할 일 입력"
        />
        <button onClick={addTodo}>추가</button>
      </div>

      {/* 카운터 & 액션 */}
      <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: 8 }}>
        <div>
          <strong>전체:</strong> {total} / <strong>진행중:</strong> {active} / <strong>완료:</strong> {completed}
        </div>
        <button onClick={clearCompleted} disabled={completed === 0}>
          완료 항목 삭제
        </button>
      </div>

      {/* 리스트 */}
      <ul style={{ listStyle: 'none', padding: 0, margin: 0 }}>
        {state.todos.map(todo => (
          <TodoItem
            key={todo.id}
            todo={todo}
            onToggle={onToggle}
            onRemove={onRemove}
            onEdit={onEdit}
          />
        ))}
        {state.todos.length === 0 && (
          <li style={{ color: '#777', padding: '8px 0' }}>할 일을 추가해 보세요.</li>
        )}
      </ul>
    </div>
  );
}
```

---

### 해설 및 포인트

* **단일 출처의 진실(Single Source of Truth)**: 모든 로직을 `reducer`에 모아 상태 변경 경로가 명확합니다.
* **불변성 유지**: `map`, `filter`, 스프레드(`...`)로 새 배열/객체를 만들어 반환합니다.
* **편집 UX**: 더블클릭으로 편집 시작, `Enter` 저장, `Escape` 취소, `blur` 시 자동 저장.
* **일괄 삭제**: 완료 항목만 필터링하여 정리하는 `CLEAR_COMPLETED` 제공.
* **접근성 튜닝**: checkbox `aria-label`, 입력 `aria-label` 부여.

---

### 테스트 체크리스트

* [ ] 할 일 추가 시 상단에 새 항목이 생기는가
* [ ] 체크박스 토글 시 취소선/색상 변경되는가
* [ ] 더블클릭 또는 \[수정] 클릭 후 Enter/Blur로 저장되는가 (Escape는 취소)
* [ ] \[삭제] 클릭 시 해당 항목만 제거되는가
* [ ] \[완료 항목 삭제]가 완료가 0일 때 비활성화되는가
* [ ] 카운터(전체/진행중/완료)가 정확한가

---

다음은 **15번 – useCallback 함수 메모이제이션**으로 넘어가겠습니다. 계속 진행할까요?
