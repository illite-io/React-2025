좋습니다. 이제 **17번 – useMemo 계산 결과 메모이제이션** 예제로 넘어가겠습니다.

---

## 17. useMemo 계산 결과 메모이제이션

### 목표

* **비싼 연산(heavy computation)** 이 매 렌더링마다 실행되는 것을 방지
* 특정 상태가 변할 때만 계산하도록 최적화

---

### 파일 경로 / 파일명

```
src/App.js
```

### 예시 코드

```javascript
import React, { useState, useMemo } from 'react';

// CPU 부하가 큰 함수 예시 (피보나치 계산)
function heavyFibonacci(n) {
  console.log("💡 피보나치 계산 실행:", n);
  if (n <= 1) return n;
  return heavyFibonacci(n - 1) + heavyFibonacci(n - 2);
}

export default function App() {
  const [num, setNum] = useState(30);   // 피보나치 입력값
  const [text, setText] = useState(""); // 별도 상태

  // useMemo로 결과 캐싱
  const fibValue = useMemo(() => heavyFibonacci(num), [num]);
  // num이 변경될 때만 다시 계산됨

  return (
    <div>
      <h1>useMemo 계산 결과 메모이제이션</h1>
      
      <div>
        <label>
          피보나치 수 입력: 
          <input 
            type="number" 
            value={num} 
            onChange={(e) => setNum(Number(e.target.value))}
          />
        </label>
      </div>

      <p>{num}번째 피보나치 수: {fibValue}</p>

      <hr />

      {/* 이 input은 fibValue와 무관 → fibValue는 재계산되지 않음 */}
      <div>
        <label>
          아무 텍스트 입력: 
          <input 
            type="text" 
            value={text} 
            onChange={(e) => setText(e.target.value)}
          />
        </label>
        <p>입력값: {text}</p>
      </div>
    </div>
  );
}
```

---

### 코드 설명

1. **문제 상황**

   ```javascript
   const result = heavyFibonacci(num);
   ```

   * 이렇게 쓰면 컴포넌트가 리렌더링될 때마다 `heavyFibonacci`가 계속 실행됨
   * num이 바뀌지 않아도, 다른 state(text 등) 변경 시 불필요하게 실행됨

2. **해결 – useMemo**

   ```javascript
   const fibValue = useMemo(() => heavyFibonacci(num), [num]);
   ```

   * num이 바뀔 때만 `heavyFibonacci(num)` 실행
   * 그 외 상태 변경 시에는 **이전 결과를 재사용**

3. **실행 로그 확인**

   * console에 `"💡 피보나치 계산 실행:"`이 찍히는지 확인
   * num이 바뀔 때만 찍혀야 하고, text 입력 시엔 찍히면 안 됨

---

### 실행 흐름

1. 초기 렌더링 시 `heavyFibonacci(30)` 실행 → 결과 캐싱
2. `num` 변경 시 → 새로운 값으로 다시 실행
3. `text` 변경 시 → fibValue는 캐싱된 값 그대로 재사용, 재계산 없음

---

다음은 **18번 – useMemo 무거운 연산 최적화** 예제로 넘어가겠습니다. 계속 진행할까요?
