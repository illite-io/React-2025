좋습니다. **16번 – useCallback 자식 컴포넌트 렌더링 최적화**로 이어가겠습니다.

---

## 16. useCallback 자식 컴포넌트 렌더링 최적화

### 목표

* 리스트 아이템에 바인딩되는 핸들러가 **매 렌더마다 새로 생성**되어 자식이 불필요하게 리렌더링되는 문제를 줄이기
* `React.memo` + `useCallback` 조합으로 **관련된 아이템만** 리렌더링되게 만들기

---

### 파일 경로 / 파일명

```
src/App.js
```

### 예시 코드

```javascript
import React, { useCallback, useMemo, useState } from 'react';

/** 개별 아이템: React.memo로 감싸 props 얕은 비교 */
const TodoItem = React.memo(function TodoItem({ item, onToggle, onRemove }) {
  console.log('TodoItem 렌더:', item.id); // 어떤 아이템이 다시 렌더되는지 확인

  return (
    <li style={{ display: 'flex', gap: 8, alignItems: 'center', padding: '4px 0' }}>
      <input
        type="checkbox"
        checked={item.completed}
        onChange={() => onToggle(item.id)}
        aria-label={`${item.text} 완료 토글`}
      />
      <span style={{ textDecoration: item.completed ? 'line-through' : 'none', flex: 1 }}>
        {item.text}
      </span>
      <button onClick={() => onRemove(item.id)}>삭제</button>
    </li>
  );
});

/** 문제 요약:
 * - onToggle, onRemove를 아이템별 인라인 화살표로 만들면 (id) => ... 가 매 렌더마다 새로 생성됨
 * - React.memo를 써도 함수 참조가 달라져 자식이 리렌더링됨
 * 해결:
 * - 부모에서 id를 받는 '안정된' 핸들러를 useCallback으로 만들고
 * - 자식에서는 그 안정된 핸들러 참조를 그대로 전달
 */
export default function App() {
  const [todos, setTodos] = useState(() => [
    { id: 1, text: '문서 읽기', completed: false },
    { id: 2, text: '코드 작성', completed: false },
    { id: 3, text: '테스트 추가', completed: false },
  ]);
  const [text, setText] = useState('');

  /** 1) 아이템 토글: 의존성은 setTodos(안 변함)이므로 []로 고정 가능 */
  const onToggle = useCallback((id) => {
    setTodos(prev =>
      prev.map(t => (t.id === id ? { ...t, completed: !t.completed } : t))
    );
  }, []);

  /** 2) 아이템 삭제 */
  const onRemove = useCallback((id) => {
    setTodos(prev => prev.filter(t => t.id !== id));
  }, []);

  /** 3) 추가 버튼: 입력 텍스트가 바뀌어도 핸들러 참조는 유지되어도 괜찮도록
   *    내부에서 최신 text를 읽기 위해 함수형 업데이트로 prev를 사용
   */
  const onAdd = useCallback(() => {
    const trimmed = text.trim();
    if (!trimmed) return;
    setTodos(prev => [
      { id: Date.now(), text: trimmed, completed: false },
      ...prev,
    ]);
    setText('');
  }, [text]); // text를 사용하므로 text는 의존성에 포함

  /** 불필요한 계산 메모이제이션 (예: 완료/미완료 카운트) */
  const stats = useMemo(() => {
    const total = todos.length;
    const done = todos.filter(t => t.completed).length;
    return { total, done, active: total - done };
  }, [todos]);

  return (
    <div style={{ maxWidth: 520, margin: '40px auto', padding: '0 16px' }}>
      <h1>useCallback으로 자식 렌더 최적화</h1>

      {/* 입력/추가 */}
      <div style={{ display: 'flex', gap: 8, marginBottom: 12 }}>
        <input
          value={text}
          onChange={(e) => setText(e.target.value)}
          placeholder="할 일 입력"
          style={{ flex: 1, padding: '8px 10px' }}
        />
        <button onClick={onAdd}>추가</button>
      </div>

      {/* 통계 */}
      <div style={{ marginBottom: 8 }}>
        전체: {stats.total} / 진행중: {stats.active} / 완료: {stats.done}
      </div>

      {/* 리스트
          핵심: 각 TodoItem에 onToggle, onRemove를 그대로 전달
          → 참조가 안정적이므로 본문/체크박스 변화가 없는 아이템은 리렌더링 회피
      */}
      <ul style={{ listStyle: 'none', padding: 0, margin: 0 }}>
        {todos.map(item => (
          <TodoItem
            key={item.id}
            item={item}
            onToggle={onToggle}
            onRemove={onRemove}
          />
        ))}
      </ul>
    </div>
  );
}
```

---

### 핵심 포인트

1. **React.memo + 안정된 핸들러 참조**

   * 자식이 받는 `onToggle`, `onRemove`를 매 렌더마다 새로운 화살표 함수로 만들지 말고,
     부모에서 `useCallback`으로 **한 번 만든 동일 참조**를 계속 전달합니다.
2. **아이템별 인라인 핸들러 지양**

   * `onChange={() => onToggle(item.id)}` 같은 **새 래퍼 함수**는 자식에서 생성하는 것이 낫습니다.
   * 부모에서 만들면 `todos.map` 루프마다 새 함수를 만들어 전달하게 되어 memo 이점이 사라집니다.
3. **의존성 설계**

   * 상태 변경 시 **함수형 업데이트**(`setTodos(prev => ...)`)를 쓰면 `setTodos`만 의존하므로
     `onToggle`, `onRemove`는 `[]`로 고정 가능.
   * 외부 값(text 등)을 사용하는 `onAdd`는 그 값만 의존성에 포함합니다.
4. **불필요한 재계산 방지**

   * `useMemo`로 파생값(카운트 등) 캐싱.

---

### 실행/관찰 방법

* 개발자 콘솔에서 `console.log('TodoItem 렌더:', item.id)` 확인
* 체크박스로 **특정 아이템만** 토글하면 해당 id만 로그가 찍혀야 함
* 새로운 아이템 추가 시, **새로 생긴 아이템**과 상단 레이아웃 정도만 리렌더링

---

다음은 **17번 – useMemo 계산 결과 메모이제이션**으로 넘어가겠습니다. 계속 진행할까요?
