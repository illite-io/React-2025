좋습니다. **20번 – useRef 상태 저장소로 활용**을 진행하겠습니다.

---

## 20. useRef 상태 저장소로 활용

### 목표

* 렌더 없이 값만 유지하는 **가변 저장소(mutable storage)** 로 `useRef`를 사용
* 예: 렌더 횟수 카운트, 디바운스 타이머 ID, 이전 값 유지 등

---

### 파일 경로 / 파일명

```
src/App.js
```

### 예시 1) 렌더 횟수 카운트(리렌더 유발 없이)

```javascript
import React, { useEffect, useRef, useState } from 'react';

export default function App() {
  const [text, setText] = useState('');
  const renderCountRef = useRef(0); // 렌더 횟수 저장용(리렌더 유발 X)

  useEffect(() => {
    // 매 렌더 후 증가. setState가 아니므로 추가 렌더 발생 없음
    renderCountRef.current += 1;
  });

  return (
    <div style={{ padding: 20 }}>
      <h1>useRef로 렌더 횟수 저장</h1>
      <input
        value={text}
        onChange={(e) => setText(e.target.value)}
        placeholder="입력해보세요"
        style={{ padding: '8px' }}
      />
      <p>현재 입력값: {text}</p>
      <p>컴포넌트 렌더 횟수(추적용): {renderCountRef.current}</p>
    </div>
  );
}
```

#### 포인트

* `renderCountRef.current` 변경은 **리렌더를 일으키지 않음**.
* 화면에 즉시 반영되어야 하는 값은 `state`, 반영될 필요 없이 내부적으로만 기록할 값은 `ref`.

---

### 예시 2) 디바운스 타이머 ID 보관(클린업 안전)

```javascript
import React, { useEffect, useRef, useState } from 'react';

function useDebouncedValue(value, delay = 500) {
  const [debounced, setDebounced] = useState(value);
  const timerRef = useRef(null); // 타이머 ID 저장

  useEffect(() => {
    // 이전 타이머가 있으면 취소
    if (timerRef.current) {
      clearTimeout(timerRef.current);
    }
    // 새 타이머 시작
    timerRef.current = setTimeout(() => {
      setDebounced(value);
      timerRef.current = null; // 사용 완료 후 정리
    }, delay);

    // 언마운트/의존성 변경 시 타이머 취소
    return () => {
      if (timerRef.current) {
        clearTimeout(timerRef.current);
        timerRef.current = null;
      }
    };
  }, [value, delay]);

  return debounced;
}

export default function App() {
  const [query, setQuery] = useState('');
  const debouncedQuery = useDebouncedValue(query, 600);

  useEffect(() => {
    // debouncedQuery가 바뀔 때만 API 요청 등 실행
    if (debouncedQuery) {
      console.log('검색 실행:', debouncedQuery);
      // fetch(`/search?q=${encodeURIComponent(debouncedQuery)}`)
    }
  }, [debouncedQuery]);

  return (
    <div style={{ padding: 20 }}>
      <h1>useRef로 디바운스 타이머 관리</h1>
      <input
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder="검색어를 입력하세요"
        style={{ padding: '8px', width: 280 }}
      />
      <p>디바운스 값: {debouncedQuery}</p>
    </div>
  );
}
```

#### 포인트

* `timerRef.current`에 **타이머 ID**를 저장하면 렌더 없이 타이머를 교체/취소 가능.
* `cleanup`에서 안전하게 `clearTimeout` 호출 → 메모리 누수/경합 방지.

---

### 예시 3) 이전 값 저장(리렌더 없이 추적)

```javascript
import React, { useEffect, useRef, useState } from 'react';

export default function App() {
  const [value, setValue] = useState('');
  const prevRef = useRef(''); // 이전 값을 보관(렌더 유발 X)

  useEffect(() => {
    // 렌더 후에 이전 값을 최신 값으로 갱신
    prevRef.current = value;
  }, [value]);

  return (
    <div style={{ padding: 20 }}>
      <h1>useRef로 이전 값 저장</h1>
      <input
        value={value}
        onChange={(e) => setValue(e.target.value)}
        placeholder="입력"
        style={{ padding: '8px' }}
      />
      <p>현재 값: {value || '(빈 값)'}</p>
      <p>이전 값: {prevRef.current || '(없음)'}</p>
    </div>
  );
}
```

---

## 언제 `useRef`를 상태 저장소로 써야 하나

* **화면에 즉시 반영할 필요가 없는 값**

  * 예: 타이머/인터벌 ID, 외부 라이브러리 인스턴스, 최근 API 요청 토큰, 스크롤 위치 캐시
* **빈번히 바뀌지만 렌더링 비용을 유발하고 싶지 않은 값**

  * 예: 입력 중간 로컬 변수, 짧은 수명 플래그, 성능 측정용 카운터
* **이전 값/최근 값 추적**

  * `useEffect`로 동기화하며 `ref.current`에 저장

> 반대로 **UI에 바로 반영되어야 하는 값**은 반드시 `useState`나 `useReducer`를 사용해야 합니다.

---

다음은 **21번 – useImperativeHandle 자식 메서드 노출**로 넘어가겠습니다. 계속 진행할까요?
