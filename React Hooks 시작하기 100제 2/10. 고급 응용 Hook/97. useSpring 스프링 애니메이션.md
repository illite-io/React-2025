좋습니다. **97번 – useSpring 스프링 애니메이션**로 진행하겠습니다.

---

## 97. useSpring 스프링 애니메이션

### 목표

* 물리 기반(후크의 법칙) 스프링 애니메이션
* `stiffness`, `damping`, `mass`로 반응성/감쇠 제어
* 목표값을 `setTarget()`으로 변경하면 자연스럽게 따라감
* `requestAnimationFrame` 기반, 1D/2D 확장 가능

---

### 파일 경로 / 파일명

```
src/hooks/useSpring.js
src/App.js
```

---

### 1) 커스텀 훅 – `useSpring.js`

```javascript
import { useCallback, useEffect, useRef, useState } from "react";

/**
 * useSpring(initial, opts?)
 * - initial: 초기 값 (number)
 * - opts:
 *   - stiffness(k): 스프링 강도 (기본 170)
 *   - damping(c): 감쇠 (기본 26)
 *   - mass(m): 질량 (기본 1)
 *   - precision: 정지 임계값 (기본 0.001)
 *
 * 반환:
 * { value, setTarget, target, playing, stop, reset, setValue }
 */
export default function useSpring(initial = 0, opts = {}) {
  const {
    stiffness = 170,
    damping = 26,
    mass = 1,
    precision = 0.001,
  } = opts;

  const [value, setValueState] = useState(initial);
  const [target, setTargetState] = useState(initial);
  const [playing, setPlaying] = useState(false);

  const velRef = useRef(0);           // 속도
  const valRef = useRef(initial);     // 현재 값
  const tgtRef = useRef(initial);
  const rafRef = useRef(0);
  const lastTsRef = useRef(0);

  const setValue = useCallback((v) => {
    valRef.current = v;
    setValueState(v);
  }, []);

  const setTarget = useCallback((t) => {
    tgtRef.current = t;
    setTargetState(t);
    setPlaying(true);
    if (!rafRef.current) {
      lastTsRef.current = 0;
      rafRef.current = requestAnimationFrame(step);
    }
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []); // step은 함수 선언 아래에서 hoist되므로 의존성 생략

  const stop = useCallback(() => {
    setPlaying(false);
    cancelAnimationFrame(rafRef.current);
    rafRef.current = 0;
  }, []);

  const reset = useCallback((v = initial) => {
    stop();
    velRef.current = 0;
    setTargetState(v);
    tgtRef.current = v;
    setValue(v);
  }, [initial, setValue, stop]);

  // 핵심 적분 루프: 반-명시적 오일러(또는 세미-implicit Euler)
  const step = useCallback((ts) => {
    if (!lastTsRef.current) lastTsRef.current = ts;
    const dt = Math.min(0.032, (ts - lastTsRef.current) / 1000); // 최대 32ms로 클램프
    lastTsRef.current = ts;

    const x = valRef.current;
    const v = velRef.current;
    const x0 = tgtRef.current;

    // Hooke's law: F = -k(x - x0) - c v
    const k = stiffness;
    const c = damping;
    const m = mass;

    const force = -k * (x - x0) - c * v;
    const a = force / m;
    const vNext = v + a * dt;
    const xNext = x + vNext * dt;

    velRef.current = vNext;
    valRef.current = xNext;
    setValueState(xNext);

    const atRest = Math.abs(vNext) < precision && Math.abs(xNext - x0) < precision;
    if (!playing || atRest) {
      if (atRest) {
        // 정확히 타겟에 스냅
        velRef.current = 0;
        valRef.current = x0;
        setValueState(x0);
      }
      cancelAnimationFrame(rafRef.current);
      rafRef.current = 0;
      setPlaying(false);
      return;
    }

    rafRef.current = requestAnimationFrame(step);
  }, [stiffness, damping, mass, precision, playing]);

  useEffect(() => {
    return () => cancelAnimationFrame(rafRef.current);
  }, []);

  return { value, setTarget, target, playing, stop, reset, setValue };
}
```

---

### 2) 사용 예제 – `App.js` (슬라이더 → 스프링 박스)

```javascript
import React, { useState } from "react";
import useSpring from "./hooks/useSpring";

export default function App() {
  const [k, setK] = useState(170);
  const [c, setC] = useState(26);
  const [m, setM] = useState(1);

  const spring = useSpring(0, { stiffness: k, damping: c, mass: m });

  return (
    <div style={{ padding: 20 }}>
      <h1>useSpring 스프링 애니메이션</h1>

      <div style={{ display: "grid", gridTemplateColumns: "120px 1fr 80px", gap: 8, maxWidth: 520 }}>
        <label>stiffness</label>
        <input type="range" min="20" max="400" value={k} onChange={(e) => setK(Number(e.target.value))} />
        <span>{k}</span>

        <label>damping</label>
        <input type="range" min="1" max="60" value={c} onChange={(e) => setC(Number(e.target.value))} />
        <span>{c}</span>

        <label>mass</label>
        <input type="range" min="0.2" max="5" step="0.1" value={m} onChange={(e) => setM(Number(e.target.value))} />
        <span>{m}</span>
      </div>

      <p style={{ color: "#64748b" }}>
        아래 트랙을 클릭하면 목표 위치가 바뀌고, 박스가 스프링 모션으로 따라갑니다.
      </p>

      {/* 트랙 */}
      <div
        onClick={(e) => {
          const rect = e.currentTarget.getBoundingClientRect();
          const ratio = (e.clientX - rect.left) / rect.width; // 0~1
          spring.setTarget(ratio); // 0~1 목표
        }}
        style={{
          position: "relative",
          width: 560,
          height: 12,
          background: "#e5e7eb",
          borderRadius: 6,
          margin: "20px 0",
        }}
      >
        {/* 진행 막대(표시용) */}
        <div
          style={{
            position: "absolute",
            left: 0, top: 0, bottom: 0,
            width: `${spring.value * 100}%`,
            background: "#93c5fd",
            borderRadius: 6,
          }}
        />
        {/* 핸들 */}
        <div
          style={{
            position: "absolute",
            left: `calc(${spring.value * 100}% - 10px)`,
            top: -7,
            width: 20,
            height: 26,
            borderRadius: 6,
            background: "#2563eb",
          }}
        />
      </div>

      <div style={{ display: "flex", gap: 8 }}>
        <button onClick={() => spring.setTarget(0)}>왼쪽</button>
        <button onClick={() => spring.setTarget(0.5)}>가운데</button>
        <button onClick={() => spring.setTarget(1)}>오른쪽</button>
        <button onClick={() => spring.reset(0)}>리셋</button>
      </div>

      <p>value: {spring.value.toFixed(3)} / target: {spring.target.toFixed(3)} / playing: {String(spring.playing)}</p>
    </div>
  );
}
```

---

### 동작 방식

* 힘: `F = -k(x - x0) - c v`
* 가속도: `a = F / m`
* 속도/위치를 `dt`로 적분하여 다음 프레임 값을 계산
* 속도와 위치가 임계(`precision`) 이하이면 정지/스냅

### 확장 아이디어

* 2D/벡터 스프링: `value`를 `{x,y}`로 두고 성분별 동일 계산
* 체이닝: 여러 스프링을 연결해 카드 스택/물리 리스트 구현
* `pause/resume`/`onUpdate` 콜백 추가, 외부 상태와 동기화
* 접근성: 사용자 설정 “감소된 모션”(`prefers-reduced-motion`) 감지해 즉시 점프 모드로 전환

---

다음은 **98번 – useGesture 제스처 감지**로 넘어가겠습니다. 계속 진행할까요?
