좋습니다. 이제 **96번 – useAnimation 애니메이션 상태 관리** 예제를 보겠습니다.

---

## 96. useAnimation 애니메이션 상태 관리

### 목표

* 컴포넌트에서 애니메이션을 **시작/중지/재시작** 제어
* `requestAnimationFrame` 기반으로 부드럽게 갱신
* 진행률(0\~1) 또는 시간 기반 제어

---

### 파일 경로 / 파일명

```
src/hooks/useAnimation.js
src/App.js
```

---

### 1) 커스텀 훅 – `useAnimation.js`

```javascript
import { useCallback, useEffect, useRef, useState } from "react";

/**
 * useAnimation(duration, { autoplay })
 * - duration: 전체 애니메이션 길이(ms)
 * - autoplay: true면 마운트 시 자동 시작
 *
 * 반환:
 * { progress, playing, start, stop, reset }
 */
export default function useAnimation(duration = 1000, { autoplay = false } = {}) {
  const [progress, setProgress] = useState(0); // 0 ~ 1
  const [playing, setPlaying] = useState(false);
  const startTimeRef = useRef(null);
  const rafRef = useRef(null);

  const step = useCallback(
    (now) => {
      if (!startTimeRef.current) startTimeRef.current = now;
      const elapsed = now - startTimeRef.current;
      const pct = Math.min(elapsed / duration, 1);
      setProgress(pct);
      if (pct < 1) {
        rafRef.current = requestAnimationFrame(step);
      } else {
        setPlaying(false);
      }
    },
    [duration]
  );

  const start = useCallback(() => {
    cancelAnimationFrame(rafRef.current);
    setProgress(0);
    setPlaying(true);
    startTimeRef.current = null;
    rafRef.current = requestAnimationFrame(step);
  }, [step]);

  const stop = useCallback(() => {
    cancelAnimationFrame(rafRef.current);
    setPlaying(false);
  }, []);

  const reset = useCallback(() => {
    cancelAnimationFrame(rafRef.current);
    setProgress(0);
    setPlaying(false);
  }, []);

  useEffect(() => {
    if (autoplay) start();
    return () => cancelAnimationFrame(rafRef.current);
  }, [autoplay, start]);

  return { progress, playing, start, stop, reset };
}
```

---

### 2) 사용 예제 – `App.js`

```javascript
import React from "react";
import useAnimation from "./hooks/useAnimation";

export default function App() {
  const { progress, playing, start, stop, reset } = useAnimation(2000);

  const size = 100 + progress * 200; // 100 → 300
  const opacity = progress;          // 0 → 1

  return (
    <div style={{ padding: 20 }}>
      <h1>useAnimation 애니메이션 상태 관리</h1>

      <div
        style={{
          width: size,
          height: size,
          borderRadius: "50%",
          background: "#2563eb",
          opacity,
          transition: "box-shadow 0.2s",
          boxShadow: playing ? "0 0 20px rgba(37,99,235,0.6)" : "none",
          margin: "20px auto",
        }}
      />

      <p>진행률: {(progress * 100).toFixed(0)}%</p>

      <div style={{ display: "flex", gap: 8 }}>
        <button onClick={start}>시작</button>
        <button onClick={stop}>중지</button>
        <button onClick={reset}>리셋</button>
      </div>
    </div>
  );
}
```

---

### 동작 방식

1. `requestAnimationFrame`으로 프레임마다 경과 시간 계산
2. `progress`(0\~1)를 갱신, 이를 기반으로 스타일/애니메이션 제어
3. `start`, `stop`, `reset` 함수로 제어 가능

---

### 활용 아이디어

* 로딩 인디케이터 진행률
* 스크롤 연동 애니메이션
* CSS 대신 JS 기반 세밀 제어 필요할 때 (캔버스/Three.js 등)

---

다음은 **97번 – useSpring 스프링 애니메이션**으로 넘어가시겠습니까?
