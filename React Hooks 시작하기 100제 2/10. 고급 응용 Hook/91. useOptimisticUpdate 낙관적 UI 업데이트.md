좋습니다. 이제 **91번 – useOptimisticUpdate 낙관적 UI 업데이트** 예제를 보겠습니다.

---

## 91. useOptimisticUpdate 낙관적 UI 업데이트

### 목표

* 서버 응답 전에 UI를 먼저 반영하고 실패 시 **롤백**
* 공통 패턴을 훅으로 추상화해 재사용
* 요청 중 중복 실행/충돌 최소화

---

### 파일 경로 / 파일명

```
src/hooks/useOptimisticUpdate.js
src/App.js
```

---

### 1) 커스텀 훅 – `useOptimisticUpdate.js`

```javascript
import { useCallback, useRef, useState } from "react";

/**
 * useOptimisticUpdate(apply, commit)
 * - apply(patch): 낙관적 변경을 로컬 상태에 적용하고, 이전 상태(snap)를 반환
 * - commit(patch): 서버에 실제 변경을 반영하는 비동기 함수 (실패 시 throw)
 *
 * 반환:
 * { run, running, error, lastPatch }
 *
 * 사용법:
 * const { run } = useOptimisticUpdate(apply, commit)
 * run(patch) // -> 성공 시 유지, 실패 시 자동 롤백
 */
export default function useOptimisticUpdate(apply, commit) {
  const [running, setRunning] = useState(false);
  const [error, setError] = useState(null);
  const [lastPatch, setLastPatch] = useState(null);
  const queueRef = useRef(Promise.resolve()); // 직렬화로 충돌 줄임

  const run = useCallback((patch) => {
    setLastPatch(patch);
    // 직렬 실행: 이전 작업이 끝나야 다음 패치 실행
    queueRef.current = queueRef.current.then(async () => {
      const snap = apply(patch);    // 1) 낙관적 적용
      setRunning(true);
      setError(null);
      try {
        await commit(patch);        // 2) 서버 커밋
      } catch (e) {
        // 3) 실패 → 롤백
        if (typeof snap?.rollback === "function") snap.rollback();
        setError(e);
        throw e;
      } finally {
        setRunning(false);
      }
    });

    return queueRef.current;
  }, [apply, commit]);

  return { run, running, error, lastPatch };
}
```

---

### 2) 사용 예제 – `App.js` (좋아요 토글 + 목록 편집)

```javascript
import React, { useMemo, useState } from "react";
import useOptimisticUpdate from "./hooks/useOptimisticUpdate";

// 가짜 서버 API
const api = {
  async toggleLike(id, nextLiked) {
    await sleep(400);
    // 실패 확률 15%
    if (Math.random() < 0.15) throw new Error("서버 오류: like 반영 실패");
    return { ok: true, liked: nextLiked };
  },
  async rename(id, name) {
    await sleep(500);
    if (name.trim() === "") throw new Error("이름은 비워둘 수 없습니다.");
    if (Math.random() < 0.1) throw new Error("일시적 오류");
    return { ok: true, name };
  },
};

function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

export default function App() {
  const [items, setItems] = useState([
    { id: "a1", name: "항목 A", liked: false },
    { id: "b2", name: "항목 B", liked: true  },
    { id: "c3", name: "항목 C", liked: false },
  ]);

  // ① 좋아요 낙관적 업데이트 훅
  const likeOps = useOptimisticUpdate(
    // apply
    (patch) => {
      const { id, liked } = patch;
      const prev = items.find((x) => x.id === id);
      setItems((arr) => arr.map((x) => x.id === id ? { ...x, liked } : x));
      // 롤백 함수 반환
      return {
        rollback() {
          setItems((arr) => arr.map((x) => x.id === id ? { ...x, liked: prev?.liked } : x));
        }
      };
    },
    // commit
    (patch) => api.toggleLike(patch.id, patch.liked)
  );

  // ② 이름 변경 낙관적 업데이트 훅
  const renameOps = useOptimisticUpdate(
    (patch) => {
      const { id, name } = patch;
      const prev = items.find((x) => x.id === id);
      setItems((arr) => arr.map((x) => x.id === id ? { ...x, name } : x));
      return {
        rollback() {
          setItems((arr) => arr.map((x) => x.id === id ? { ...x, name: prev?.name } : x));
        }
      };
    },
    (patch) => api.rename(patch.id, patch.name)
  );

  const busy = likeOps.running || renameOps.running;

  return (
    <div style={{ padding: 20, maxWidth: 720, margin: "0 auto" }}>
      <h1>useOptimisticUpdate 낙관적 UI 업데이트</h1>
      <p style={{ color: "#64748b" }}>
        서버 응답을 기다리지 않고 UI를 먼저 바꿉니다. 실패하면 자동 롤백합니다.
      </p>

      <ul style={{ listStyle: "none", padding: 0 }}>
        {items.map((it) => (
          <li key={it.id}
              style={{ display: "flex", alignItems: "center", gap: 10, borderBottom: "1px solid #f1f5f9", padding: "10px 0" }}>
            <button
              onClick={() => likeOps.run({ id: it.id, liked: !it.liked }).catch(()=>{})}
              aria-pressed={it.liked}
              title={it.liked ? "좋아요 취소" : "좋아요"}
              style={{
                width: 34, height: 34, borderRadius: "50%",
                border: "1px solid #e5e7eb",
                background: it.liked ? "#fee2e2" : "white"
              }}
            >
              {it.liked ? "♥" : "♡"}
            </button>

            <input
              defaultValue={it.name}
              onBlur={(e) => {
                const next = e.target.value;
                if (next !== it.name) {
                  renameOps.run({ id: it.id, name: next }).catch(() => {
                    // 실패 시 입력값을 롤백된 state로 재동기화
                    e.target.value = items.find(x => x.id === it.id)?.name ?? "";
                  });
                }
              }}
              style={{ flex: 1, padding: "6px 8px", border: "1px solid #e5e7eb", borderRadius: 6 }}
            />

            <code style={{ color: "#94a3b8" }}>{it.id}</code>
          </li>
        ))}
      </ul>

      {busy && <p>서버 동기화 중...</p>}
      {(likeOps.error || renameOps.error) && (
        <p style={{ color: "crimson" }}>
          에러: {likeOps.error?.message || renameOps.error?.message}
        </p>
      )}
    </div>
  );
}
```

---

### 동작 방식

1. `apply(patch)`에서 **즉시 로컬 상태를 변경**하고, 이전 상태로 되돌릴 `rollback()`을 반환
2. `commit(patch)`가 성공하면 그대로 유지, 실패하면 `rollback()` 호출
3. 훅 내부 큐로 **직렬 실행**하여 동시 패치 충돌을 최소화

---

### 실무 팁

* 리스트 추가/삭제도 같은 방식으로 처리: 삭제는 먼저 제거 후 실패 시 다시 삽입
* SWR/RTK Query 등과 함께 사용할 때는 **캐시 무효화**를 잊지 말 것
* 동일 리소스에 대해 여러 낙관적 패치가 겹칠 때는 **키 기반 큐**로 더 정밀한 직렬화를 고려
* 서버가 최종 소스오브트루스이므로, 주기적 재동기화(62번 폴링, 64\~65번 푸시)로 **드리프트**를 줄이기

---

다음은 **92번 – useDebounce 디바운스 처리**로 넘어가겠습니다. 계속 진행할까요?
