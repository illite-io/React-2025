좋습니다. **95번 – useInfiniteScroll 무한 스크롤**로 진행하겠습니다.

---

## 95. useInfiniteScroll 무한 스크롤

### 목표

* 스크롤 바닥(관찰 지점)에 도달하면 다음 페이지 로드
* 중복 호출 방지, 로딩/에러/종료 상태 관리
* IntersectionObserver 기반으로 성능 안정

---

### 파일 경로 / 파일명

```
src/hooks/useInfiniteScroll.js
src/App.js
```

---

### 1) 커스텀 훅 – `useInfiniteScroll.js`

```javascript
import { useCallback, useEffect, useRef, useState } from "react";

/**
 * useInfiniteScroll(loadMore, options?)
 * - loadMore: (page) => Promise<{ items: any[], done?: boolean }>
 *   - page: 1부터 시작하는 페이지 번호
 *   - 반환값의 done=true면 더 이상 로드 없음
 *
 * options:
 * - rootMargin: 옵저버 마진 (기본 "200px")
 * - threshold: 관찰 임계치 (기본 0)
 * - enabled: 로딩 활성화 (기본 true)
 *
 * 반환:
 * { items, loading, error, done, sentinelRef, reset, reload }
 */
export default function useInfiniteScroll(loadMore, {
  root = null,
  rootMargin = "200px",
  threshold = 0,
  enabled = true,
} = {}) {
  const [items, setItems] = useState([]);
  const [page, setPage] = useState(1);
  const [loading, setLoading] = useState(false);
  const [done, setDone] = useState(false);
  const [error, setError] = useState(null);
  const sentinelRef = useRef(null);
  const observingRef = useRef(false);

  const fetchPage = useCallback(async (p) => {
    if (!enabled || loading || done) return;
    setLoading(true);
    setError(null);
    try {
      const res = await loadMore(p);
      setItems((prev) => [...prev, ...(res?.items ?? [])]);
      if (res?.done || (res?.items?.length ?? 0) === 0) {
        setDone(true);
      } else {
        setPage(p + 1);
      }
    } catch (e) {
      setError(e);
    } finally {
      setLoading(false);
    }
  }, [enabled, loading, done, loadMore]);

  // IntersectionObserver로 sentinel 감시
  useEffect(() => {
    const node = sentinelRef.current;
    if (!node || !enabled || done) return;

    let io = new IntersectionObserver((entries) => {
      const [entry] = entries;
      if (entry.isIntersecting && !observingRef.current) {
        observingRef.current = true;
        fetchPage(page).finally(() => {
          // 재관찰 가능하게 잠금 해제
          observingRef.current = false;
        });
      }
    }, { root, rootMargin, threshold });

    io.observe(node);
    return () => io.disconnect();
  }, [enabled, done, page, root, rootMargin, threshold, fetchPage]);

  const reset = useCallback(() => {
    setItems([]);
    setPage(1);
    setDone(false);
    setError(null);
  }, []);

  const reload = useCallback(async () => {
    reset();
    await fetchPage(1);
  }, [reset, fetchPage]);

  return { items, loading, error, done, sentinelRef, reset, reload };
}
```

---

### 2) 사용 예제 – `App.js` (가짜 API로 목록 불러오기)

```javascript
import React, { useCallback, useEffect } from "react";
import useInfiniteScroll from "./hooks/useInfiniteScroll";

// 가짜 API: 페이지당 20개, 총 5페이지
async function fetchItems(page) {
  await new Promise((r) => setTimeout(r, 400)); // 네트워크 지연 시뮬
  const pageSize = 20;
  const maxPage = 5;
  if (page > maxPage) return { items: [], done: true };
  const start = (page - 1) * pageSize + 1;
  const items = Array.from({ length: pageSize }, (_, i) => ({
    id: start + i,
    text: `아이템 ${start + i}`,
  }));
  return { items, done: page >= maxPage };
}

export default function App() {
  const loadMore = useCallback((p) => fetchItems(p), []);
  const { items, loading, error, done, sentinelRef, reload } = useInfiniteScroll(loadMore, {
    rootMargin: "300px",
  });

  // 초기 첫 페이지 프리페치(옵션)
  useEffect(() => {
    if (items.length === 0) reload();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  return (
    <div style={{ padding: 20, maxWidth: 560, margin: "0 auto" }}>
      <h1>useInfiniteScroll 무한 스크롤</h1>
      <button onClick={reload} style={{ marginBottom: 12 }}>다시 불러오기</button>

      <ul style={{ listStyle: "none", padding: 0 }}>
        {items.map((it) => (
          <li key={it.id}
              style={{ padding: "10px 12px", borderBottom: "1px solid #f1f5f9" }}>
            {it.text}
          </li>
        ))}
      </ul>

      {error && <p style={{ color: "crimson" }}>에러: {String(error.message || error)}</p>}
      {loading && <p>로딩 중...</p>}
      {done && <p style={{ color: "#64748b" }}>더 이상 항목이 없습니다.</p>}

      {/* 관찰 지점 */}
      <div ref={sentinelRef} style={{ height: 1 }} />
    </div>
  );
}
```

---

### 동작 방식

1. 리스트 끝에 배치한 `sentinelRef`가 뷰포트에 들어오면 `loadMore(page)` 호출
2. 응답 `items`를 누적하고, `done`이면 추가 로드를 중단
3. 내부 잠금으로 관찰 이벤트 중복 호출을 방지

---

### 실무 팁

* 서버 페이징과 결합 시 `cursor/nextToken` 방식도 지원하도록 `loadMore` 반환값에 `cursor` 포함 후 훅 상태로 보관.
* 필터/검색어가 바뀌면 반드시 `reset()` 후 첫 페이지부터 다시 로드.
* 중복 데이터 방지: 아이템 키가 중복될 수 있으면 `Set`으로 dedup.
* 접근성: 끝에 “더 불러오기” 버튼을 제공해 키보드/스크린리더 사용자도 컨트롤 가능하게.

---

다음은 **96번 – useAnimation 애니메이션 상태 관리**로 넘어가겠습니다. 계속 진행할까요?
