좋습니다. **99번 – useFormValidation 폼 검증**로 진행하겠습니다.

---

## 99. useFormValidation 폼 검증

### 목표

* 필드 단위 검증 + 폼 전체 검증
* `onChange`에 즉시 검증(blur 시 검증도 옵션)
* 동기/비동기 규칙(예: 아이디 중복 체크) 모두 지원

---

### 파일 경로 / 파일명

```
src/hooks/useFormValidation.js
src/App.js
```

---

### 1) 커스텀 훅 – `useFormValidation.js`

```javascript
import { useCallback, useMemo, useRef, useState } from "react";

/**
 * useFormValidation(initial, rules, options?)
 * - initial: { field: defaultValue }
 * - rules: {
 *     field: [
 *       (value, values) => string | null | Promise<string|null>
 *     ]
 *   }
 * - options: { validateOn: 'change' | 'blur' | 'submit' (기본 'change') }
 *
 * 반환:
 * {
 *   values, errors, dirty, touched, validating,
 *   setValue(name, value), setValues(patch)
 *   validateField(name), validateAll(),
 *   handleChange(e), handleBlur(e), handleSubmit(onValid)
 *   reset(nextInitial?)
 *   isValid
 * }
 */
export default function useFormValidation(initial, rules = {}, options = {}) {
  const { validateOn = "change" } = options;
  const [values, setValues] = useState(initial);
  const [errors, setErrors] = useState({});
  const [dirty, setDirty] = useState({});
  const [touched, setTouched] = useState({});
  const [validating, setValidating] = useState({}); // { field: boolean }
  const latestValuesRef = useRef(values);
  latestValuesRef.current = values;

  const setValue = useCallback((name, value) => {
    setValues((v) => ({ ...v, [name]: value }));
    setDirty((d) => ({ ...d, [name]: true }));
    if (validateOn === "change") {
      validateField(name, value, { schedule: true });
    }
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [validateOn]);

  const setValuesPatch = useCallback((patch) => {
    setValues((v) => ({ ...v, ...(typeof patch === "function" ? patch(v) : patch) }));
  }, []);

  const runRules = useCallback(async (name, value, vs) => {
    const fns = rules[name] || [];
    for (const fn of fns) {
      const msg = await fn(value, vs);
      if (msg) return msg; // 첫 실패 메시지 반환
    }
    return null;
  }, [rules]);

  const validateField = useCallback(async (name, value = latestValuesRef.current[name], { schedule = false } = {}) => {
    try {
      if (schedule) setValidating((m) => ({ ...m,  [name]: true }));
      const msg = await runRules(name, value, { ...latestValuesRef.current, [name]: value });
      setErrors((e) => ({ ...e, [name]: msg }));
      return !msg;
    } finally {
      if (schedule) setValidating((m) => ({ ...m, [name]: false }));
    }
  }, [runRules]);

  const validateAll = useCallback(async () => {
    const names = Object.keys({ ...initial, ...values });
    const result = {};
    const valState = {};
    for (const n of names) {
      valState[n] = true;
      const ok = await validateField(n);
      result[n] = ok;
      valState[n] = false;
    }
    setValidating((_) => valState);
    return names.every((n) => result[n]);
  }, [initial, values, validateField]);

  const handleChange = useCallback((e) => {
    const { name, value } = e.target;
    setValue(name, value);
  }, [setValue]);

  const handleBlur = useCallback((e) => {
    const { name } = e.target;
    setTouched((t) => ({ ...t, [name]: true }));
    if (validateOn === "blur") validateField(name, values[name], { schedule: true });
  }, [validateOn, validateField, values]);

  const handleSubmit = useCallback((onValid) => {
    return async (e) => {
      e?.preventDefault?.();
      if (validateOn !== "submit") {
        const ok = await validateAll();
        if (!ok) return;
      } else {
        // submit 모드면 그때 처음 검증
        const ok = await validateAll();
        if (!ok) return;
      }
      await onValid?.(latestValuesRef.current);
    };
  }, [validateAll, validateOn]);

  const reset = useCallback((next = initial) => {
    setValues(next);
    setErrors({});
    setDirty({});
    setTouched({});
    setValidating({});
  }, [initial]);

  const isValid = useMemo(() => Object.values(errors).every((m) => !m), [errors]);

  return {
    values, errors, dirty, touched, validating,
    setValue, setValues: setValuesPatch,
    validateField, validateAll,
    handleChange, handleBlur, handleSubmit,
    reset, isValid,
  };
}
```

---

### 2) 사용 예제 – `App.js`

```javascript
import React from "react";
import useFormValidation from "./hooks/useFormValidation";

const rules = {
  username: [
    (v) => (!v ? "아이디를 입력하세요." : null),
    (v) => (v && v.length < 3 ? "3자 이상 입력하세요." : null),
    async (v) => {
      if (!v) return null;
      // 중복 체크(가짜): 'admin'은 이미 사용 중
      await new Promise((r) => setTimeout(r, 400));
      return v.toLowerCase() === "admin" ? "이미 사용 중인 아이디입니다." : null;
    },
  ],
  email: [
    (v) => (!v ? "이메일을 입력하세요." : null),
    (v) => (!/^\S+@\S+\.\S+$/.test(v) ? "이메일 형식이 아닙니다." : null),
  ],
  password: [
    (v) => (!v ? "비밀번호를 입력하세요." : null),
    (v) => (v.length < 8 ? "8자 이상 입력하세요." : null),
  ],
  password2: [
    (v, vs) => (v !== vs.password ? "비밀번호가 일치하지 않습니다." : null),
  ],
};

export default function App() {
  const {
    values, errors, touched, validating,
    handleChange, handleBlur, handleSubmit,
    setValue, reset, isValid
  } = useFormValidation(
    { username: "", email: "", password: "", password2: "" },
    rules,
    { validateOn: "change" } // 'blur' 또는 'submit'로 바꿔 보세요
  );

  const onRegister = async (vals) => {
    alert("회원가입 성공: " + JSON.stringify(vals, null, 2));
    reset();
  };

  const field = (name, type = "text", placeholder = "") => (
    <div style={{ marginBottom: 12 }}>
      <input
        name={name}
        type={type}
        value={values[name]}
        onChange={handleChange}
        onBlur={handleBlur}
        placeholder={placeholder}
        style={{
          width: 320, padding: "8px 10px",
          border: `1px solid ${errors[name] && (touched[name] || values[name]) ? "#ef4444" : "#e5e7eb"}`,
          borderRadius: 6,
        }}
      />
      <div style={{ height: 18, marginTop: 4 }}>
        {validating[name] && <small style={{ color: "#64748b" }}>검증 중...</small>}
        {!validating[name] && errors[name] && (touched[name] || values[name]) && (
          <small style={{ color: "#ef4444" }}>{errors[name]}</small>
        )}
      </div>
    </div>
  );

  return (
    <div style={{ padding: 20 }}>
      <h1>useFormValidation 폼 검증</h1>

      {field("username", "text", "아이디")}
      {field("email", "email", "이메일")}
      {field("password", "password", "비밀번호")}
      {field("password2", "password", "비밀번호 확인")}

      <div style={{ display: "flex", gap: 8 }}>
        <button onClick={handleSubmit(onRegister)} disabled={!isValid}>가입</button>
        <button onClick={() => setValue("username", "guest")}>아이디=guest 설정</button>
        <button onClick={() => reset()}>리셋</button>
      </div>
    </div>
  );
}
```

---

### 동작 방식

1. 각 필드에 배열 형태의 검증 규칙을 부여
2. 값 변경/블러/제출 타이밍 중 선택적으로 검증
3. 비동기 규칙도 순차 실행하여 첫 실패 메시지를 `errors[name]`에 반영
4. `handleSubmit(onValid)`는 전체 검증 통과 시 콜백 실행

---

### 실무 팁

* 서버 검증이 필요한 필드는 **디바운스**(92번)와 결합해 과도한 API 호출 방지
* 파일/이미지 등 복합 입력은 규칙 함수에서 `values`를 함께 검사
* 멀티스텝 폼은 100번 훅(다단계 폼)과 조합

---

다음은 **100번 – useMultiStepForm 다단계 폼 관리**로 이어가겠습니다. 계속 진행할까요?
