좋습니다. 이제 **93번 – useThrottle 쓰로틀 처리** 예제를 보겠습니다.

---

## 93. useThrottle 쓰로틀 처리

### 목표

* 이벤트가 연속으로 발생해도 **일정 주기마다 최대 한 번**만 실행
* 스크롤/마우스 이동/리사이즈 처리에 적합
* 값 기반 throttling과 함수 기반 throttling 모두 제공

---

### 파일 경로 / 파일명

```
src/hooks/useThrottle.js
src/App.js
```

---

### 1) 커스텀 훅 – `useThrottle.js`

```javascript
import { useEffect, useRef, useState, useCallback } from "react";

/**
 * ① 값 쓰로틀: useThrottleValue(value, delay)
 * - delay(ms) 주기마다 마지막 값으로 갱신
 */
export function useThrottleValue(value, delay = 200) {
  const [throttled, setThrottled] = useState(value);
  const lastRan = useRef(0);
  const lastValue = useRef(value);
  const timer = useRef(null);

  useEffect(() => {
    lastValue.current = value;
    const now = Date.now();
    const remaining = delay - (now - lastRan.current);

    if (remaining <= 0) {
      lastRan.current = now;
      setThrottled(lastValue.current);
    } else {
      clearTimeout(timer.current);
      timer.current = setTimeout(() => {
        lastRan.current = Date.now();
        setThrottled(lastValue.current);
      }, remaining);
    }

    return () => clearTimeout(timer.current);
  }, [value, delay]);

  return throttled;
}

/**
 * ② 함수 쓰로틀: useThrottleFn(fn, delay, { leading, trailing })
 * - leading: 시작 시 즉시 1회 실행 여부(기본 true)
 * - trailing: 종료 시 마지막 호출 보장 여부(기본 true)
 */
export function useThrottleFn(fn, delay = 200, opts = {}) {
  const { leading = true, trailing = true } = opts;
  const lastRan = useRef(0);
  const timer = useRef(null);
  const lastArgs = useRef(null);
  const lastThis = useRef(null);

  const throttled = useCallback(function (...args) {
    const now = Date.now();
    if (!lastRan.current && !leading) {
      lastRan.current = now; // 첫 구간 시작점만 찍고 실행은 미룸
    }
    const remaining = delay - (now - lastRan.current);

    lastArgs.current = args;
    lastThis.current = this;

    if (remaining <= 0) {
      if (timer.current) {
        clearTimeout(timer.current);
        timer.current = null;
      }
      lastRan.current = now;
      fn.apply(lastThis.current, lastArgs.current);
    } else if (trailing && !timer.current) {
      timer.current = setTimeout(() => {
        lastRan.current = leading ? Date.now() : 0;
        timer.current = null;
        fn.apply(lastThis.current, lastArgs.current);
      }, remaining);
    }
  }, [fn, delay, leading, trailing]);

  useEffect(() => () => timer.current && clearTimeout(timer.current), []);

  return throttled;
}
```

---

### 2) 사용 예제 – `App.js` (스크롤/마우스 좌표 쓰로틀)

```javascript
import React, { useEffect, useState } from "react";
import { useThrottleValue, useThrottleFn } from "./hooks/useThrottle";

export default function App() {
  const [rawX, setRawX] = useState(0);
  const [rawY, setRawY] = useState(0);
  const [scrollY, setScrollY] = useState(0);

  // 값 기반: 마우스 좌표를 100ms 단위로만 갱신
  const tx = useThrottleValue(rawX, 100);
  const ty = useThrottleValue(rawY, 100);

  // 함수 기반: 스크롤 핸들러를 200ms로 쓰로틀
  const onScrollThrottled = useThrottleFn(() => {
    setScrollY(window.scrollY);
  }, 200);

  useEffect(() => {
    const onMove = (e) => {
      setRawX(e.clientX);
      setRawY(e.clientY);
    };
    window.addEventListener("mousemove", onMove);
    window.addEventListener("scroll", onScrollThrottled, { passive: true });
    return () => {
      window.removeEventListener("mousemove", onMove);
      window.removeEventListener("scroll", onScrollThrottled);
    };
  }, [onScrollThrottled]);

  return (
    <div style={{ padding: 20 }}>
      <h1>useThrottle 쓰로틀 처리</h1>

      <section style={{ marginBottom: 16 }}>
        <h3>마우스 위치 (100ms 쓰로틀)</h3>
        <p>즉시 값: {rawX}, {rawY}</p>
        <p>쓰로틀 값: {tx}, {ty}</p>
      </section>

      <section style={{ marginBottom: 16 }}>
        <h3>스크롤 Y (200ms 쓰로틀)</h3>
        <p>scrollY: {Math.round(scrollY)}</p>
        <div style={{ height: 800, background: "#f1f5f9", borderRadius: 8 }} />
      </section>
    </div>
  );
}
```

---

### 동작 방식

* **useThrottleValue**: 마지막 변경 시점을 기준으로 delay 내 추가 변경을 묶어 일정 주기로만 값 갱신
* **useThrottleFn**: 핸들러 실행을 delay 주기로 제한. `leading/trailing` 옵션으로 첫 실행과 마지막 실행을 제어

---

### 활용 아이디어

* 스크롤 기반 헤더 고정/섀도우 토글
* 드래그 중 좌표 계산 빈도 제한
* 윈도우 리사이즈 이벤트 최적화

---

다음은 **94번 – useIntersectionObserver 요소 노출 감지**로 넘어가겠습니다. 계속 진행할까요?
