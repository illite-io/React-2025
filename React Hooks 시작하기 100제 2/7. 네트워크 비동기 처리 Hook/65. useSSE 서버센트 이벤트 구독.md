좋습니다. 이제 **65번 – useSSE 서버센트 이벤트 구독** 예제를 보겠습니다.

---

## 65. useSSE 서버센트 이벤트 구독

### 핵심 개념

* **SSE(Server-Sent Events)** 는 서버가 **단방향 스트리밍**으로 텍스트 이벤트를 지속 전송하는 방식입니다.
* 브라우저의 `EventSource` 를 사용하며, 자동 재연결과 **순차적 메시지 보장**이 장점입니다.
* 채팅처럼 양방향이 필요하면 웹소켓을, 알림/로그/진행률 스트림이면 SSE가 간단합니다.

---

### 파일 경로 / 파일명

```
src/hooks/useSSE.js
src/App.js
```

---

### 1) 커스텀 훅 – `useSSE.js`

```javascript
import { useEffect, useRef, useState, useCallback } from "react";

/**
 * useSSE(url, {
 *   withCredentials?: boolean,  // 쿠키 필요 시
 *   enabled?: boolean,          // 구독 on/off
 *   onEvent?: (evt) => void,    // 모든 메시지 공통 후킹
 *   events?: Record<string, (data, evt) => void>, // 커스텀 이벤트 핸들러 { "progress": fn }
 * })
 *
 * 반환: { messages, error, open, close, readyState }
 * - messages: 기본 'message' 채널로 받은 payload 배열
 * - error: 연결 에러 객체
 * - open(): 수동 연결
 * - close(): 수동 종료
 * - readyState: 0(CONNECTING) | 1(OPEN) | 2(CLOSED)
 */
export default function useSSE(url, opts = {}) {
  const {
    withCredentials = false,
    enabled = true,
    onEvent,
    events = {},
  } = opts;

  const [messages, setMessages] = useState([]);
  const [error, setError] = useState(null);
  const [readyState, setReadyState] = useState(2); // CLOSED
  const esRef = useRef(null);

  const close = useCallback(() => {
    if (esRef.current) {
      esRef.current.close();
      esRef.current = null;
      setReadyState(2);
    }
  }, []);

  const open = useCallback(() => {
    if (!url || esRef.current) return;
    const es = new EventSource(url, { withCredentials });
    esRef.current = es;
    setReadyState(0); // CONNECTING
    setError(null);

    es.onopen = () => {
      setReadyState(1); // OPEN
    };

    es.onerror = (e) => {
      setError(e);
      // 브라우저가 자동 재연결을 시도함 (HTTP 2xx 이면서 네트워크 끊김 등)
      // 영구 오류(401/403/404 등)인 경우 서버가 재연결을 막을 수 있음
    };

    // 기본 'message' 이벤트
    es.onmessage = (evt) => {
      onEvent?.(evt);
      try {
        const payload = evt.data ? JSON.parse(evt.data) : null;
        setMessages((prev) => [...prev, payload]);
      } catch {
        // JSON이 아닐 수도 있으니 원문 저장
        setMessages((prev) => [...prev, evt.data]);
      }
    };

    // 사용자 정의 이벤트 바인딩 (예: event: progress)
    Object.entries(events).forEach(([type, handler]) => {
      es.addEventListener(type, (evt) => {
        onEvent?.(evt);
        let data = evt.data;
        try { data = JSON.parse(evt.data); } catch {}
        handler?.(data, evt);
      });
    });
  }, [url, withCredentials, onEvent, events]);

  // 라이프사이클 관리
  useEffect(() => {
    if (!enabled) {
      close();
      return;
    }
    open();
    return () => close();
  }, [enabled, open, close]);

  return { messages, error, open, close, readyState };
}
```

---

### 2) 사용 예제 – `App.js`

```javascript
import React, { useState } from "react";
import useSSE from "./hooks/useSSE";

/**
 * 테스트용 SSE 서버 아이디어
 * - Express 등에서:
 *   res.writeHead(200, {
 *     "Content-Type": "text/event-stream",
 *     "Cache-Control": "no-cache",
 *     Connection: "keep-alive",
 *   });
 *   let i = 0;
 *   setInterval(() => {
 *     res.write(`data: ${JSON.stringify({ tick: ++i, time: Date.now() })}\n\n`);
 *     // 커스텀 이벤트: progress
 *     res.write(`event: progress\n`);
 *     res.write(`data: ${JSON.stringify({ value: i % 100 })}\n\n`);
 *   }, 1000);
 */

export default function App() {
  const [enabled, setEnabled] = useState(true);
  const [progress, setProgress] = useState(0);

  const { messages, error, readyState } = useSSE(
    "http://localhost:3000/sse", // 실제 서버 주소로 교체
    {
      enabled,
      events: {
        progress: (data) => setProgress(data?.value ?? 0),
      },
    }
  );

  return (
    <div style={{ padding: 20 }}>
      <h1>useSSE 서버센트 이벤트 구독</h1>

      <div style={{ display: "flex", gap: 8, alignItems: "center" }}>
        <label>
          <input
            type="checkbox"
            checked={enabled}
            onChange={(e) => setEnabled(e.target.checked)}
          />
          구독 활성화
        </label>
        <span>상태: {["연결중", "연결됨", "종료"][readyState] || readyState}</span>
      </div>

      <div style={{ marginTop: 12 }}>
        <strong>진행률(커스텀 이벤트 progress):</strong>
        <div
          style={{
            width: 300,
            height: 10,
            background: "#e5e7eb",
            borderRadius: 6,
            overflow: "hidden",
            marginTop: 6,
          }}
        >
          <div
            style={{
              width: `${Math.min(100, Math.max(0, progress))}%`,
              height: "100%",
              background: "#2563eb",
            }}
          />
        </div>
      </div>

      <h3 style={{ marginTop: 16 }}>최근 메시지</h3>
      <ul style={{ maxHeight: 200, overflow: "auto", border: "1px solid #eee", padding: 8 }}>
        {messages.slice(-20).map((m, i) => (
          <li key={i}>
            <pre style={{ margin: 0 }}>{typeof m === "string" ? m : JSON.stringify(m, null, 2)}</pre>
          </li>
        ))}
      </ul>

      {error && <p style={{ color: "crimson" }}>에러: {String(error.message || error)}</p>}
    </div>
  );
}
```

---

## 동작/구현 포인트

* **자동 재연결**: `EventSource`는 네트워크가 잠시 끊겨도 브라우저가 재연결을 시도합니다.
* **커스텀 이벤트**: 서버가 `event: progress` 같은 라인을 보내면 `addEventListener('progress')`로 분리 처리 가능.
* **CORS/인증**: 쿠키가 필요한 경우 `withCredentials: true` + 서버의 `Access-Control-Allow-Credentials: true`.
* **형식**: 각 이벤트는 `data: ...\n\n` 형태. 여러 줄 `data:` 가능. `id:`/`retry:` 헤더로 재연결 정책 제어 가능.
* **리소스 정리**: 언마운트/비활성화 시 `close()` 호출로 연결을 닫아 누수 방지.

---

## 선택 가이드: WebSocket vs SSE

| 구분     | SSE                 | WebSocket      |
| ------ | ------------------- | -------------- |
| 방향     | 서버 → 클라이언트 단방향      | 양방향            |
| 프로토콜   | HTTP/1.1 keep-alive | 전용 ws/wss      |
| 재연결    | 브라우저 기본 제공          | 직접 구현 필요       |
| 메시지 형식 | 텍스트(EventStream)    | 자유(텍스트/바이너리)   |
| 용도     | 알림/로그/진행률/스트림       | 채팅/게임/양방향 상호작용 |

---

다음은 **66번 – useGraphQL GraphQL 요청**으로 넘어가겠습니다. 계속 진행할까요?
