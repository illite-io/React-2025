좋습니다. **67번 – useApiCache API 캐싱**로 진행하겠습니다.

---

## 67. useApiCache API 캐싱

### 목표

* 동일 파라미터로 반복 호출되는 API를 **메모리 캐시**로 절약
* TTL(만료시간), 인플라이트 요청 공유(중복 호출 방지), 무효화/초기화 제공
* 사용자는 `get(key, fetcher, { ttl })`로 간단히 사용

---

### 파일 경로 / 파일명

```
src/hooks/useApiCache.js
src/App.js
```

---

### 1) 커스텀 훅 – `useApiCache.js`

```javascript
import { useCallback } from "react";

/**
 * 내부 캐시 구조
 * key: string →
 *   {
 *     value: any,
 *     expiresAt: number,        // Date.now() 기준
 *     inFlight?: Promise<any>,  // 같은 키의 중복 fetch 합치기
 *   }
 */
const CACHE = new Map();

function now() {
  return Date.now();
}

function isFresh(entry) {
  return entry && entry.expiresAt > now();
}

/**
 * useApiCache()
 * - get(key, fetcher, { ttl, force }?)
 *   - key: 캐시 키(파라미터 포함하여 고유해야 함)
 *   - fetcher: () => Promise<any>
 *   - ttl: ms (기본 30초)
 *   - force: true면 캐시 무시하고 새로 요청
 *
 * - set(key, value, ttl?)
 * - invalidate(key?)
 * - clear()
 * - has(key)
 */
export default function useApiCache() {
  const get = useCallback(async (key, fetcher, opts = {}) => {
    const { ttl = 30_000, force = false } = opts;
    let entry = CACHE.get(key);

    if (!force && isFresh(entry)) {
      return entry.value;
    }

    // 이미 같은 키로 요청 중이면 그 Promise 재사용
    if (!force && entry?.inFlight) {
      return entry.inFlight;
    }

    // 새 요청 시작
    const p = Promise.resolve()
      .then(fetcher)
      .then((value) => {
        CACHE.set(key, { value, expiresAt: now() + ttl });
        return value;
      })
      .finally(() => {
        const cur = CACHE.get(key);
        if (cur && cur.inFlight) {
          // inFlight 제거
          CACHE.set(key, { value: cur.value, expiresAt: cur.expiresAt });
        }
      });

    // inFlight로 마킹
    CACHE.set(key, { ...(entry || {}), inFlight: p, expiresAt: now() - 1 });
    return p;
  }, []);

  const set = useCallback((key, value, ttl = 30_000) => {
    CACHE.set(key, { value, expiresAt: now() + ttl });
  }, []);

  const invalidate = useCallback((key) => {
    if (key) CACHE.delete(key);
    else CACHE.clear();
  }, []);

  const clear = useCallback(() => CACHE.clear(), []);
  const has = useCallback((key) => isFresh(CACHE.get(key)), []);

  return { get, set, invalidate, clear, has };
}
```

---

### 2) 사용 예제 – `App.js` (리스트 캐싱 + 강제 새로고침)

```javascript
import React, { useEffect, useState } from "react";
import useApiCache from "./hooks/useApiCache";

// 단순 fetcher
const fetchPosts = async (limit = 5) => {
  const res = await fetch(`https://jsonplaceholder.typicode.com/posts?_limit=${limit}`);
  if (!res.ok) throw new Error(`HTTP ${res.status}`);
  return res.json();
};

export default function App() {
  const { get, invalidate } = useApiCache();
  const [posts, setPosts] = useState(null);
  const [loading, setLoading] = useState(false);
  const limit = 5;
  const key = `posts?limit=${limit}`;

  const load = async ({ force = false } = {}) => {
    setLoading(true);
    try {
      const data = await get(key, () => fetchPosts(limit), { ttl: 20_000, force });
      setPosts(data);
    } catch (e) {
      console.error(e);
      setPosts(null);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    load(); // 마운트 시 캐시 읽거나 요청
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  return (
    <div style={{ maxWidth: 640, margin: "40px auto", padding: "0 16px" }}>
      <h1>useApiCache API 캐싱</h1>
      <div style={{ display: "flex", gap: 8, marginBottom: 12 }}>
        <button onClick={() => load()}>불러오기(캐시 사용)</button>
        <button onClick={() => load({ force: true })}>강제 새로고침(force)</button>
        <button onClick={() => { invalidate(key); }}>이 키만 무효화</button>
        <button onClick={() => { invalidate(); }}>전체 캐시 비우기</button>
      </div>

      {loading && <p>로딩 중...</p>}
      {!loading && posts && (
        <ul>
          {posts.map((p) => (
            <li key={p.id}>
              <strong>{p.title}</strong>
              <p>{p.body}</p>
            </li>
          ))}
        </ul>
      )}
    </div>
  );
}
```

---

## 동작 요약

* 동일 키로 여러 컴포넌트/이벤트에서 동시에 호출해도 **인플라이트 공유**로 네트워크 1회만 수행.
* TTL 내에는 **메모리 캐시 히트**로 즉시 반환.
* 필요 시 `force: true`로 강제 최신화, `invalidate(key)`로 수동 무효화.

---

## 실무 팁

* 키 설계: URL + 정렬/필터 파라미터를 모두 포함해 **충분히 구체적**이어야 합니다.
* 사용자 액션 후 최신화: 생성/수정/삭제 이후 관련 키를 `invalidate`하거나 `force`로 즉시 동기화.
* 영속 캐시가 필요하면 `localStorage/IndexedDB` 백엔드를 붙인 변형 훅을 추가(네트워크 오프라인 대응).
* SWR 패턴이 필요하면:

  * 먼저 캐시값을 즉시 반환
  * 백그라운드에서 `force` 요청 후 **값 바뀌면 컴포넌트 상태 갱신**(현재 예제는 이벤트에서 `load({force:true})`로 구현).

---

다음은 **68번 – useUpload 파일 업로드 상태 관리**로 넘어가겠습니다. 계속 진행할까요?
