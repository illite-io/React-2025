좋습니다. 이번에는 **63번 – useRetry 요청 재시도** 예제를 보겠습니다.

---

## 63. useRetry 요청 재시도

### 목표

* 실패한 비동기 요청을 **자동 또는 수동으로 재시도**
* 최대 시도 횟수, 지수 백오프(대기 시간 점점 증가) 지원
* 네트워크 불안정 환경에서도 안정적으로 동작

---

### 파일 경로 / 파일명

```
src/hooks/useRetry.js
src/App.js
```

---

### 1) 커스텀 훅 – `useRetry.js`

```javascript
import { useCallback, useState } from "react";

/**
 * useRetry(fetcher, { retries, delay })
 * - fetcher: Promise 반환 함수
 * - retries: 최대 재시도 횟수 (기본 3)
 * - delay: 최초 지연(ms), 이후 지수적으로 증가 (기본 1000ms)
 *
 * 반환값:
 * { run, loading, error, data, attempt }
 */
export default function useRetry(fetcher, opts = {}) {
  const { retries = 3, delay = 1000 } = opts;

  const [loading, setLoading] = useState(false);
  const [attempt, setAttempt] = useState(0);
  const [error, setError] = useState(null);
  const [data, setData] = useState(null);

  const sleep = (ms) => new Promise((r) => setTimeout(r, ms));

  const run = useCallback(async (...args) => {
    setLoading(true);
    setError(null);
    setData(null);

    for (let i = 0; i <= retries; i++) {
      setAttempt(i + 1);
      try {
        const result = await fetcher(...args);
        setData(result);
        setLoading(false);
        return result;
      } catch (err) {
        setError(err);
        if (i < retries) {
          const wait = delay * Math.pow(2, i); // 지수 백오프
          await sleep(wait);
        } else {
          setLoading(false);
          throw err;
        }
      }
    }
  }, [fetcher, retries, delay]);

  return { run, loading, error, data, attempt };
}
```

---

### 2) 사용 예제 – `App.js`

```javascript
import React from "react";
import useRetry from "./hooks/useRetry";

// 실패 확률이 있는 가짜 API
async function unstableApi() {
  await new Promise((r) => setTimeout(r, 500));
  if (Math.random() < 0.6) {
    throw new Error("랜덤 실패 발생!");
  }
  return { success: true, time: new Date().toISOString() };
}

export default function App() {
  const { run, loading, error, data, attempt } = useRetry(unstableApi, {
    retries: 3,
    delay: 1000,
  });

  const handleClick = async () => {
    try {
      await run();
    } catch (e) {
      console.error("최종 실패:", e);
    }
  };

  return (
    <div style={{ padding: 20 }}>
      <h1>useRetry 요청 재시도</h1>
      <button onClick={handleClick} disabled={loading}>
        {loading ? "요청 중..." : "요청 실행"}
      </button>

      <p>시도 횟수: {attempt}</p>
      {error && <p style={{ color: "red" }}>에러: {error.message}</p>}
      {data && (
        <p style={{ color: "green" }}>
          성공! {JSON.stringify(data)}
        </p>
      )}
    </div>
  );
}
```

---

### 실행 흐름

1. `run()` 실행 → API 요청 시작
2. 실패 시 → `delay`, `delay*2`, `delay*4` … 방식으로 대기 후 재시도
3. 성공 시 → `data` 반환, `loading=false`
4. 모든 시도 실패 시 → 최종 에러 반환

---

### 활용 아이디어

* 네트워크 불안정 환경에서 API 안정성 강화
* 파일 업로드 시 실패 → 자동 재시도
* 채팅/알림 서비스에서 중요한 요청 보장

---

다음은 **64번 – useWebSocket 웹소켓 연결** 예제로 넘어가시겠습니까?
