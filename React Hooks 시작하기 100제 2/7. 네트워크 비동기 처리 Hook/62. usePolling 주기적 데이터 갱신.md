좋습니다. **62번 – usePolling 주기적 데이터 갱신**으로 진행하겠습니다.

---

## 62. usePolling 주기적 데이터 갱신

### 목표

* 일정 주기로 API를 호출해 데이터를 갱신
* 탭 비활성화 시 일시중지, 에러 시 지수 백오프
* 수동 `refetch`, `start/stop` 제어

---

### 파일 경로 / 파일명

```
src/hooks/usePolling.js
src/App.js
```

---

### 1) 커스텀 훅 – `usePolling.js`

```javascript
import { useCallback, useEffect, useRef, useState } from "react";

/**
 * usePolling(fetcher, {
 *   interval: 5000,        // 기본 주기(ms)
 *   leading: true,         // 시작하자마자 한 번 실행
 *   pauseWhenHidden: true, // 탭 비활성화 시 일시중지
 *   maxInterval: 60_000,   // 백오프 상한
 *   enabled: true,         // 전체 활성/비활성
 * }?)
 *
 * 반환: { data, error, loading, start, stop, refetch, running }
 */
export default function usePolling(fetcher, opts = {}) {
  const {
    interval = 5000,
    leading = true,
    pauseWhenHidden = true,
    maxInterval = 60_000,
    enabled = true,
  } = opts;

  const [data, setData] = useState(null);
  const [error, setError] = useState(null);
  const [running, setRunning] = useState(Boolean(enabled));
  const [loading, setLoading] = useState(false);

  const timerRef = useRef(null);
  const currentIntervalRef = useRef(interval);
  const destroyedRef = useRef(false);

  const clearTimer = () => {
    if (timerRef.current) {
      clearTimeout(timerRef.current);
      timerRef.current = null;
    }
  };

  const scheduleNext = useCallback((delay) => {
    clearTimer();
    if (!running || destroyedRef.current) return;
    timerRef.current = setTimeout(() => {
      tick();
    }, delay);
  }, [running]);

  const tick = useCallback(async () => {
    if (!running) return;
    setLoading(true);
    setError(null);
    try {
      const result = await fetcher();
      if (destroyedRef.current) return;
      setData(result);
      // 성공 시 간격 리셋
      currentIntervalRef.current = interval;
      scheduleNext(currentIntervalRef.current);
    } catch (e) {
      if (destroyedRef.current) return;
      setError(e);
      // 에러 시 지수 백오프
      currentIntervalRef.current = Math.min(
        Math.max(1000, currentIntervalRef.current * 2),
        maxInterval
      );
      scheduleNext(currentIntervalRef.current);
    } finally {
      if (!destroyedRef.current) setLoading(false);
    }
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [fetcher, interval, maxInterval, running]);

  const start = useCallback(() => {
    if (running) return;
    setRunning(true);
  }, [running]);

  const stop = useCallback(() => {
    setRunning(false);
    clearTimer();
  }, []);

  const refetch = useCallback(() => {
    // 즉시 한 번 실행하고 다음 주기 예약
    clearTimer();
    currentIntervalRef.current = interval;
    tick();
  }, [interval, tick]);

  // running/on-off에 따른 시작/정지
  useEffect(() => {
    if (!enabled) {
      stop();
      return;
    }
    if (running) {
      if (leading && !data && !loading) {
        // 첫 시작 시 즉시 한 번
        refetch();
      } else if (!timerRef.current) {
        scheduleNext(currentIntervalRef.current);
      }
    } else {
      clearTimer();
    }
    // cleanup on unmount
    return () => {};
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [running, enabled]);

  // 탭 가시성에 따른 일시중지
  useEffect(() => {
    if (!pauseWhenHidden) return;
    const onVis = () => {
      if (document.hidden) {
        clearTimer();
      } else if (running) {
        // 다시 보이면 즉시 동기화
        refetch();
      }
    };
    document.addEventListener("visibilitychange", onVis);
    return () => document.removeEventListener("visibilitychange", onVis);
  }, [pauseWhenHidden, running, refetch]);

  // 언마운트 정리
  useEffect(() => {
    destroyedRef.current = false;
    return () => {
      destroyedRef.current = true;
      clearTimer();
    };
  }, []);

  return { data, error, loading, start, stop, refetch, running };
}
```

---

### 2) 사용 예제 – `App.js`

```javascript
import React from "react";
import usePolling from "./hooks/usePolling";

// 예시 fetcher: 서버 시간 또는 임의 데이터
async function fetchServerTime() {
  // 네트워크 지연/에러 흉내
  await new Promise((r) => setTimeout(r, 300));
  // 간헐적 에러
  if (Math.random() < 0.1) throw new Error("임시 오류");
  return { now: new Date().toISOString() };
}

export default function App() {
  const {
    data, error, loading, start, stop, refetch, running
  } = usePolling(fetchServerTime, {
    interval: 5000,
    leading: true,
    pauseWhenHidden: true,
    maxInterval: 30000,
    enabled: true,
  });

  return (
    <div style={{ padding: 20 }}>
      <h1>usePolling 주기적 데이터 갱신</h1>
      <p>상태: {running ? "실행 중" : "중지"}</p>
      {loading && <p>요청 중...</p>}
      {error && <p style={{ color: "crimson" }}>에러: {error.message}</p>}
      {data && (
        <pre style={{ background: "#f8fafc", padding: 12 }}>{JSON.stringify(data, null, 2)}</pre>
      )}

      <div style={{ display: "flex", gap: 8, marginTop: 12 }}>
        <button onClick={refetch}>지금 새로고침</button>
        <button onClick={start} disabled={running}>시작</button>
        <button onClick={stop} disabled={!running}>정지</button>
      </div>

      <p style={{ color: "#64748b", marginTop: 8 }}>
        에러 발생 시 간격이 2배로 증가(최대 30초), 성공하면 기본 간격(5초)으로 복귀합니다.
        탭이 비활성화되면 일시중지됩니다.
      </p>
    </div>
  );
}
```

---

## 실무 팁

* API 한도(rate limit)가 있는 경우, 백오프와 함께 **서버가 제공하는 Retry-After 헤더**를 반영해 간격을 조절하세요.
* 여러 폴링을 동시에 돌리면 부하가 커질 수 있습니다. 공통 스케줄러로 합치거나 웹소켓/SSE로 대체를 고려.
* 리스트 갱신 시에는 **낙관적 업데이트(91번)** 또는 **디프 머지**로 UI 점프를 줄이세요.
* 폴링이 로그인 세션/토큰에 의존한다면, 토큰 만료 시 자동 정지 및 재인증 흐름을 포함하세요.

---

다음은 **63번 – useRetry 요청 재시도**로 이어가겠습니다. 계속 진행할까요?
