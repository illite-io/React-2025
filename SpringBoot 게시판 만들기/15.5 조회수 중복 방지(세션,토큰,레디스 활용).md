좋습니다. 이제 15-5 단계, \*\*조회수 중복 방지(세션/토큰/레디스 활용)\*\*로 넘어가겠습니다.
일반적인 게시판 API에서 조회수는 단순히 `UPDATE posts SET views = views+1` 방식으로 증가시키지만, **같은 사용자가 짧은 시간 안에 여러 번 새로고침할 때 중복 집계되는 문제**가 있습니다. 이를 방지하는 것이 이번 단계의 목적입니다.

---

# 1) 가장 흔한 방법들

1. **세션 기반**

   * 서버 세션(HttpSession)에 "방문한 게시글 ID"를 기록
   * 단점: 서버가 다중 인스턴스일 때 세션 공유 필요 (분산 환경에서는 부적합)

2. **JWT 토큰 기반**

   * 로그인된 사용자라면 토큰에서 사용자 ID를 추출
   * “사용자별-게시글별-조회시간”을 기록해 일정 시간 내 중복 조회 방지

3. **Redis 기반(실무에서 가장 일반적)**

   * 키: `view:{postId}:{userId}` 또는 비로그인 시 `view:{postId}:{ip}`
   * TTL(만료시간)을 1시간/하루로 설정
   * 키가 존재하면 조회수 증가 X, 없으면 증가 후 키 저장

---

# 2) Redis 의존성 추가

`pom.xml`

```xml
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
```

---

# 3) Redis 설정

`src/main/resources/application.yml`

```yaml
spring:
  data:
    redis:
      host: localhost
      port: 6379
```

로컬에서 Redis 실행:

```bash
# Windows WSL 또는 Docker 사용
docker run -d --name redis -p 6379:6379 redis:7
```

---

# 4) 조회수 처리 서비스 개선

`src/main/java/com/example/boardapi/service/PostService.java` 일부 수정

```java
import org.springframework.data.redis.core.StringRedisTemplate;
import java.util.concurrent.TimeUnit;

@Service
public class PostService {
    private final PostMapper postMapper;
    private final StringRedisTemplate redisTemplate;

    public PostService(PostMapper postMapper, StringRedisTemplate redisTemplate) {
        this.postMapper = postMapper;
        this.redisTemplate = redisTemplate;
    }

    @Transactional
    public PostResponse findOne(Long id, String userKey) {
        Post found = postMapper.findById(id);
        if (found == null) throw new ApiException(ErrorCode.NOT_FOUND);

        // Redis 키: view:postId:userKey
        String redisKey = "view:" + id + ":" + userKey;

        Boolean isNew = redisTemplate.opsForValue().setIfAbsent(redisKey, "1", 1, TimeUnit.HOURS);
        // setIfAbsent = key가 없으면 저장(true), 있으면 false

        if (Boolean.TRUE.equals(isNew)) {
            postMapper.increaseViews(id);
            found.setViews(found.getViews() + 1); // 캐싱 반영
        }

        return toResponse(found);
    }
}
```

---

# 5) 컨트롤러 수정 (사용자 구분값 전달)

`src/main/java/com/example/boardapi/controller/PostController.java`

```java
@GetMapping("/{id}")
public ApiResponse<PostResponse> detail(@PathVariable Long id,
        HttpServletRequest request,
        @AuthenticationPrincipal(expression = "username") String username) {

    String userKey;
    if (username != null) {
        // 로그인 사용자 → username
        userKey = username;
    } else {
        // 비로그인 사용자 → IP 주소
        userKey = request.getRemoteAddr();
    }

    return ApiResponse.ok(postService.findOne(id, userKey));
}
```

---

# 6) 동작 방식

1. 사용자가 게시글 상세 API 호출 → 컨트롤러에서 `userKey` 생성 (로그인 시 username, 비로그인 시 IP)
2. Redis에 `view:{postId}:{userKey}` 키 검색
3. 없으면 → 조회수 증가 + Redis에 키 저장 (1시간 TTL)
4. 있으면 → 조회수 증가 안 함

---

# 7) 이해 포인트

* **왜 Redis인가?**

  * 다중 서버 환경에서도 키-값 저장소로 중앙에서 중복 확인 가능
  * TTL로 자동 만료 → 특정 기간 내 중복만 막고, 시간이 지나면 다시 집계 가능

* **유저 구분 키(userKey)**

  * 로그인 사용자: username/id → 정확한 중복 방지
  * 비로그인 사용자: IP 주소 사용 (프록시 환경에선 한계 있음)

* **TTL 설정**

  * 1시간/24시간 등 비즈니스 요구에 맞게 조정
  * 너무 짧으면 중복 집계 발생, 너무 길면 조회수가 실제보다 적게 반영됨

---

여기까지가 **조회수 중복 방지**의 가장 일반적인 구현입니다.

다음 단계는 15-6, **정렬/다중 조건 검색/동적 SQL 고도화**입니다. 이 부분으로 바로 이어갈까요?
