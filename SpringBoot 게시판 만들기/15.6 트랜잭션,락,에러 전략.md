좋습니다. 이제 15-7 단계, \*\*트랜잭션/락/에러 전략(실전 운영 팁)\*\*으로 넘어가겠습니다.
이 단계는 단순히 코드 구현이 아니라, **운영 환경에서 데이터 무결성과 동시성 문제를 어떻게 다루는지**를 다루는 중요한 부분입니다.

---

# 1) 트랜잭션(Transaction)

## 기본 원칙

* **원자성(Atomicity)**: 여러 DB 작업을 하나로 묶어 "전부 성공 or 전부 실패" 처리
* **예시**: 게시글 작성 시 → `posts` INSERT + `attachments` INSERT + `comments` INSERT 중 하나라도 실패하면 전체 롤백

## 구현 (Spring Boot)

```java
@Service
public class PostService {
    @Transactional
    public Long createPostWithFiles(PostCreateRequest req, List<MultipartFile> files) {
        // 1) 게시글 저장
        Post post = new Post();
        post.setTitle(req.title());
        post.setContent(req.content());
        post.setAuthorId(req.authorId());
        postMapper.insert(post);

        // 2) 파일 저장
        for (MultipartFile file : files) {
            fileService.saveFile(post.getId(), file); // 내부적으로 Attachment INSERT
        }

        // 하나라도 실패하면 RuntimeException 발생 → 전체 롤백
        return post.getId();
    }
}
```

**중요**: `@Transactional`은 기본적으로 `RuntimeException`이 발생하면 롤백합니다.
체크 예외(Exception)를 롤백하려면 `@Transactional(rollbackFor = Exception.class)` 추가 필요.

---

# 2) 락(Lock) 전략

## 상황 예시

* 동시에 여러 사용자가 같은 게시글을 수정하거나 조회수를 증가시킬 때 → 데이터 불일치 발생 가능

## 락 종류

1. **낙관적 락(Optimistic Lock)**

   * 버전 번호(`version`)를 두고 업데이트 시 검증
   * 충돌 시 예외 발생 → 재시도 필요
   * 예: `WHERE id=? AND version=?` 조건으로 UPDATE

2. **비관적 락(Pessimistic Lock)**

   * `SELECT ... FOR UPDATE` 구문으로 레코드를 읽을 때 DB 차원에서 잠금
   * 동시성이 낮을 때 안정적이지만, 트래픽 많으면 데드락 위험

---

# 3) 예시 (조회수 증가 시 비관적 락)

`PostMapper.xml`

```xml
<select id="findByIdForUpdate" resultMap="PostResult">
  SELECT <include refid="columns"/>
  FROM posts
  WHERE id = #{id}
  FOR UPDATE
</select>
```

`PostService.java`

```java
@Transactional
public void increaseViewWithLock(Long id) {
    Post p = postMapper.findByIdForUpdate(id);
    if (p == null) throw new ApiException(ErrorCode.NOT_FOUND);
    postMapper.increaseViews(id);
}
```

이 방식은 **트랜잭션이 끝날 때까지 행이 잠금 상태**이므로 동시성 문제를 막을 수 있습니다.

---

# 4) 에러 전략

## 일반적인 에러 구분

1. **비즈니스 에러**: "없는 게시글", "권한 없음"

   * → `ApiException` + 커스텀 ErrorCode 반환
2. **시스템 에러**: DB 연결 끊김, Redis 장애

   * → `500 INTERNAL_ERROR` 반환 + 로깅/모니터링
3. **데이터 무결성 위반**: Unique 키 중복, FK 제약조건 위반

   * → 예외 캐치 후 `400 BAD_REQUEST` 또는 `409 CONFLICT`로 변환

## 글로벌 핸들러 활용

이미 작성한 `GlobalExceptionHandler`에서 케이스별 매핑:

```java
@ExceptionHandler(DataIntegrityViolationException.class)
public ApiResponse<?> handleDataIntegrity(DataIntegrityViolationException e) {
    return ApiResponse.fail("데이터 무결성 위반: " + e.getMessage());
}
```

---

# 5) 운영 팁

* **트랜잭션 범위 최소화**: DB 작업이 끝난 후 오래 걸리는 작업(파일 업로드, 외부 API 호출 등)은 트랜잭션 밖에서 처리
* **데드락 방지**: UPDATE 순서를 코드 전반에 통일 (예: 항상 `user → post → comment` 순)
* **모니터링**: Sentry, ELK, Prometheus 등으로 예외/락/에러 발생률 추적
* **재시도 전략**: 낙관적 락 충돌 시 사용자에게 재시도 요청 or 자동 재시도 로직 추가

---

# 6) 이해 포인트

* **트랜잭션**은 데이터 일관성 보장의 핵심 → 반드시 서비스 계층에서 단위로 묶어야 함
* **락 전략**은 상황에 맞게 선택:

  * 읽기 많은 경우 → 낙관적 락
  * 쓰기 충돌 많은 경우 → 비관적 락
* **에러 처리**는 API 사용자에게 일관된 응답 포맷을 제공해야 함 (`ApiResponse.fail`)
* **운영 팁**은 실무에서 발생하는 장애(데드락, 중복 데이터, 세션 타임아웃 등)를 예방

---

여기까지가 **트랜잭션/락/에러 전략**에 대한 일반적이고 실무적인 구현과 운영 노하우입니다.

다음 단계는 15-8, \*\*테스트 코드(통합/단위)\*\*입니다. 바로 이어서 진행할까요?
