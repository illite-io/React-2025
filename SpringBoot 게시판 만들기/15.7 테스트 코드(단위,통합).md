좋습니다. 이제 15-8 단계, \*\*테스트 코드(통합/단위)\*\*로 넘어가겠습니다.
API 서버가 커질수록 “코드가 잘 동작하는지 자동으로 확인하는 테스트 코드”가 필수입니다.

---

# 1) 테스트의 종류

1. **단위(Unit) 테스트**

   * 특정 클래스/메서드 단위만 검증
   * 예: `PostService.create()`가 DB 저장을 정상 호출하는지
   * DB/외부 API는 Mock 처리

2. **통합(Integration) 테스트**

   * 스프링 컨텍스트 + DB(MySQL or H2)까지 포함
   * 예: `/api/posts` 엔드포인트 호출 → DB에 실제 데이터가 저장되는지

---

# 2) 의존성 (pom.xml)

Spring Boot Starter Test에는 JUnit5, Mockito, AssertJ, MockMvc 등이 이미 포함되어 있습니다.
추가로 H2 인메모리 DB를 사용하면 빠른 통합 테스트가 가능합니다.

```xml
<dependency>
  <groupId>com.h2database</groupId>
  <artifactId>h2</artifactId>
  <scope>test</scope>
</dependency>
```

---

# 3) 단위 테스트 예시

`src/test/java/com/example/boardapi/service/PostServiceTest.java`

```java
package com.example.boardapi.service;

import com.example.boardapi.domain.Post;
import com.example.boardapi.dto.PostCreateRequest;
import com.example.boardapi.mapper.PostMapper;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;

import static org.assertj.core.api.Assertions.assertThat;

class PostServiceTest {

    @Test
    void 게시글_등록_성공() {
        // given
        PostMapper mockMapper = Mockito.mock(PostMapper.class);
        PostService service = new PostService(mockMapper, null);

        PostCreateRequest req = new PostCreateRequest("제목", "내용", 1L);

        // when
        Long postId = service.create(req);

        // then
        assertThat(postId).isNotNull();
        Mockito.verify(mockMapper, Mockito.times(1)).insert(Mockito.any(Post.class));
    }
}
```

* DB 없이 **Mock 객체**를 사용하여 서비스 로직만 검증
* 빠르고 독립적

---

# 4) 통합 테스트 예시 (MockMvc)

`src/test/java/com/example/boardapi/controller/PostControllerTest.java`

```java
package com.example.boardapi.controller;

import com.example.boardapi.BoardApiApplication;
import com.example.boardapi.dto.PostCreateRequest;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@SpringBootTest(classes = BoardApiApplication.class)
@AutoConfigureMockMvc
class PostControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private ObjectMapper objectMapper;

    @Test
    void 게시글_등록_API_성공() throws Exception {
        PostCreateRequest req = new PostCreateRequest("테스트 제목", "테스트 내용", 1L);

        mockMvc.perform(post("/api/posts")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(req)))
                .andExpect(status().isOk());
    }
}
```

* 실제 스프링 컨텍스트 로딩 → 컨트롤러/서비스/리포지토리 전체 호출
* DB는 테스트 환경에서 H2를 사용하거나, MySQL Test DB를 따로 구성

---

# 5) H2 DB 테스트 설정

`src/test/resources/application.yml`

```yaml
spring:
  datasource:
    url: jdbc:h2:mem:testdb;MODE=MYSQL;DB_CLOSE_DELAY=-1;DATABASE_TO_UPPER=false
    driver-class-name: org.h2.Driver
    username: sa
    password:
  mybatis:
    mapper-locations: classpath:mapper/**/*.xml
    configuration:
      map-underscore-to-camel-case: true
```

테스트 실행 시 실제 MySQL 대신 **H2 메모리 DB**를 사용 → 빠른 테스트 가능.

---

# 6) 이해 포인트

* **단위 테스트**: 빠르고 독립적, 비즈니스 로직 안정성 확보
* **통합 테스트**: API 동작 확인, 실제 DB/환경에 가까움
* **MockMvc**: 실제 HTTP 요청을 흉내내어 컨트롤러 테스트
* **H2 DB**: MySQL 호환 모드로 테스트 DB 실행 가능
* **CI/CD 연동**: GitHub Actions, GitLab CI에서 자동 실행하도록 구성 → 코드 변경 시 자동 검증

---

여기까지가 **테스트 코드(통합/단위)** 단계입니다.
다음은 15-9, **다중 프로필(application-dev.yml / -prod.yml)** 단계인데, 이어서 설명해드릴까요?
