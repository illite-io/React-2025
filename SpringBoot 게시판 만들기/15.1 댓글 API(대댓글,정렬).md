좋습니다. 15번 로드맵의 1번, \*\*“댓글 API 추가(대댓글/정렬)”\*\*부터 바로 구현하겠습니다.
아래는 “가장 일반적인 순서”로 진행한 **스키마 → 코드(도메인/DTO/Mapper/Service/Controller) → 점검**까지의 전체 단계입니다. 파일 경로/파일명을 모두 명시했습니다.

---

# 1) DB 스키마 확장 (대댓글/정렬용 컬럼 추가)

이미 `comments` 테이블이 있으므로, \*\*대댓글 구조(Adjacency List)\*\*와 정렬을 위해 컬럼을 추가합니다.

```sql
USE boarddb;

ALTER TABLE comments
  ADD COLUMN parent_id  BIGINT NULL AFTER author_id,
  ADD COLUMN thread_id  BIGINT NOT NULL DEFAULT 0 AFTER parent_id,
  ADD COLUMN depth      INT    NOT NULL DEFAULT 0 AFTER thread_id,
  ADD COLUMN is_deleted TINYINT(1) NOT NULL DEFAULT 0 AFTER content,
  ADD COLUMN deleted_at TIMESTAMP NULL DEFAULT NULL AFTER is_deleted;

-- 인덱스(목록/정렬/부모 탐색 최적화)
CREATE INDEX idx_comments_post_thread ON comments(post_id, thread_id, created_at);
CREATE INDEX idx_comments_parent      ON comments(parent_id);
```

정렬 규칙(가장 일반적):

* **스레드 정렬**: 최신 스레드(최상위 댓글) 먼저 → `thread_id DESC`
* **스레드 내 대댓글 정렬**: 등록 순서대로 → `id ASC`
  이 조합으로 “최신 글의 댓글 스레드가 위에, 그 안에서는 대댓글이 시간순”이 됩니다.

---

# 2) 도메인(엔티티) 수정

`src/main/java/com/example/boardapi/domain/Comment.java`

```java
package com.example.boardapi.domain;

import lombok.Data;
import java.time.LocalDateTime;

@Data
public class Comment {
    private Long id;
    private Long postId;
    private Long authorId;
    private Long parentId;   // 최상위는 null
    private Long threadId;   // 스레드 그룹 식별자(최상위 댓글의 id)
    private Integer depth;   // 0=최상위, 1=대댓글, ...
    private String content;
    private Boolean isDeleted;
    private LocalDateTime createdAt;
    private LocalDateTime deletedAt;
}
```

---

# 3) DTO 추가

`src/main/java/com/example/boardapi/dto/CommentCreateRequest.java`

```java
package com.example.boardapi.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;

public record CommentCreateRequest(
        @NotNull  Long authorId,
        @NotBlank String content,
        Long parentId // null이면 최상위 댓글
) {}
```

`src/main/java/com/example/boardapi/dto/CommentUpdateRequest.java`

```java
package com.example.boardapi.dto;

import jakarta.validation.constraints.NotBlank;

public record CommentUpdateRequest(
        @NotBlank String content
) {}
```

`src/main/java/com/example/boardapi/dto/CommentResponse.java`

```java
package com.example.boardapi.dto;

import java.time.LocalDateTime;

public record CommentResponse(
        Long id,
        Long postId,
        Long authorId,
        Long parentId,
        Long threadId,
        Integer depth,
        String content,
        Boolean isDeleted,
        LocalDateTime createdAt,
        LocalDateTime deletedAt
) {}
```

---

# 4) Mapper 인터페이스

`src/main/java/com/example/boardapi/mapper/CommentMapper.java`

```java
package com.example.boardapi.mapper;

import com.example.boardapi.domain.Comment;
import org.apache.ibatis.annotations.Param;

import java.util.List;

public interface CommentMapper {

    int insert(Comment c);                      // useGeneratedKeys=true
    int updateContent(@Param("id") Long id, @Param("content") String content);
    int softDelete(@Param("id") Long id);
    int updateThreadId(@Param("id") Long id, @Param("threadId") Long threadId);

    Comment findById(@Param("id") Long id);
    long    countChildren(@Param("id") Long id);

    List<Comment> findByPost(
            @Param("postId") Long postId,
            @Param("offset") int offset,
            @Param("limit") int limit
    );
    long countByPost(@Param("postId") Long postId);
}
```

---

# 5) Mapper XML

`src/main/resources/mapper/CommentMapper.xml`

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="com.example.boardapi.mapper.CommentMapper">

  <resultMap id="CommentResult" type="com.example.boardapi.domain.Comment">
    <id     property="id"         column="id"/>
    <result property="postId"     column="post_id"/>
    <result property="authorId"   column="author_id"/>
    <result property="parentId"   column="parent_id"/>
    <result property="threadId"   column="thread_id"/>
    <result property="depth"      column="depth"/>
    <result property="content"    column="content"/>
    <result property="isDeleted"  column="is_deleted"/>
    <result property="createdAt"  column="created_at"/>
    <result property="deletedAt"  column="deleted_at"/>
  </resultMap>

  <sql id="columns">
    id, post_id, author_id, parent_id, thread_id, depth, content, is_deleted, created_at, deleted_at
  </sql>

  <insert id="insert" parameterType="com.example.boardapi.domain.Comment" useGeneratedKeys="true" keyProperty="id">
    INSERT INTO comments (post_id, author_id, parent_id, thread_id, depth, content)
    VALUES (#{postId}, #{authorId}, #{parentId}, #{threadId}, #{depth}, #{content})
  </insert>

  <update id="updateThreadId">
    UPDATE comments SET thread_id = #{threadId} WHERE id = #{id}
  </update>

  <update id="updateContent">
    UPDATE comments SET content = #{content} WHERE id = #{id} AND is_deleted = 0
  </update>

  <update id="softDelete">
    UPDATE comments
    SET is_deleted = 1,
        content = '(삭제된 댓글입니다.)',
        deleted_at = NOW()
    WHERE id = #{id} AND is_deleted = 0
  </update>

  <select id="findById" resultMap="CommentResult" parameterType="long">
    SELECT <include refid="columns"/>
    FROM comments
    WHERE id = #{id}
  </select>

  <select id="countChildren" resultType="long" parameterType="long">
    SELECT COUNT(*) FROM comments WHERE parent_id = #{id}
  </select>

  <!-- 정렬: 최신 스레드(thread_id DESC) → 스레드 내 오름차순(id ASC) -->
  <select id="findByPost" resultMap="CommentResult">
    SELECT <include refid="columns"/>
    FROM comments
    WHERE post_id = #{postId}
    ORDER BY thread_id DESC, id ASC
    LIMIT #{limit} OFFSET #{offset}
  </select>

  <select id="countByPost" resultType="long">
    SELECT COUNT(*) FROM comments WHERE post_id = #{postId}
  </select>

</mapper>
```

---

# 6) 서비스 계층

`src/main/java/com/example/boardapi/service/CommentService.java`

```java
package com.example.boardapi.service;

import com.example.boardapi.domain.Comment;
import com.example.boardapi.domain.Post;
import com.example.boardapi.dto.CommentCreateRequest;
import com.example.boardapi.dto.CommentResponse;
import com.example.boardapi.dto.CommentUpdateRequest;
import com.example.boardapi.dto.PageResponse;
import com.example.boardapi.exception.ApiException;
import com.example.boardapi.exception.ErrorCode;
import com.example.boardapi.mapper.CommentMapper;
import com.example.boardapi.mapper.PostMapper;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

@Service
public class CommentService {

    private final CommentMapper commentMapper;
    private final PostMapper postMapper;

    public CommentService(CommentMapper commentMapper, PostMapper postMapper) {
        this.commentMapper = commentMapper;
        this.postMapper = postMapper;
    }

    @Transactional
    public Long create(Long postId, CommentCreateRequest req) {
        // 1) 게시글 존재 확인
        Post post = postMapper.findById(postId);
        if (post == null) throw new ApiException(ErrorCode.NOT_FOUND);

        Comment c = new Comment();
        c.setPostId(postId);
        c.setAuthorId(req.authorId());
        c.setContent(req.content());

        if (req.parentId() == null) {
            // 최상위 댓글: 우선 thread_id=0 으로 INSERT → 생성된 id로 thread_id 갱신
            c.setParentId(null);
            c.setDepth(0);
            c.setThreadId(0L); // placeholder
            commentMapper.insert(c);
            commentMapper.updateThreadId(c.getId(), c.getId());
            return c.getId();
        } else {
            // 대댓글: 부모 댓글 확인 + 동일 post 검증
            Comment parent = commentMapper.findById(req.parentId());
            if (parent == null) throw new ApiException(ErrorCode.NOT_FOUND);
            if (!parent.getPostId().equals(postId)) throw new ApiException(ErrorCode.BAD_REQUEST);

            c.setParentId(parent.getId());
            c.setDepth(parent.getDepth() + 1);
            c.setThreadId(parent.getThreadId());
            commentMapper.insert(c);
            return c.getId();
        }
    }

    @Transactional
    public void update(Long id, CommentUpdateRequest req) {
        Comment found = commentMapper.findById(id);
        if (found == null) throw new ApiException(ErrorCode.NOT_FOUND);
        if (Boolean.TRUE.equals(found.getIsDeleted())) throw new ApiException(ErrorCode.BAD_REQUEST);
        commentMapper.updateContent(id, req.content());
    }

    @Transactional
    public void delete(Long id) {
        Comment found = commentMapper.findById(id);
        if (found == null) throw new ApiException(ErrorCode.NOT_FOUND);
        // 가장 일반적 운영 정책: 트리 보존을 위해 소프트 삭제
        commentMapper.softDelete(id);
    }

    public PageResponse<CommentResponse> list(Long postId, int page, int size) {
        int current = Math.max(1, page);
        int limit = Math.max(1, size);
        int offset = (current - 1) * limit;

        List<Comment> rows = commentMapper.findByPost(postId, offset, limit);
        long total = commentMapper.countByPost(postId);

        List<CommentResponse> items = rows.stream().map(this::toResponse).toList();
        return PageResponse.of(items, current, limit, total);
    }

    private CommentResponse toResponse(Comment c) {
        return new CommentResponse(
                c.getId(), c.getPostId(), c.getAuthorId(), c.getParentId(),
                c.getThreadId(), c.getDepth(), c.getContent(),
                c.getIsDeleted(), c.getCreatedAt(), c.getDeletedAt()
        );
    }
}
```

---

# 7) 컨트롤러

`src/main/java/com/example/boardapi/controller/CommentController.java`

```java
package com.example.boardapi.controller;

import com.example.boardapi.dto.CommentCreateRequest;
import com.example.boardapi.dto.CommentResponse;
import com.example.boardapi.dto.CommentUpdateRequest;
import com.example.boardapi.dto.PageResponse;
import com.example.boardapi.service.CommentService;
import com.example.boardapi.util.ApiResponse;
import jakarta.validation.Valid;
import org.springframework.web.bind.annotation.*;

@RestController
public class CommentController {

    private final CommentService commentService;
    public CommentController(CommentService commentService){ this.commentService = commentService; }

    // 댓글 목록 (스레드 정렬: 최신 스레드 우선, 스레드 내 오름차순)
    @GetMapping("/api/posts/{postId}/comments")
    public ApiResponse<PageResponse<CommentResponse>> list(
            @PathVariable Long postId,
            @RequestParam(defaultValue = "1") int page,
            @RequestParam(defaultValue = "20") int size
    ) {
        return ApiResponse.ok(commentService.list(postId, page, size));
    }

    // 댓글 등록 (parentId가 null이면 최상위, 값이 있으면 대댓글)
    @PostMapping("/api/posts/{postId}/comments")
    public ApiResponse<Long> create(
            @PathVariable Long postId,
            @RequestBody @Valid CommentCreateRequest req
    ) {
        return ApiResponse.ok(commentService.create(postId, req));
    }

    // 댓글 수정
    @PutMapping("/api/comments/{id}")
    public ApiResponse<Void> update(
            @PathVariable Long id,
            @RequestBody @Valid CommentUpdateRequest req
    ) {
        commentService.update(id, req);
        return ApiResponse.ok(null, "updated");
    }

    // 댓글 삭제(소프트 삭제)
    @DeleteMapping("/api/comments/{id}")
    public ApiResponse<Void> delete(@PathVariable Long id) {
        commentService.delete(id);
        return ApiResponse.ok(null, "deleted");
    }
}
```

---

# 8) 빠른 기능 점검 (curl)

```bash
# 1) 최상위 댓글 등록 (postId=1 가정, authorId=1)
curl -X POST http://localhost:8080/api/posts/1/comments \
  -H "Content-Type: application/json" \
  -d '{"authorId":1,"content":"첫 댓글","parentId":null}'

# 2) 대댓글 등록 (방금 생성된 댓글 id가 10 이라고 가정)
curl -X POST http://localhost:8080/api/posts/1/comments \
  -H "Content-Type: application/json" \
  -d '{"authorId":2,"content":"대댓글","parentId":10}'

# 3) 목록 조회 (스레드 최신 우선)
curl "http://localhost:8080/api/posts/1/comments?page=1&size=20"

# 4) 수정
curl -X PUT http://localhost:8080/api/comments/10 \
  -H "Content-Type: application/json" \
  -d '{"content":"수정된 댓글"}'

# 5) 삭제(소프트 삭제)
curl -X DELETE http://localhost:8080/api/comments/10
```

---

# 9) 이해 포인트

* **Adjacency List + thread\_id**

  * 최상위 댓글은 `id == thread_id`가 되도록 두 단계(INSERT → thread\_id 갱신)로 처리
  * 대댓글은 `parent_id`로 부모를 가리키고, 트리 소속은 `thread_id`로 구분
* **정렬 전략(일반적 UX)**

  * 최신 스레드가 위로 오게 `ORDER BY thread_id DESC`
  * 스레드 내부는 작성 순서대로 `id ASC`
* **소프트 삭제**

  * 트리의 구조를 무너뜨리지 않기 위해 `is_deleted=1` + 내용 치환
  * 복구/감사 로그, 신고 처리 등 운영 상 이점
* **인덱스**

  * `(post_id, thread_id, created_at)`로 목록/정렬 최적화
  * `parent_id`로 자식 유무 검사/대댓글 탐색 최적화

---

여기까지가 15-1 **댓글 API(대댓글/정렬)** 구현의 전체 과정입니다.
원하시면 15-2 **Swagger/OpenAPI 문서화**로 이어가겠습니다. 다음 단계로 진행할까요, 아니면 위 코드 중 보완·설명이 더 필요한 부분이 있을까요?
