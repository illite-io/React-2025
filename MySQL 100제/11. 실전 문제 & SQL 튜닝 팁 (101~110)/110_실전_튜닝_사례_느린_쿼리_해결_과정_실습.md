좋습니다.
**110번 – 실전 튜닝 사례: 느린 쿼리 해결 과정 실습** 예제를 설명드리겠습니다.

---

## ✅ 110. 실전 튜닝 사례: 느린 쿼리 해결 과정 실습

### 📌 시나리오

* 테이블: **Orders** (100만 건), **Customers** (10만 건)
* 요구사항: "GOLD 등급 고객의 최근 주문 10건을 날짜순으로 가져오기"
* 기존 쿼리가 **5초 이상 소요**됨

---

### 📄 1단계: 기존 쿼리

```sql
SELECT o.*
FROM Orders o
JOIN Customers c ON o.고객ID = c.고객ID
WHERE c.고객등급 = 'GOLD'
ORDER BY o.주문일자 DESC
LIMIT 10;
```

* `EXPLAIN` 결과:

  * `type=ALL` (Full Table Scan 발생)
  * Orders 전체를 읽은 뒤 정렬 → 비효율

---

### 📄 2단계: 조건 테이블 축소

```sql
-- 고객등급에 인덱스 생성
CREATE INDEX idx_customer_grade ON Customers(고객등급);

SELECT o.*
FROM Orders o
JOIN (
    SELECT 고객ID
    FROM Customers
    WHERE 고객등급 = 'GOLD'
) c ON o.고객ID = c.고객ID
ORDER BY o.주문일자 DESC
LIMIT 10;
```

* GOLD 고객만 먼저 추출 → JOIN 대상 데이터 감소

---

### 📄 3단계: ORDER BY 최적화

```sql
-- 주문일자 + 고객ID 복합 인덱스 생성
CREATE INDEX idx_order_date_customer ON Orders(주문일자 DESC, 고객ID);

SELECT o.*
FROM Orders o
JOIN (
    SELECT 고객ID
    FROM Customers
    WHERE 고객등급 = 'GOLD'
) c ON o.고객ID = c.고객ID
ORDER BY o.주문일자 DESC
LIMIT 10;
```

* ORDER BY에 맞는 복합 인덱스로 정렬 비용 제거

---

### 📄 4단계: 실행 계획 재확인

```sql
EXPLAIN
SELECT o.*
FROM Orders o
JOIN (
    SELECT 고객ID
    FROM Customers
    WHERE 고객등급 = 'GOLD'
) c ON o.고객ID = c.고객ID
ORDER BY o.주문일자 DESC
LIMIT 10;
```

* `type=ref`로 변경
* `Using index` 또는 `Using where; Using index` 확인 가능

---

### 📄 성능 개선 결과

| 단계           | 실행 시간 |
| ------------ | ----- |
| 기존           | 5.2초  |
| 인덱스 + 조건 최적화 | 0.35초 |

---

### 🧠 실무 팁

1. 느린 쿼리는 **EXPLAIN → 조건 축소 → 인덱스 최적화** 순서로 튜닝
2. ORDER BY와 WHERE 조건을 모두 만족하는 **복합 인덱스** 활용
3. LIMIT가 있는 경우 **정렬 인덱스**로 성능 극대화
4. 불필요한 컬럼 조회 지양 (`SELECT *` 대신 필요한 컬럼 지정)

---

이렇게 하면 **MySQL 시작하기 예시 110제**의 모든 항목을 완성했습니다.
원하시면 제가 지금까지 만든 **110제 전체를 md 파일 110개**로 나눠 드릴 수도 있습니다.
바로 생성해 드릴까요?
