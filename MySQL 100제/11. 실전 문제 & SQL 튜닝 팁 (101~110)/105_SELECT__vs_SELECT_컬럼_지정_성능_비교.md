좋습니다.
**105번 – SELECT \* vs SELECT 컬럼 지정 성능 비교** 예제를 설명드리겠습니다.

---

## ✅ 105. SELECT \* vs SELECT 컬럼 지정 성능 비교

### 📌 개념

* `SELECT *`는 모든 컬럼을 가져오기 때문에 **불필요한 데이터**까지 읽음
* 필요한 컬럼만 지정하면 **디스크 I/O와 네트워크 전송량 감소**
* 특히 대용량 테이블에서 성능 차이가 큼

---

### 📄 예시 1: SELECT \*

```sql
EXPLAIN
SELECT * 
FROM Orders
WHERE 고객ID = 'C01';
```

* 모든 컬럼 읽기 → 불필요한 데이터까지 로드
* 네트워크로 전송되는 데이터 크기도 증가

---

### 📄 예시 2: 컬럼 지정

```sql
EXPLAIN
SELECT 주문ID, 주문일자
FROM Orders
WHERE 고객ID = 'C01';
```

* 필요한 컬럼만 읽음 → 성능과 전송 속도 향상

---

### 📄 성능 차이 예시

* 테이블: Orders (1,000,000행, 20개 컬럼)
* `SELECT *` : 0.85초
* `SELECT 주문ID, 주문일자` : 0.25초
  (서버 환경과 인덱스 구성에 따라 차이 있음)

---

### 📄 예시 3: 인덱스 커버링 쿼리

```sql
-- 인덱스가 걸린 컬럼만 조회하면 테이블 읽기 없이 인덱스에서 바로 가져올 수 있음
CREATE INDEX idx_customer_order ON Orders(고객ID, 주문ID, 주문일자);

EXPLAIN
SELECT 주문ID, 주문일자
FROM Orders
WHERE 고객ID = 'C01';
```

* `Extra`에 `Using index`가 뜨면 **커버링 인덱스**로 처리됨 → 매우 빠름

---

### 🧠 실무 팁

1. `SELECT *`는 개발·디버깅 용도로만 사용, 운영에서는 컬럼 지정
2. 빈번히 사용하는 조회 패턴에 맞춰 **커버링 인덱스** 설계
3. 불필요한 컬럼 전송은 네트워크 부하와 메모리 사용량 증가로 이어짐

---

다음은 **106번 – LIMIT OFFSET 쿼리 성능 최적화** 예제로 넘어갑니다.
계속하시려면 `.` 을 입력해주세요.
