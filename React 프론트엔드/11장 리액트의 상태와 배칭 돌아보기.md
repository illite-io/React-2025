좋습니다. 이제 **11장 리액트의 상태와 배칭**을 정리해드리겠습니다.

---

# 11장. 리액트의 상태와 배칭 돌아보기

## 11.1 왜 상태와 배칭을 돌아봐야 하나

* 리액트는 UI를 \*\*상태(state)\*\*에 기반해 렌더링합니다.
* 상태 관리와 **배칭(batching)** 최적화 동작을 이해해야 불필요한 리렌더링을 줄이고 성능을 높일 수 있습니다.

---

## 11.2 리액트의 상태 정의와 종류

### 11.2.1 지역 상태(Local State)와 파생 상태(Derived State)

* **지역 상태**: 컴포넌트 내부에서만 사용하는 값.
* **파생 상태**: props나 다른 상태를 가공해 만든 값 → 별도 상태로 두지 말고 계산하는 것이 원칙.

```jsx
function Price({ amount, taxRate }) {
  const tax = amount * taxRate; // 파생 상태
  return <p>총액: {amount + tax}</p>;
}
```

---

### 11.2.2 상태와 스냅샷

* `useState` 값은 **렌더 시점의 스냅샷**.
* 비동기 안에서 참조하면 **예상과 다를 수 있음** → 함수형 업데이트 필요.

```jsx
const [count, setCount] = useState(0);

// 잘못된 예 (옛 값 캡처)
setTimeout(() => setCount(count + 1), 1000);

// 올바른 예 (함수형 업데이트)
setTimeout(() => setCount(c => c + 1), 1000);
```

---

### 11.2.3 상태의 불변성

* 상태는 직접 수정하지 않고 **새 객체/배열 생성**해야 함.

```jsx
// ❌ 잘못된 예
state.items.push("새 항목");

// ✅ 올바른 예
setItems([...items, "새 항목"]);
```

---

### 11.2.4 상태 끌어올리기 (Lifting State Up)

* 여러 컴포넌트가 공유해야 하는 상태는 **공통 부모로 끌어올려** 관리.

```jsx
function Parent() {
  const [value, setValue] = useState("");

  return (
    <>
      <Input value={value} setValue={setValue} />
      <Display value={value} />
    </>
  );
}
```

---

## 11.3 컴포넌트 간 데이터 흐름

### 11.3.1 단방향 데이터 흐름

* 부모 → 자식 전달. React의 기본 원칙.

### 11.3.2 양방향 데이터 흐름

* 보통 `value` + `onChange` 조합으로 흉내냄.

```jsx
function Input({ value, onChange }) {
  return <input value={value} onChange={e => onChange(e.target.value)} />;
}
```

---

## 11.4 리액트 배칭 돌아보기

### 11.4.1 배칭의 개념과 필요성

* 여러 `setState` 호출을 **한 번의 렌더링으로 묶음**.
* 성능 최적화를 위해 React 18부터는 **기본적으로 모든 이벤트 핸들러/비동기에서 배칭**.

---

### 11.4.2 비동기 동작에서의 배칭

```jsx
function App() {
  const [n, setN] = useState(0);

  const handleClick = () => {
    setTimeout(() => {
      // React 18 이전: 각각 리렌더
      // React 18 이후: 자동 배칭 → 한 번만 리렌더
      setN(n => n + 1);
      setN(n => n + 1);
    }, 1000);
  };

  return (
    <>
      <p>{n}</p>
      <button onClick={handleClick}>+2</button>
    </>
  );
}
```

---

### 11.4.3 flushSync()

* 배칭을 깨고 **즉시 렌더링**이 필요할 때 사용.

```jsx
import { flushSync } from "react-dom";

function App() {
  const [count, setCount] = useState(0);

  const handleClick = () => {
    flushSync(() => setCount(c => c + 1)); // 즉시 반영
    console.log("즉시 DOM 업데이트 후 count:", count + 1);
  };

  return <button onClick={handleClick}>{count}</button>;
}
```

---

### 예시 코드

**/11-state-batching/App.jsx**

```jsx
import React, { useState } from "react";
import { flushSync } from "react-dom";

export default function App() {
  const [count, setCount] = useState(0);

  const addTwo = () => {
    // 배칭 → 한 번의 리렌더
    setCount(c => c + 1);
    setCount(c => c + 1);
  };

  const addSync = () => {
    // flushSync → 첫 번째 업데이트 즉시 반영
    flushSync(() => setCount(c => c + 1));
    flushSync(() => setCount(c => c + 1));
  };

  return (
    <div>
      <h1>상태와 배칭</h1>
      <p>현재 값: {count}</p>
      <button onClick={addTwo}>+2 (배칭)</button>
      <button onClick={addSync}>+2 (즉시 반영)</button>
    </div>
  );
}
```

---

**핵심 키워드 리마인드**
지역 상태 / 파생 상태 / 스냅샷 / 불변성 / 상태 끌어올리기 / 단방향 흐름 / 배칭 / flushSync

---

넥스트스탭님, 이제 마지막 **12장 리액트 파이버 아키텍처**까지 정리해드릴까요?
