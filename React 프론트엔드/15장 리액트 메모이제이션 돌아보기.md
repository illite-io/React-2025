좋습니다. 이제 **15장 리액트 메모이제이션 돌아보기**를 정리해드리겠습니다.

---

# 15장. 리액트 메모이제이션 돌아보기

## 15.1 왜 메모이제이션을 돌아봐야 하나

* 리액트는 **상태나 props 변경 시 함수형 컴포넌트를 다시 실행**합니다.
* 불필요한 리렌더링은 성능 저하를 유발할 수 있습니다.
* \*\*메모이제이션(memoization)\*\*은 계산 결과나 컴포넌트를 캐싱해 재사용하는 방식으로, 성능 최적화를 돕습니다.

---

## 15.2 memo( )를 사용한 렌더링 최적화

### 15.2.1 기본 사용법

```jsx
import React, { memo } from "react";

const Child = memo(({ value }) => {
  console.log("Child 렌더링");
  return <p>{value}</p>;
});

export default function App() {
  const [count, setCount] = React.useState(0);
  return (
    <div>
      <Child value="고정 값" />
      <button onClick={() => setCount(c => c + 1)}>+1</button>
      <p>{count}</p>
    </div>
  );
}
```

* `Child`는 props가 변하지 않으므로 리렌더링되지 않음.

### 15.2.2 성급한 최적화의 함정

* 모든 컴포넌트에 `memo`를 쓰면 비교 비용이 더 커져 성능이 떨어질 수 있음.

### 15.2.3 children 프롭스의 함정

* `props.children`은 렌더마다 새로 생성되므로 memo가 무효화될 수 있음.
* 해결책: `useMemo`로 children을 고정하거나 별도 컴포넌트 분리.

---

## 15.3 useMemo( ) : 값 메모이제이션

### 15.3.1 내부 동작

* `useMemo(fn, deps)` → deps가 변하지 않으면 `fn` 결과를 캐싱.

### 15.3.2 연산 최적화 예제

```jsx
const expensive = (n) => {
  console.log("무거운 연산 실행");
  return Array(n).fill(0).reduce(a => a + 1, 0);
};

function App() {
  const [count, setCount] = React.useState(0);
  const [n, setN] = React.useState(1000);

  const result = React.useMemo(() => expensive(n), [n]);

  return (
    <div>
      <p>계산 결과: {result}</p>
      <button onClick={() => setCount(c => c + 1)}>+1</button>
      <button onClick={() => setN(n + 1000)}>N 증가</button>
    </div>
  );
}
```

---

## 15.4 useCallback( ) : 함수 메모이제이션

### 15.4.1 커스텀 훅에 안정적 콜백 전달

```jsx
function useInterval(callback, delay) {
  React.useEffect(() => {
    const id = setInterval(callback, delay);
    return () => clearInterval(id);
  }, [callback, delay]);
}
```

* `callback`이 매번 새로 생성되면 타이머가 매번 초기화됨 → `useCallback` 필요.

### 15.4.2 props 메모이제이션

```jsx
const Child = React.memo(({ onClick }) => {
  console.log("Child 렌더링");
  return <button onClick={onClick}>클릭</button>;
});

function App() {
  const [count, setCount] = React.useState(0);
  const handleClick = React.useCallback(() => console.log("clicked"), []);
  return <Child onClick={handleClick} />;
}
```

### 15.4.3 디바운스 구현

```jsx
function useDebounce(fn, delay) {
  return React.useCallback(() => {
    const id = setTimeout(fn, delay);
    return () => clearTimeout(id);
  }, [fn, delay]);
}
```

---

## 15.5 리액트 컴파일러를 이용한 자동 메모이제이션

### 15.5.1 수동 메모이제이션의 한계

* `memo`, `useMemo`, `useCallback`은 **개발자가 직접 지정**해야 함 → 실수 가능.

### 15.5.2 컴파일러 개발 역사

* Facebook 팀은 자동 최적화를 위해 **React Compiler**(2024 공개)를 개발.

### 15.5.3 역할과 기능

* 코드 변환 시점에 props/state 변경 추적 → 불필요한 리렌더링 방지.

### 15.5.4 원리

* 코드 정적 분석 → 자동으로 `memo`/`useMemo` 삽입.
* 개발자가 수동 최적화하지 않아도 됨.

### 15.5.5 수동 메모이제이션 대체 가능?

* 단순 케이스는 대체 가능, 복잡한 커스텀 훅/외부 상태는 여전히 개발자 최적화 필요.

### 15.5.6 사용해보기

* 현재는 실험적 단계, 일부 빌드 도구에서 플러그인 제공 예정.

---

## 예시 코드 (15장 통합)

**/15-memoization/App.jsx**

```jsx
import React, { useState, memo, useMemo, useCallback } from "react";

const Child = memo(({ onClick }) => {
  console.log("Child 렌더링");
  return <button onClick={onClick}>자식 버튼</button>;
});

export default function App() {
  const [count, setCount] = useState(0);
  const [n, setN] = useState(1000);

  // useMemo로 값 캐싱
  const result = useMemo(() => {
    console.log("무거운 계산 실행");
    return Array(n).fill(0).reduce(a => a + 1, 0);
  }, [n]);

  // useCallback으로 함수 캐싱
  const handleClick = useCallback(() => console.log("자식 클릭"), []);

  return (
    <div>
      <h1>메모이제이션</h1>
      <p>카운트: {count}</p>
      <p>계산 결과: {result}</p>
      <button onClick={() => setCount(c => c + 1)}>+1</button>
      <button onClick={() => setN(n + 1000)}>N 증가</button>

      {/* memo + useCallback 조합 */}
      <Child onClick={handleClick} />
    </div>
  );
}
```

---

**핵심 키워드 리마인드**

* memo: 컴포넌트 메모이제이션
* useMemo: 값 메모이제이션
* useCallback: 함수 메모이제이션
* 성급한 최적화의 함정
* React Compiler: 자동 메모이제이션

---

넥스트스탭님, 이어서 \*\*16장 (컨텍스트, 에러 바운더리, 서스펜스)\*\*로 넘어가 정리해드릴까요?
