

# 01장. 프론트엔드 구성 요소와 발전 과정 돌아보기

## 1.1 왜 돌아봐야 하나

* 프론트엔드는 **문서(Web 1.0)** → **웹앱(Web 2.0)** → \*\*대규모 프론트엔드(현대)\*\*로 진화하면서, **모듈/번들러/패키지 매니저/템플릿 엔진/선언형 UI** 등이 생겼습니다.
* 역사를 알면 기술 선택의 **맥락과 트레이드오프**를 이해해 불필요한 복잡도를 피할 수 있습니다.

## 1.2 위상과 구성 요소

* 구성: **언어(HTML/CSS/JS)**, **런타임(브라우저, Node.js)**, **도구(npm/yarn/pnpm, Vite/Rsbuild, ESLint/Prettier)**, **프레임워크(React/Vue/Svelte)**, **상태/라우팅/테스트** 등.

## 1.3 초창기 웹 프론트엔드

* 서버가 HTML을 완성해 내려주고, JS는 양념(폼 검증) 정도.

### 예시: 전통적 폼 제출

**/01-legacy-form/index.html**

```html
<!doctype html>
<html>
  <body>
    <form action="/submit" method="POST">
      <input name="email" required />
      <button>제출</button>
    </form>
  </body>
</html>
```

## 1.4 모듈의 탄생과 한계

* 과거 IIFE/AMD/CommonJS를 거쳐 **ES Modules(ESM)** 표준화.
* 브라우저 네이티브 ESM은 좋지만 **네트워크 요청 수**가 늘어 대규모 앱에서 느릴 수 있어 **번들러**가 필요했습니다.

### 예시: 브라우저 ESM

**/01-esm/index.html**

```html
<!doctype html>
<html>
  <body>
    <script type="module">
      import { add } from './math.js';
      console.log(add(2, 3));
    </script>
  </body>
</html>
```

**/01-esm/math.js**

```js
export const add = (a, b) => a + b;
```

## 1.5 번들러의 탄생

* 수백/수천 개 모듈을 **하나 혹은 몇 개 번들**로 묶어 초기 로드를 최적화.
* 요즘은 **Vite, Rsbuild**처럼 빌드와 \*\*개발 서버(ESBuild/Rspack)\*\*를 분리해 DX 향상.

## 1.6 패키지 매니저의 도입

* **npm/yarn/pnpm**: 의존성 관리, 스크립트 실행, 워크스페이스(모노레포) 지원.

### 예시: 스크립트 실행

**/package.json**

```json
{
  "name": "demo",
  "private": true,
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "format": "prettier -w ."
  }
}
```

## 1.7 템플릿 엔진의 도입

* 서버 사이드에서 HTML 생성(Pug, EJS 등). CSR/SSR/하이브리드와 함께 여전히 유효.

### 예시: EJS

**/01-ejs/server.js**

```js
import express from 'express';
import ejs from 'ejs';
const app = express();
app.set('view engine', 'ejs');

app.get('/', (req, res) => res.render('index', { name: '넥스트스탭' }));
app.listen(3000);
```

**/01-ejs/views/index.ejs**

```ejs
<h1>안녕하세요 <%= name %>님</h1>
```

## 1.8 명령형 vs 선언형

* **명령형**: DOM 변경 절차를 직접 기술.
* **선언형**: “상태 → UI” 매핑을 선언(React 등).

### 1.8.1 명령형 예시

**/01-imperative/index.html**

```html
<button id="inc">+1</button>
<p id="count">0</p>
<script>
  let count = 0;
  const $count = document.getElementById('count');
  document.getElementById('inc').addEventListener('click', () => {
    count += 1;
    $count.textContent = String(count); // DOM을 직접 갱신
  });
</script>
</html>
```

### 1.8.2 선언형(React) 예시

**/01-declarative/main.jsx**

```jsx
import { createRoot } from 'react-dom/client';
import { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0); // 상태를 선언
  return (
    <>
      <button onClick={() => setCount(c => c + 1)}>+1</button>
      <p>{count}</p> {/* 상태 → UI 매핑 */}
    </>
  );
}
createRoot(document.getElementById('app')).render(<Counter />);
```

**핵심 키워드 리마인드**
모듈/번들러/패키지 매니저/템플릿 엔진/명령형 vs 선언형/ESM

---