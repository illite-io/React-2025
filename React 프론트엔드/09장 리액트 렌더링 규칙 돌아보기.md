좋습니다. 이제 **09장 리액트 렌더링 규칙**을 정리해드리겠습니다.

---

# 09장. 리액트 렌더링 규칙 돌아보기

## 9.1 왜 렌더링 규칙을 돌아봐야 하나

* 리액트는 **상태와 props 변화**에 따라 컴포넌트를 다시 실행합니다.
* 렌더링 규칙을 이해해야 **불필요한 리렌더링을 방지**하고 성능을 최적화할 수 있습니다.

---

## 9.2 렌더링 조건

### 9.2.1 애플리케이션이 처음 로드될 때

* 루트 컴포넌트가 최초로 실행 → 초기 렌더.

### 9.2.2 컴포넌트 내부 상태(state) 변경

* `useState` setter가 호출되면 해당 컴포넌트와 자식이 리렌더링.

### 9.2.3 부모 컴포넌트 리렌더링

* 부모가 리렌더되면 자식도 기본적으로 리렌더링.
* 단, 자식이 `React.memo`로 감싸져 있으면 props 변경 없는 경우 리렌더링 방지.

### 9.2.4 컨텍스트 값 변경

* `useContext`를 사용하는 컴포넌트는 컨텍스트 값 변경 시 리렌더링.

---

## 9.3 리렌더링에 대한 오해

### 9.3.1 자식 컴포넌트와 props.children

* 부모가 리렌더링되면 `props.children`도 새로 생성됨.
* 따라서 memoized 자식도 불필요하게 다시 렌더될 수 있음.

### 9.3.2 프롭스가 "변경되지 않았다"?

* 객체/배열/함수는 참조가 매번 새로 생성되므로 "같은 값처럼 보여도" props가 변경된 것으로 인식됨.

---

## 9.4 리액트 렌더링 규칙

### 9.4.1 부수 효과 제거와 멱등성 보장

* 리액트는 컴포넌트를 여러 번 호출할 수 있음(StrictMode에서 특히).
* 따라서 **렌더링 과정은 순수 함수처럼 동작**해야 하고, DOM 조작 같은 부수 효과는 `useEffect`에 넣어야 함.

### 9.4.2 JSX로 전달된 값의 불변성 유지

* props/state는 **불변성 유지**가 기본.
* 직접 수정하지 않고 새로운 객체/배열을 만들어 전달해야 함.

---

### 예시 코드

**/09-render-rules/App.jsx**

```jsx
import React, { useState, memo, createContext, useContext } from "react";

const ThemeContext = createContext("light");

const Child = memo(({ user }) => {
  console.log("Child 렌더링");
  return <p>사용자: {user.name}</p>;
});

function ThemeDisplay() {
  const theme = useContext(ThemeContext);
  console.log("ThemeDisplay 렌더링");
  return <p>현재 테마: {theme}</p>;
}

export default function App() {
  const [count, setCount] = useState(0);
  const [theme, setTheme] = useState("light");

  const user = { name: "넥스트스탭" }; // 매번 새 객체 생성됨

  return (
    <ThemeContext.Provider value={theme}>
      <h1>리액트 렌더링 규칙</h1>
      <button onClick={() => setCount(count + 1)}>카운트 +1</button>
      <button onClick={() => setTheme(theme === "light" ? "dark" : "light")}>
        테마 변경
      </button>
      <p>카운트: {count}</p>

      {/* props가 매번 새로운 객체 → memo 무효화 */}
      <Child user={user} />

      <ThemeDisplay />
    </ThemeContext.Provider>
  );
}
```

---

### 개선 코드 (불필요한 리렌더링 방지)

```jsx
const user = useMemo(() => ({ name: "넥스트스탭" }), []);
<Child user={user} />;
```

* `useMemo`로 참조를 고정하면 `Child`가 props 변경 없이 재사용됨.

---

**핵심 키워드 리마인드**
최초 렌더 / 상태 변경 / 부모 리렌더 / 컨텍스트 변경 / props 불변성 / memo / useMemo / 멱등성 / 부수 효과 제거

---

넥스트스탭님, 이어서 **10장 리액트의 프롭스와 컴포넌트 패턴**으로 넘어갈까요, 아니면 지금 09장을 더 코드 예시로 확장해서 보강해드릴까요?
