좋습니다. \[PART 3]의 **14장 리액트 필수 훅 돌아보기**를 정리해드리겠습니다.
구성은 → **개념 설명 → 주의사항 → 코드 예시**로 하겠습니다.

---

# 14장. 리액트 필수 훅 돌아보기

## 14.1 왜 필수 훅을 돌아봐야 하나

* 리액트를 쓸 때 가장 많이 사용하는 훅은 \*\*`useState`, `useEffect`, `useRef`, `useReducer`\*\*입니다.
* 이 훅들은 **상태 관리, 외부 세계와 동기화, DOM 접근, 복잡한 상태 로직**을 가능하게 하므로 “리액트의 기초 체력”입니다.

---

## 14.2 useState( ) : 상태 관리의 시작

### 14.2.1 상태 초기화와 지연 초기화

```jsx
// 일반 초기화
const [count, setCount] = useState(0);

// 지연 초기화: 무거운 계산을 함수로 전달하면 최초 1회만 실행
const [value, setValue] = useState(() => expensiveCalculation());
```

### 14.2.2 상태 업데이트와 업데이트 함수

```jsx
setCount(count + 1);     // 현재 값을 기반으로 갱신
setCount(c => c + 1);    // 함수형 업데이트 (안전)
```

### 14.2.3 업데이트 함수와 클로저

* 비동기 로직 안에서 옛 상태값을 캡처하면 **의도와 다르게 동작**할 수 있음.
* 항상 **함수형 업데이트**를 권장.

---

## 14.3 useEffect( ) : 외부 세계와 동기화

### 14.3.1 기본 사용법과 의존성 배열

```jsx
useEffect(() => {
  console.log("렌더링 후 실행");
}, [count]); // count가 바뀔 때만 실행
```

### 14.3.2 클린업 함수

```jsx
useEffect(() => {
  const id = setInterval(() => console.log("tick"), 1000);
  return () => clearInterval(id); // 언마운트 시 정리
}, []);
```

### 14.3.3 외부 시스템과 동기화

* API 호출, 이벤트 리스너, 타이머 등은 모두 **부수 효과**.

### 14.3.4 엄격 모드에서의 실행

* React 18의 StrictMode에서는 **의도적으로 2번 실행**됨 → 부수 효과의 순수성 검증용.

---

## 14.4 useRef( ) : 렌더링을 넘어 값을 기억

### 14.4.1 리렌더링을 발생시키지 않는 값 저장

```jsx
const ref = useRef(0);
ref.current += 1; // 변경해도 컴포넌트 리렌더링 없음
```

### 14.4.2 DOM 요소 접근

```jsx
const inputRef = useRef();
useEffect(() => {
  inputRef.current.focus();
}, []);
return <input ref={inputRef} />;
```

### 14.4.3 forwardRef( ) : 부모가 자식의 DOM에 접근

```jsx
const MyInput = React.forwardRef((props, ref) => (
  <input {...props} ref={ref} />
));

function App() {
  const ref = useRef();
  return (
    <>
      <MyInput ref={ref} />
      <button onClick={() => ref.current.focus()}>포커스</button>
    </>
  );
}
```

### 14.4.4 리액트 19의 forwardRef

* 기본적으로 **props + ref 객체 구조 분리**가 개선 예정 (React 19 preview).

---

## 14.5 useReducer( )와 리액트 포탈

### 14.5.1 useReducer( )

* 복잡한 상태 로직을 `reducer` 함수로 관리.
* Redux-lite 같은 구조.

```jsx
function reducer(state, action) {
  switch (action.type) {
    case "inc": return { count: state.count + 1 };
    case "dec": return { count: state.count - 1 };
    default: return state;
  }
}

const [state, dispatch] = useReducer(reducer, { count: 0 });
```

---

### 14.5.2 createPortal( )

* 부모 DOM 구조와 무관하게, 특정 DOM 노드에 컴포넌트를 렌더링.
* 모달/툴팁 구현에 필수.

```jsx
import { createPortal } from "react-dom";

function Modal({ children }) {
  return createPortal(
    <div className="modal">{children}</div>,
    document.getElementById("portal-root")
  );
}
```

---

## 예시 코드 (14장 통합)

**/14-essential-hooks/App.jsx**

```jsx
import React, { useState, useEffect, useRef, useReducer, forwardRef } from "react";
import { createPortal } from "react-dom";

// useReducer 예시
function reducer(state, action) {
  switch (action.type) {
    case "inc": return { count: state.count + 1 };
    case "dec": return { count: state.count - 1 };
    default: return state;
  }
}

const MyInput = forwardRef((props, ref) => <input {...props} ref={ref} />);

export default function App() {
  const [count, setCount] = useState(0);
  const [state, dispatch] = useReducer(reducer, { count: 0 });
  const inputRef = useRef();

  useEffect(() => {
    console.log("카운트가 바뀜:", count);
  }, [count]);

  return (
    <div>
      <h1>리액트 필수 훅</h1>

      {/* useState */}
      <p>useState 카운트: {count}</p>
      <button onClick={() => setCount(c => c + 1)}>+1</button>

      {/* useEffect + useRef */}
      <MyInput ref={inputRef} placeholder="포커스 테스트" />
      <button onClick={() => inputRef.current.focus()}>포커스 주기</button>

      {/* useReducer */}
      <p>useReducer 카운트: {state.count}</p>
      <button onClick={() => dispatch({ type: "inc" })}>+1</button>
      <button onClick={() => dispatch({ type: "dec" })}>-1</button>

      {/* Portal */}
      {createPortal(<div style={{ color: "red" }}>포털 모달!</div>, document.body)}
    </div>
  );
}
```

---

**핵심 키워드 리마인드**

* useState: 상태 초기화, 함수형 업데이트, 클로저 문제
* useEffect: 의존성 배열, 클린업, 외부 동기화, StrictMode
* useRef: 값 유지, DOM 접근, forwardRef
* useReducer: 복잡한 상태 로직 관리
* createPortal: 트리 바깥 렌더링

---

넥스트스탭님, 이어서 \*\*15장 리액트 메모이제이션 (memo, useMemo, useCallback, React Compiler)\*\*로 정리해드릴까요?
