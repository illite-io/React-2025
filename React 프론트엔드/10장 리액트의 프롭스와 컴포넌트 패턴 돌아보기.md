좋습니다. 이어서 **10장 리액트의 프롭스와 컴포넌트 패턴**을 정리해드리겠습니다.

---

# 10장. 리액트의 프롭스와 컴포넌트 패턴 돌아보기

## 10.1 왜 프롭스와 패턴을 돌아봐야 하나

* \*\*프롭스(props)\*\*는 리액트 컴포넌트의 “입력값”입니다.
* 상태(state)와 달리 **부모 → 자식으로 단방향 전달**되며, UI를 조합하고 재사용하는 핵심입니다.
* 다양한 **컴포넌트 패턴**을 이해하면 복잡한 UI도 **유연하게 설계**할 수 있습니다.

---

## 10.2 리액트의 프롭스와 상태 개념

### 10.2.1 프롭스와 상태

* **프롭스(props)**: 외부에서 주어지는 값 (읽기 전용).
* **상태(state)**: 컴포넌트 내부에서 관리하는 값 (변경 가능).

### 10.2.2 프롭스의 불변성

```jsx
function Profile({ name }) {
  // name = "다른 값"; ❌ props 직접 수정 불가
  return <h2>{name}</h2>;
}
```

### 10.2.3 프롭스와 HTML 속성의 차이

* HTML 속성은 문자열 기반.
* 프롭스는 JS 표현식을 받을 수 있음.

```jsx
<input type="text" />   {/* HTML 속성 */}
<Profile name="넥스트스탭" /> {/* 리액트 프롭스 */}
```

---

## 10.3 프롭스 자료형 검증

### 10.3.1 prop-types (런타임 검증)

```jsx
import PropTypes from "prop-types";

function Profile({ name, age }) {
  return <p>{name} ({age})</p>;
}

Profile.propTypes = {
  name: PropTypes.string.isRequired,
  age: PropTypes.number,
};
```

### 10.3.2 타입스크립트 (컴파일 타임 검증)

```tsx
type ProfileProps = { name: string; age?: number };

function Profile({ name, age }: ProfileProps) {
  return <p>{name} ({age})</p>;
}
```

---

## 10.4 프롭스를 사용하는 컴포넌트 패턴

### 10.4.1 합성과 상속, HOC

* 리액트는 \*\*합성(Composition)\*\*을 권장.
* HOC(고차 컴포넌트)는 함수처럼 컴포넌트를 감싸 기능 확장.

```jsx
// HOC 예시
function withLogger(Component) {
  return function Wrapped(props) {
    console.log("props:", props);
    return <Component {...props} />;
  };
}
```

---

### 10.4.2 중첩 컴포넌트와 children, 프롭스 드릴링

```jsx
function Card({ children }) {
  return <div className="card">{children}</div>;
}

<Card>
  <h3>제목</h3>
  <p>내용</p>
</Card>
```

* children은 중첩된 JSX를 전달하는 프롭스.
* 프롭스 드릴링 문제: 깊은 자식까지 계속 전달해야 하는 불편 → Context나 상태 관리 도구로 해결.

---

### 10.4.3 렌더 프롭스 패턴

```jsx
function List({ items, render }) {
  return <ul>{items.map((it, i) => <li key={i}>{render(it)}</li>)}</ul>;
}

<List items={["A", "B"]} render={(it) => <strong>{it}</strong>} />
```

* `render` 프롭스를 함수로 전달 → 유연한 UI 조합 가능.

---

### 10.4.4 슬롯 프롭스 패턴

* 여러 개의 `children`을 명시적으로 받는 방식.

```jsx
function Layout({ header, content, footer }) {
  return (
    <div>
      <div>{header}</div>
      <main>{content}</main>
      <div>{footer}</div>
    </div>
  );
}

<Layout
  header={<h1>헤더</h1>}
  content={<p>본문</p>}
  footer={<p>푸터</p>}
/>
```

---

### 10.4.5 컴파운드 컴포넌트 패턴

* 부모/자식 컴포넌트를 묶어 일관된 API 제공.

```jsx
function Tabs({ children }) {
  return <div className="tabs">{children}</div>;
}
Tabs.Tab = function ({ children }) {
  return <button>{children}</button>;
};

<Tabs>
  <Tabs.Tab>탭1</Tabs.Tab>
  <Tabs.Tab>탭2</Tabs.Tab>
</Tabs>
```

---

### 10.4.6 명시적 슬롯 패턴 (slot type RFC)

* 실험적 패턴: 자식 컴포넌트에 `slot` 속성을 두어 위치 지정.

```jsx
<Tabs>
  <div slot="tab">탭1</div>
  <div slot="content">내용1</div>
</Tabs>
```

---

### 예시 코드

**/10-props-patterns/App.jsx**

```jsx
import React from "react";

function Card({ children }) {
  return <div style={{ border: "1px solid #aaa", padding: "10px" }}>{children}</div>;
}

function List({ items, render }) {
  return <ul>{items.map((it, i) => <li key={i}>{render(it)}</li>)}</ul>;
}

export default function App() {
  return (
    <div>
      <h1>프롭스와 패턴</h1>

      {/* children 패턴 */}
      <Card>
        <h2>Card 제목</h2>
        <p>Card 내용</p>
      </Card>

      {/* 렌더 프롭스 패턴 */}
      <List items={["사과", "바나나"]} render={(it) => <strong>{it}</strong>} />
    </div>
  );
}
```

---

**핵심 키워드 리마인드**
프롭스/상태 차이 / 불변성 / prop-types / TS 인터페이스 / children / 프롭스 드릴링 / 렌더 프롭스 / 컴파운드 컴포넌트

---

넥스트스탭님, 다음은 **11장 리액트의 상태와 배칭**으로 넘어가 정리해드릴까요?
