좋습니다. 이제 마지막 **17장 리액트 동시성 기능과 심화 훅 돌아보기**를 정리해드리겠습니다.

---

# 17장. 리액트 동시성 기능과 심화 훅 돌아보기

## 17.1 왜 이 장을 돌아봐야 하나

* 리액트 18 이후 **동시성(Concurrent Rendering)** 개념이 도입되었습니다.
* 이를 활용하면 무거운 연산/네트워크 작업 중에도 **UI 응답성을 매끄럽게 유지**할 수 있습니다.
* 이 장에서는 기존 훅(`useLayoutEffect`, `useImperativeHandle`)뿐 아니라 **트랜지션 관련 훅**(`useTransition`, `useDeferredValue`, `startTransition`), 외부 상태 동기화 훅(`useSyncExternalStore`)까지 다룹니다.

---

## 17.2 useLayoutEffect( )와 useInsertionEffect( )

### 17.2.1 useEffect vs useLayoutEffect

* `useEffect`: **렌더 → 화면 반영 후** 실행 (비동기적).
* `useLayoutEffect`: **렌더 → DOM 업데이트 직후** 동기 실행.
  → 레이아웃 측정, DOM 조작 필요 시 사용.

```jsx
function Box() {
  const ref = React.useRef();
  React.useLayoutEffect(() => {
    console.log("크기:", ref.current.getBoundingClientRect());
  }, []);
  return <div ref={ref} style={{ width: 100, height: 50, background: "skyblue" }} />;
}
```

### 17.2.2 useInsertionEffect

* 스타일 삽입 시점 제어 (CSS-in-JS 라이브러리용).
* 일반 개발자가 직접 쓸 일은 드묾.

### 17.2.3 React 19 메타 데이터 & 스타일시트

* React 19에선 메타데이터/스타일시트 관리 개선 예정 → useInsertionEffect 활용 가능성↑.

---

## 17.3 useImperativeHandle( )

* 부모가 자식 DOM/메서드에 접근할 수 있게 “제어 역전(Inversion of Control)” 제공.
* `forwardRef`와 함께 사용.

```jsx
const MyInput = React.forwardRef((props, ref) => {
  const inputRef = React.useRef();
  React.useImperativeHandle(ref, () => ({
    focus: () => inputRef.current.focus()
  }));
  return <input ref={inputRef} {...props} />;
});

function App() {
  const ref = React.useRef();
  return (
    <>
      <MyInput ref={ref} />
      <button onClick={() => ref.current.focus()}>포커스!</button>
    </>
  );
}
```

---

## 17.4 동시성 기능과 트랜지션

### 17.4.1 useTransition

* 우선순위 낮은 작업을 “트랜지션”으로 표시 → 사용자 입력(고우선 작업) 먼저 처리.

```jsx
function Search() {
  const [query, setQuery] = React.useState("");
  const [results, setResults] = React.useState([]);
  const [isPending, startTransition] = React.useTransition();

  const handleChange = (e) => {
    const value = e.target.value;
    setQuery(value);
    startTransition(() => {
      // 무거운 작업: 낮은 우선순위
      const filtered = bigList.filter(item => item.includes(value));
      setResults(filtered);
    });
  };

  return (
    <>
      <input value={query} onChange={handleChange} />
      {isPending && <p>검색 중...</p>}
      <ul>{results.map(r => <li key={r}>{r}</li>)}</ul>
    </>
  );
}
```

### 17.4.2 useDeferredValue

* 특정 상태를 “지연된 버전”으로 사용.
* UI가 버벅이지 않고 빠른 응답 유지.

```jsx
function Search({ query }) {
  const deferredQuery = React.useDeferredValue(query);
  const results = bigList.filter(item => item.includes(deferredQuery));
  return <ul>{results.map(r => <li key={r}>{r}</li>)}</ul>;
}
```

### 17.4.3 startTransition

* 함수 호출부에서 트랜지션 명시.
* 입력 핸들러, API 응답 처리 시 활용.

---

## 17.5 useSyncExternalStore( )

### 17.5.1 내부 상태 vs 외부 상태

* 내부 상태: useState/useReducer로 관리.
* 외부 상태: Redux, Zustand 등 전역 상태 관리 라이브러리.

### 17.5.2 외부 상태 동기화

* `useSyncExternalStore`는 외부 상태와 리액트 컴포넌트를 **안전하게 연결**.
* React 18에 도입, Concurrent Rendering 환경에서 외부 스토어 일관성 보장.

```jsx
import { useSyncExternalStore } from "react";

const store = {
  value: 0,
  listeners: new Set(),
  subscribe(cb) { this.listeners.add(cb); return () => this.listeners.delete(cb); },
  set(v) { this.value = v; this.listeners.forEach(cb => cb()); },
  get() { return this.value; }
};

function Counter() {
  const value = useSyncExternalStore(
    (cb) => store.subscribe(cb),
    () => store.get()
  );
  return (
    <>
      <p>스토어 값: {value}</p>
      <button onClick={() => store.set(value + 1)}>+1</button>
    </>
  );
}
```

---

## 예시 코드 (17장 통합)

**/17-advanced-hooks/App.jsx**

```jsx
import React, {
  useRef, useLayoutEffect, useImperativeHandle,
  forwardRef, useState, useTransition, useDeferredValue
} from "react";

// forwardRef + useImperativeHandle
const MyInput = forwardRef((props, ref) => {
  const inputRef = useRef();
  useImperativeHandle(ref, () => ({
    focus: () => inputRef.current.focus()
  }));
  return <input ref={inputRef} {...props} />;
});

export default function App() {
  const [count, setCount] = useState(0);
  const ref = useRef();

  // useLayoutEffect
  useLayoutEffect(() => {
    console.log("버튼 위치:", ref.current.getBoundingClientRect());
  }, []);

  // useTransition + useDeferredValue
  const [query, setQuery] = useState("");
  const [isPending, startTransition] = useTransition();
  const deferredQuery = useDeferredValue(query);

  const results = Array(10000).fill(0).map((_, i) => "item " + i)
    .filter(item => item.includes(deferredQuery));

  return (
    <div ref={ref}>
      <h1>심화 훅과 동시성</h1>
      <p>카운트: {count}</p>
      <button onClick={() => setCount(c => c + 1)}>+1</button>

      <MyInput placeholder="포커스 테스트" ref={ref} />

      <input value={query} onChange={(e) => {
        const value = e.target.value;
        startTransition(() => setQuery(value));
      }} />

      {isPending && <p>검색 중...</p>}
      <ul>{results.slice(0, 10).map(r => <li key={r}>{r}</li>)}</ul>
    </div>
  );
}
```

---

**핵심 키워드 리마인드**

* useLayoutEffect: DOM 측정/조작 시 동기 실행
* useInsertionEffect: 스타일 삽입용 훅
* useImperativeHandle: 부모가 자식 DOM/메서드 제어
* useTransition / startTransition: 우선순위 낮은 작업 분리
* useDeferredValue: 지연된 값 사용
* useSyncExternalStore: 외부 상태 안전 동기화

---

넥스트스탭님, 이렇게 해서 **\[PART 3] 훅 사용법 깊게 돌아보기 (13\~17장)** 전체를 정리했습니다.
이제 이어서 **\[PART 4] 리액트 성능 최적화**로 넘어가 드릴까요, 아니면 지금까지 내용을 요약 정리(마인드맵/도표 스타일)로 먼저 정리해드릴까요?
