좋습니다. 이제 마지막 **12장 리액트의 뿌리, 파이버(Fiber) 아키텍처**를 정리해드리겠습니다.

---

# 12장. 리액트를 구성하는 뿌리, 파이버 돌아보기

## 12.1 왜 파이버를 돌아봐야 하나

* 리액트는 16 버전부터 **Fiber 아키텍처**를 도입했습니다.
* 기존의 “스택 재조정자(Stack Reconciler)”는 **동기적 재귀 호출** 기반이라, 컴포넌트 트리가 크면 브라우저 UI 스레드를 오래 점유했습니다.
* Fiber는 이를 해결하기 위해 **작업을 쪼개고 우선순위를 관리**하는 새로운 구조를 도입했습니다.

---

## 12.2 스택 재조정자 알아보기

### 12.2.1 스택 재조정자의 동작

* 컴포넌트 트리를 \*\*깊이 우선 탐색(DFS)\*\*으로 순회하면서 재귀적으로 업데이트.
* 작업 중간에 멈출 수 없어, 긴 작업은 브라우저 응답성을 떨어뜨렸음.

### 12.2.2 스택 재조정자의 한계

* 중단 불가, 우선순위 고려 불가 → 애니메이션/입력 지연 발생.

---

## 12.3 파이버 아키텍처

### 12.3.1 파이버 노드 해부하기

* 각 컴포넌트마다 **Fiber 객체** 생성.
* 주요 속성:

  * `type`: 컴포넌트 타입 (함수, 클래스, DOM 태그)
  * `pendingProps`: 새 props
  * `memoizedProps`: 이전 props (비교용)
  * `child`, `sibling`, `return`: 트리 구조를 위한 링크
  * `alternate`: 현재 트리와 작업 중인 트리의 짝

### 12.3.2 파이버 우선순위와 Lanes 모델

* 작업을 “Lane” 단위로 나누어 **우선순위 기반 처리**.
* 예: 사용자 입력 > 네트워크 데이터 > 렌더링 최적화

### 12.3.3 파이버 트리 구조 (재귀 없는 순회)

* 파이버는 `child`, `sibling`, `return` 포인터를 이용해 **링크드 리스트 형태**로 구현.
* 이를 통해 재귀 대신 반복문으로 순회 → 작업 중단 가능.

### 12.3.4 더블 버퍼링과 alternate 포인터

* 리액트는 \*\*현재 트리(current tree)\*\*와 **작업 중인 트리(work-in-progress tree)** 두 개를 유지.
* 작업 완료 시 교체 → UI가 일관되게 유지됨.

### 12.3.5 동시성 기능 원리

* Fiber는 작업을 잘게 쪼개서 **requestIdleCallback / Scheduler**와 통합.
* React 18의 Concurrent Mode는 이를 활용해 사용자 입력이 오면 **중단하고 먼저 처리** 가능.

---

## 시각적 비유

* **스택 재조정자**: 한 번에 책을 전부 읽어야 하는 방식 (중간에 멈출 수 없음).
* **Fiber**: 책을 읽다가 잠시 멈추고, 중요한 전화가 오면 먼저 받을 수 있는 방식.

---

## 예시 코드 (Fiber를 직접 볼 수는 없지만 원리를 시뮬레이션)

**/12-fiber-simulate/fiber.js**

```js
// 간단한 Fiber 구조 시뮬레이션
class FiberNode {
  constructor(type, props) {
    this.type = type;
    this.props = props;
    this.child = null;
    this.sibling = null;
    this.return = null;
  }
}

// 트리 순회 (재귀 대신 반복문)
function workLoop(root) {
  let nextUnit = root;
  while (nextUnit) {
    console.log("작업 중:", nextUnit.type);
    // 자식 우선
    if (nextUnit.child) {
      nextUnit = nextUnit.child;
      continue;
    }
    // 형제
    while (nextUnit) {
      if (nextUnit.sibling) {
        nextUnit = nextUnit.sibling;
        break;
      }
      nextUnit = nextUnit.return;
    }
  }
}

// 트리 만들기
const root = new FiberNode("App", {});
const child1 = new FiberNode("Header", {});
const child2 = new FiberNode("Content", {});
const child3 = new FiberNode("Footer", {});

root.child = child1;
child1.return = root;
child1.sibling = child2;
child2.return = root;
child2.sibling = child3;
child3.return = root;

workLoop(root);
```

출력:

```
작업 중: App
작업 중: Header
작업 중: Content
작업 중: Footer
```

→ 실제 리액트 Fiber는 이런 식으로 트리를 “포인터 기반 순회”하면서 작업을 분할합니다.

---

**핵심 키워드 리마인드**
스택 재조정자 / 한계 / Fiber 노드 / child-sibling-return / alternate / 더블 버퍼링 / Lanes / 동시성 / Concurrent Mode

---

넥스트스탭님, 이렇게 해서 **\[PART 2] 리액트 핵심 요소 깊게 돌아보기 (06\~12장)** 전체를 설명 + 예시 코드까지 정리해드렸습니다.
혹시 이 내용을 \*\*한눈에 보이는 요약(마인드맵 스타일 정리)\*\*으로 정리해드릴까요, 아니면 PART 3로 바로 넘어가길 원하시나요?
