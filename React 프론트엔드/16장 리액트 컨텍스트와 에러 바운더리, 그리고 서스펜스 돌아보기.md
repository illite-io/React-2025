좋습니다. 이제 **16장 리액트 컨텍스트와 에러 바운더리, 그리고 서스펜스 돌아보기**를 정리해드리겠습니다.

---

# 16장. 리액트 컨텍스트와 에러 바운더리, 그리고 서스펜스 돌아보기

## 16.1 왜 이 장을 돌아봐야 하나

* **컨텍스트(Context)**: 프롭스 드릴링 없이 전역적으로 상태를 공유.
* **에러 바운더리(Error Boundary)**: UI 오류를 잡아 앱이 흰 화면으로 죽는 걸 방지.
* **서스펜스(Suspense)**: 비동기 로딩 중인 컴포넌트 상태를 우아하게 처리.
  → 이 세 가지는 **안정성, 확장성, 사용자 경험**을 위해 반드시 알아야 함.

---

## 16.2 에러 바운더리

### 16.2.1 클래스 기반 구현

```jsx
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }
  static getDerivedStateFromError(error) {
    return { hasError: true };
  }
  componentDidCatch(error, info) {
    console.error("에러 발생:", error, info);
  }
  render() {
    if (this.state.hasError) {
      return <h2>문제가 발생했습니다.</h2>;
    }
    return this.props.children;
  }
}
```

### 16.2.2 에러 전파

* 하위 트리에서 발생한 렌더링 에러를 잡음.
* 단, **이벤트 핸들러 에러는 잡지 못함** (try/catch 필요).

### 16.2.3 작동 조건

* 렌더링, 라이프사이클, 자식의 constructor 에러만 처리.

---

## 16.3 컨텍스트 API로 상태 공유

### 16.3.1 프롭스 드릴링

```jsx
function Child({ user }) {
  return <p>{user.name}</p>;
}
function Parent({ user }) {
  return <Child user={user} />;
}
```

→ 깊이 중첩되면 모든 중간 컴포넌트에 props 전달 필요.

### 16.3.2 컨텍스트 생성

```jsx
const UserContext = React.createContext(null);

function App() {
  const [user] = React.useState({ name: "넥스트스탭" });
  return (
    <UserContext.Provider value={user}>
      <Profile />
    </UserContext.Provider>
  );
}

function Profile() {
  const user = React.useContext(UserContext);
  return <p>사용자: {user.name}</p>;
}
```

---

## 16.4 컨텍스트 API의 유스케이스

* 전역 테마 (light/dark)
* 인증된 사용자 정보
* i18n(다국어)

---

## 16.5 컨텍스트와 리렌더링 문제

### 16.5.1 value 프롭스 메모이제이션

```jsx
// ❌ 잘못된 예: 매 렌더마다 새 객체
<UserContext.Provider value={{ name: "넥스트스탭" }}>

// ✅ useMemo 사용
const userValue = useMemo(() => ({ name: "넥스트스탭" }), []);
<UserContext.Provider value={userValue}>
```

### 16.5.2 컨텍스트 분리

* theme / auth 같은 값은 별도 Context로 나눠 리렌더링 범위 최소화.

### 16.5.3 셀렉터 패턴

* use-context-selector 라이브러리로 원하는 값만 구독.

### 16.5.4 HOC + memo 활용

* Context 소비 컴포넌트를 memo로 감싸 최적화 가능.

---

## 16.6 서스펜스

### 16.6.1 역사

* React.lazy → 코드 스플리팅.
* Suspense → 비동기 컴포넌트 로딩 처리.

### 16.6.2 에러 바운더리와 서스펜스

* Suspense는 **비동기 로딩** 처리.
* ErrorBoundary는 **실패 상황** 처리.
* 둘을 함께 써야 UX가 안전해짐.

### 16.6.3 내부 원리

* 컴포넌트가 Promise를 throw → Suspense가 잡아 fallback 렌더링.

```jsx
const LazyComp = React.lazy(() => import("./Comp"));

function App() {
  return (
    <React.Suspense fallback={<p>로딩 중...</p>}>
      <LazyComp />
    </React.Suspense>
  );
}
```

---

## 16.7 use( ) 훅 (React 18+ 실험적, 19에서 정식 예정)

### 16.7.1 컨텍스트값 읽기

```jsx
const theme = use(ThemeContext); // useContext 대체
```

### 16.7.2 프로미스 읽기

```jsx
const data = use(fetchData()); // Promise를 직접 풀어줌
```

### 16.7.3 조건문 안에서 호출 가능

* `use()`는 기존 훅 규칙 예외. React가 내부적으로 트래킹.

---

## 예시 코드 (16장 통합)

**/16-context-error-suspense/App.jsx**

```jsx
import React, { useState, useContext, createContext, Suspense } from "react";

// ErrorBoundary
class ErrorBoundary extends React.Component {
  state = { hasError: false };
  static getDerivedStateFromError() {
    return { hasError: true };
  }
  render() {
    return this.state.hasError ? <h2>에러 발생!</h2> : this.props.children;
  }
}

// Context
const UserContext = createContext(null);

function Profile() {
  const user = useContext(UserContext);
  if (!user) throw new Error("사용자 없음");
  return <p>사용자: {user.name}</p>;
}

// Suspense (lazy)
const LazyComp = React.lazy(() => import("./LazyComp"));

export default function App() {
  const [user] = useState({ name: "넥스트스탭" });

  return (
    <ErrorBoundary>
      <UserContext.Provider value={user}>
        <Suspense fallback={<p>로딩중...</p>}>
          <Profile />
          <LazyComp />
        </Suspense>
      </UserContext.Provider>
    </ErrorBoundary>
  );
}
```

---

**핵심 키워드 리마인드**

* ErrorBoundary: 클래스 컴포넌트 기반, UI 보호막
* Context: 전역 상태 공유, props drilling 해결
* Context 최적화: value 메모이제이션, 분리, 셀렉터 패턴
* Suspense: 로딩 상태 처리, Promise throw 기반
* use(): Context/Promise를 직접 읽는 새로운 훅

---

넥스트스탭님, 다음은 \*\*17장 리액트 동시성 기능과 심화 훅 (useLayoutEffect, useTransition, useDeferredValue 등)\*\*으로 정리해드릴까요?
