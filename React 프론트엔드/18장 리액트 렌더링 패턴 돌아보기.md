좋습니다. 이제 **\[PART 4] 리액트를 둘러싸는 기술과 미래** 중 **18장 리액트 렌더링 패턴**을 먼저 정리해드리겠습니다.

---

# 18장. 리액트 렌더링 패턴 돌아보기

## 18.1 왜 렌더링 패턴을 돌아봐야 하나

* 리액트 앱은 **클라이언트 사이드 렌더링(CSR)** → **서버 사이드 렌더링(SSR)** → **정적 사이트 생성(SSG)** → \*\*서버 컴포넌트(RSC)\*\*로 진화해 왔습니다.
* 각 패턴은 **성능, SEO, 사용자 경험**에 서로 다른 트레이드오프를 가집니다.

---

## 18.2 클라이언트 사이드 렌더링 vs SSR

### 18.2.1 클라이언트 사이드 렌더링(CSR)

* 초기엔 **빈 HTML + JS 번들**만 내려주고, 브라우저가 JS 실행 후 DOM 구성.
* 장점: 빠른 개발, 상태 관리 단순.
* 단점: 첫 로딩 느림(SEO 취약).

```html
<div id="root"></div>
<script src="/bundle.js"></script>
```

---

### 18.2.2 서버 사이드 렌더링(SSR)

* 서버에서 HTML을 만들어 보내고, 클라이언트가 \*\*hydrate(수화)\*\*하여 상호작용 가능하게 만듦.
* 장점: 초기 화면 빠름, SEO 강화.
* 단점: 서버 부하↑, 복잡성↑.

---

### 18.2.3 SSR의 동형성(Hydration)

* 서버에서 `<button>클릭</button>` 렌더링 → 브라우저에서 동일한 트리를 React가 연결(hydration).
* HTML과 클라이언트 렌더가 불일치하면 **hydration mismatch warning** 발생.

---

### 18.2.4 번들 크기 분석 (Next.js 예시)

* `next.config.js`에서 `analyze: true`로 번들 분석 가능.
* 큰 라이브러리는 동적 import로 분리해야 초기 로딩 성능↑.

---

## 18.3 SSR을 위한 리액트 API

### 18.3.1 renderToString()

```js
import { renderToString } from "react-dom/server";
const html = renderToString(<App />);
```

* 전체 HTML 문자열 생성.

### 18.3.2 renderToNodeStream()

* Node.js 스트림 기반 SSR. 초기 HTML을 빠르게 전달.

### 18.3.3 renderToPipeableStream() (React 18)

* 최신 스트리밍 렌더링 API.
* **Suspense와 통합**되어 데이터 도착 시점에 따라 부분 렌더링 가능.

```js
import { renderToPipeableStream } from "react-dom/server";

app.get("/", (req, res) => {
  const { pipe } = renderToPipeableStream(<App />, {
    onShellReady() { pipe(res); }
  });
});
```

---

## 18.4 정적 사이트 생성(SSG) & ISR

### 18.4.1 Next.js 정적 사이트 생성

```js
export async function getStaticProps() {
  return { props: { posts: await getPosts() } };
}
```

### 18.4.2 ISR (Incremental Static Regeneration)

* 빌드 후 특정 페이지를 **주기적으로 다시 생성**.
* 정적 페이지 + 최신 데이터 동시 보장.

```js
export async function getStaticProps() {
  return {
    props: { posts: await getPosts() },
    revalidate: 60, // 60초마다 페이지 갱신
  };
}
```

---

## 18.5 리액트 서버 컴포넌트(RSC)

### 18.5.1 개념과 특징

* 서버에서 렌더링되는 컴포넌트 → 번들 크기 줄고, 보안↑.
* DB 쿼리, 비즈니스 로직을 직접 포함 가능.

### 18.5.2 클라이언트 컴포넌트

* 브라우저 상호작용이 필요한 UI는 여전히 **클라이언트 컴포넌트** 필요.
* `useState`, `useEffect` 같은 훅은 **클라이언트 컴포넌트에서만 사용**.

```jsx
// 서버 컴포넌트
export default async function Page() {
  const data = await fetchData();
  return <div>{data.title}</div>;
}
```

```jsx
// 클라이언트 컴포넌트
"use client";
import { useState } from "react";
export default function Counter() {
  const [n, setN] = useState(0);
  return <button onClick={() => setN(n + 1)}>{n}</button>;
}
```

### 18.5.3 서버 컴포넌트 규칙

* 서버 훅(`use server`)과 클라이언트 훅은 분리.
* 서버 컴포넌트는 직렬화 가능한 데이터만 props로 전달.

---

## 예시 코드 (18장 종합)

**/18-rendering-patterns/server.js**

```js
import express from "express";
import { renderToPipeableStream } from "react-dom/server";
import App from "./App.js";

const app = express();
app.get("/", (req, res) => {
  const { pipe } = renderToPipeableStream(<App />, {
    onShellReady() {
      res.setHeader("content-type", "text/html");
      pipe(res);
    }
  });
});
app.listen(3000);
```

---

**핵심 키워드 리마인드**

* CSR: 초기 느림, SEO 취약
* SSR: 초기 빠름, hydration 필요
* renderToPipeableStream: React 18 스트리밍 SSR
* SSG & ISR: 정적 빌드 + 주기적 재생성
* RSC(Server Components): 서버 전용, 번들 크기↓, 보안↑
* 클라이언트 컴포넌트: 상호작용 담당

---

넥스트스탭님, 이어서 **19장 Next.js 앱 라우터와 서버 액션**으로 정리해드릴까요, 아니면 18장의 SSR/RSC 부분을 더 깊게 코드 실습 중심으로 풀어드릴까요?
