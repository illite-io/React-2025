
# 02장. 싱글 페이지 애플리케이션(SPA) 돌아보기

## 2.1 왜 SPA를 돌아봐야 하나

* 사용자 기대치(빠른 인터랙션) 상승, **클라이언트 상태** 관리 필요.

## 2.2 네트워크 호출 빈도

* SPA는 **라우팅/부분 갱신**으로 전체 HTML 재다운로드를 줄임.

### 예시: MPA vs SPA 데이터 갱신

**MPA**: 페이지 전환마다 HTML 재요청.
**SPA**: fetch로 JSON만 받아 부분 갱신.

**/02-spa/app.js**

```js
async function loadUsers() {
  const res = await fetch('/api/users');
  const users = await res.json();
  document.getElementById('list').innerHTML =
    users.map(u => `<li>${u.name}</li>`).join('');
}
document.getElementById('reload').addEventListener('click', loadUsers);
loadUsers();
```

## 2.3 성능 향상

* 최초 로드는 번들이 커질 수 있어 **코드 스플리팅, 지연 로딩**이 중요.

### 예시: React 지연 로딩

**/02-spa-split/App.jsx**

```jsx
import { Suspense, lazy } from 'react';
const Admin = lazy(() => import('./Admin.jsx')); // 필요할 때만 로드

export default function App() {
  return (
    <Suspense fallback={<p>로딩...</p>}>
      <Admin />
    </Suspense>
  );
}
```

## 2.4 생산성 향상

* **프론트/백엔드 분리**로 병렬 작업, **선언형 UI**로 빠른 프로토타이핑.

### 2.4.1 FE/BE 분리 개발 서버 프록시

**/02-vite-proxy/vite.config.js**

```js
export default {
  server: {
    proxy: {
      '/api': 'http://localhost:4000' // 백엔드로 프록시
    }
  }
};
```

### 2.4.2 선언형 프로토타입

**/02-proto/Todo.jsx**

```jsx
import { useState } from 'react';
export default function Todo() {
  const [items, setItems] = useState([]);
  const add = e => {
    e.preventDefault();
    const v = new FormData(e.currentTarget).get('t');
    if (v) setItems(prev => [...prev, v]);
    e.currentTarget.reset();
  };
  return (
    <form onSubmit={add}>
      <input name="t" placeholder="할 일" />
      <button>추가</button>
      <ul>{items.map((v, i) => <li key={i}>{v}</li>)}</ul>
    </form>
  );
}
```

**핵심 키워드 리마인드**
부분 갱신/fetch/코드 스플리팅/지연 로딩/프록시/병렬 개발

---