좋습니다. 이제 **\[PART 3] 리액트 훅 사용법 깊게 돌아보기**의 첫 장인 **13장 리액트 훅의 사용 규칙**을 설명과 예시 코드로 정리해드리겠습니다.

---

# 13장. 리액트 훅의 사용 규칙 돌아보기

## 13.1 당신이 리액트 훅을 돌아봐야 하는 이유

* 훅(Hook)은 함수형 컴포넌트에서 **상태(state), 생명주기, 컨텍스트** 등을 다룰 수 있게 해줍니다.
* 클래스 컴포넌트의 한계를 극복하고 **로직 재사용**을 쉽게 만들어줍니다.
* 하지만 규칙을 지키지 않으면 **예상치 못한 버그**가 발생할 수 있습니다.

---

## 13.2 왜 “훅(Hook)”이라고 부를까?

* 훅은 리액트 내부의 상태 관리/렌더링 로직에 **“걸어(hook into)” 들어가는 메커니즘**.
* 예: `useState`는 리액트의 상태 관리 시스템에 “걸려” 있어, 컴포넌트 렌더링과 함께 동작.

---

## 13.3 클래스 컴포넌트에서 함수형 컴포넌트로

### 13.3.1 this 키워드의 혼란

* 클래스 컴포넌트에서는 `this` 바인딩 문제로 코드가 복잡해짐.

```jsx
class Counter extends React.Component {
  state = { count: 0 };
  // 수동으로 this 바인딩 필요
  increment = this.increment.bind(this);

  increment() {
    this.setState({ count: this.state.count + 1 });
  }

  render() {
    return <button onClick={this.increment}>{this.state.count}</button>;
  }
}
```

### 13.3.2 고차 컴포넌트(HOC)와 래퍼 지옥

* 클래스 시절에는 로직 재사용을 위해 HOC를 과도하게 중첩 → 가독성 저하.

```jsx
const withAuth = (Comp) => (props) => <Comp {...props} />;
const withTheme = (Comp) => (props) => <Comp {...props} />;
const Enhanced = withAuth(withTheme(MyComponent)); // 래퍼 지옥
```

### 13.3.3 커스텀 훅으로 로직 재사용

* 훅을 통해 **함수 추상화**로 재사용 가능.

```jsx
function useCounter(initial = 0) {
  const [count, setCount] = React.useState(initial);
  const increment = () => setCount((c) => c + 1);
  return { count, increment };
}

function Counter() {
  const { count, increment } = useCounter();
  return <button onClick={increment}>{count}</button>;
}
```

---

## 13.4 리액트 훅 사용 규칙

### 13.4.1 훅은 최상위에서만 호출해야 한다

* 조건문/반복문/중첩 함수 안에서 호출 금지.
* 호출 순서가 매 렌더링마다 동일해야 함.

```jsx
// ❌ 잘못된 예
if (loggedIn) {
  const [user, setUser] = useState(null);
}
```

```jsx
// ✅ 올바른 예
const [user, setUser] = useState(null);
if (loggedIn) {
  // 로직 분기만
}
```

---

### 13.4.2 오직 리액트 함수 내에서만 훅 호출

* 훅은 **리액트 함수형 컴포넌트 또는 커스텀 훅**에서만 호출 가능.

```jsx
// ❌ 일반 함수에서 호출 금지
function fetchData() {
  const [data, setData] = useState(null); // 에러
}
```

```jsx
// ✅ 커스텀 훅으로 작성
function useFetch(url) {
  const [data, setData] = useState(null);
  React.useEffect(() => {
    fetch(url).then((res) => res.json()).then(setData);
  }, [url]);
  return data;
}
```

---

### 13.4.3 훅의 인수는 불변성을 유지해야 한다

* 의존성 배열(dependency array)에서 참조가 매번 바뀌면 **불필요한 리렌더링/효과 실행** 발생.

```jsx
// ❌ 매번 새로운 함수 → useEffect 매 렌더마다 실행
useEffect(() => {
  console.log("불필요하게 실행됨");
}, [() => doSomething()]);
```

```jsx
// ✅ useCallback으로 참조 고정
const stableFn = useCallback(() => doSomething(), []);
useEffect(() => {
  console.log("필요할 때만 실행됨");
}, [stableFn]);
```

---

### 예시 코드

**/13-hooks-rules/App.jsx**

```jsx
import React, { useState, useEffect, useCallback } from "react";

// 커스텀 훅
function useCounter(initial = 0) {
  const [count, setCount] = useState(initial);
  const increment = () => setCount(c => c + 1);
  return { count, increment };
}

export default function App() {
  const { count, increment } = useCounter();

  // ✅ 훅은 최상위에서만 호출
  const [time, setTime] = useState(new Date());

  // ✅ 불변성 유지: stableCallback 사용
  const stableCallback = useCallback(() => console.log("tick"), []);

  useEffect(() => {
    const id = setInterval(() => {
      setTime(new Date());
      stableCallback();
    }, 1000);
    return () => clearInterval(id);
  }, [stableCallback]);

  return (
    <div>
      <h1>리액트 훅 사용 규칙</h1>
      <p>카운트: {count}</p>
      <button onClick={increment}>+1</button>
      <p>현재 시각: {time.toLocaleTimeString()}</p>
    </div>
  );
}
```

---

**핵심 키워드 리마인드**

* 클래스 컴포넌트의 한계 (this 혼란, HOC 남발)
* 함수형 컴포넌트 + 훅 도입 이유
* 훅 규칙: 최상위에서만 호출 / 리액트 함수 내에서만 호출 / 인수 불변성 유지
* 커스텀 훅을 통한 로직 재사용

---

넥스트스탭님, 이어서 **14장 useState 훅**부터 본격적으로 훅별 학습 가이드로 들어갈까요?
