
# 04장. 상태와 반응성 돌아보기

## 4.1 왜 돌아봐야 하나

* UI는 **상태의 투영**. 상태 변화에 **자동 반응**하는 모델이 생산성과 안정성을 올립니다.

## 4.2 설계 컴포넌트

* **뷰**(표현), **모델**(데이터, 규칙), **중재자**(동기화/흐름).

## 4.3 패턴으로 반응성 구현

### 4.3.1 비반응성 MVC 중재자

**/04-mvc-nonreactive/index.html**

```html
<div>
  <input id="msg" />
  <button id="save">저장</button>
  <p id="view"></p>
</div>
<script>
  const model = { text: '' };
  const $msg = document.getElementById('msg');
  const $view = document.getElementById('view');

  document.getElementById('save').addEventListener('click', () => {
    model.text = $msg.value;
    $view.textContent = model.text; // 변경 시마다 직접 갱신(명령형)
  });
</script>
```

### 4.3.2 관찰자(Observer)로 반응성 주입

**/04-observer/observable.js**

```js
export function observable(obj) {
  const listeners = new Set();
  return {
    get value() { return obj; },
    set(patch) { Object.assign(obj, patch); listeners.forEach(fn => fn(obj)); },
    subscribe(fn) { listeners.add(fn); return () => listeners.delete(fn); }
  };
}
```

**/04-observer/index.html**

```html
<div>
  <input id="msg" />
  <button id="save">저장</button>
  <p id="view"></p>
</div>
<script type="module">
  import { observable } from './observable.js';
  const state = observable({ text: '' });

  // 뷰는 상태를 '구독'하여 자동 갱신
  state.subscribe(s => document.getElementById('view').textContent = s.text);

  document.getElementById('save').onclick = () => {
    state.set({ text: document.getElementById('msg').value });
  };
</script>
```

## 4.4 관찰자 패턴 요점

* 주체(Subject)가 관찰자(Observer) 목록을 가지고 변화 시 알림 → **느슨한 결합**.

## 4.5 MVVM과 반응성

### 4.5.1 양방향/단방향 바인딩

* 양방향: input 값 변경 ↔ 상태 변경이 서로 동기화.
* 단방향: 상태 → UI 단방향 흐름(React가 기본), 입력은 이벤트로 상태 갱신.

### 4.5.2 MVVM 할 일 앱(단방향 바인딩)

**/04-mvvm/TodoModel.js**

```js
export class TodoModel {
  constructor() { this.items = []; this.listeners = new Set(); }
  add(text) { this.items.push({ id: Date.now(), text, done: false }); this.emit(); }
  toggle(id) { const t = this.items.find(i => i.id === id); t.done = !t.done; this.emit(); }
  onChange(fn) { this.listeners.add(fn); return () => this.listeners.delete(fn); }
  emit() { this.listeners.forEach(fn => fn(this.items)); }
}
```

**/04-mvvm/index.html**

```html
<div>
  <form id="f"><input name="t" placeholder="할 일"/><button>추가</button></form>
  <ul id="list"></ul>
</div>
<script type="module">
  import { TodoModel } from './TodoModel.js';
  const model = new TodoModel();
  const $list = document.getElementById('list');

  // ViewModel 역할: 이벤트 → 모델 메서드 호출, 모델 변경 → 뷰 렌더
  model.onChange(render);
  document.getElementById('f').onsubmit = e => {
    e.preventDefault();
    const t = new FormData(e.target).get('t');
    if (t) model.add(t);
    e.target.reset();
  };

  function render(items) {
    $list.innerHTML = items.map(i =>
      `<li>
        <label>
          <input type="checkbox" ${i.done?'checked':''} data-id="${i.id}"/>
          ${i.text}
        </label>
      </li>`
    ).join('');
    $list.querySelectorAll('input[type=checkbox]').forEach($c => {
      $c.onchange = () => model.toggle(Number($c.dataset.id));
    });
  }
  render([]); // 초기 렌더
</script>
```

### 4.5.3/4.5.4 바인더 아이디어

* 입력 요소들의 value/checked와 모델 속성을 매핑해 **양방향 바인딩 헬퍼**를 작성할 수 있습니다.

**/04-binder/bind.js**

```js
export function bindInput(input, obj, key, notify) {
  input.value = obj[key] ?? '';
  input.addEventListener('input', () => { obj[key] = input.value; notify?.(obj); });
  return () => (input.value = obj[key] ?? '');
}
```

**핵심 키워드 리마인드**
MVC/MVVM/Observer/단방향·양방향 바인딩/상태=UI의 원천

---