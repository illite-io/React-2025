좋습니다. 이어서 **08장 리액트 재조정과 키 프롭스**부터 설명과 예시 코드를 정리해드리겠습니다.

---

# 08장. 리액트 재조정과 키 프롭스 돌아보기

## 8.1 왜 렌더링과 가상 DOM을 돌아봐야 하나

* 리액트는 DOM 조작 대신 \*\*가상 DOM(Virtual DOM)\*\*을 사용합니다.
* 변경 사항을 **비교(diffing)** 후 필요한 부분만 실제 DOM에 반영합니다.
* 이 과정이 바로 **재조정(Reconciliation)**.

---

## 8.2 리액트 컴포넌트와 인스턴스

* 함수형 컴포넌트는 호출 시마다 새로운 UI를 반환.
* 리액트 내부는 이를 **Fiber 노드**로 관리하며, 상태와 DOM을 이어줌.

---

## 8.3 렌더링과 리렌더링

* **렌더링(Rendering)**: 컴포넌트 함수가 실행되어 React 엘리먼트를 반환하는 과정.
* **리렌더링(Re-rendering)**: props나 state가 변경될 때 다시 함수 실행.

---

## 8.4 재조정 과정

1. 이전 가상 DOM과 새로운 가상 DOM을 비교(diffing).
2. 동일한 타입이면 속성만 비교/갱신.
3. 타입이 다르면 노드를 제거 후 새로 생성.

---

## 8.5 얕은 비교와 렌더링 최적화

* React.memo, useMemo, useCallback 등을 활용해 **불필요한 리렌더링 방지**.
* 얕은 비교(shallow compare): 객체 참조가 같은지 확인.

---

## 8.6 key 프롭스와 리스트 렌더링

* 리스트 렌더링에서 key는 **요소의 식별자** 역할.
* key가 없거나 index를 key로 쓰면 리렌더링 성능/정합성 문제 발생.

---

## 8.7 key 프롭스와 메모이제이션

* key는 React가 **재사용할지 새로 만들지** 판단하는 기준.
* 안정적인 key를 쓰면 memoization 효과 ↑.

---

### 예시 코드

**/08-reconciliation/App.jsx**

```jsx
import React, { useState } from "react";

function ListItem({ item }) {
  console.log("렌더링:", item.id);
  return <li>{item.text}</li>;
}

export default function App() {
  const [items, setItems] = useState([
    { id: 1, text: "사과" },
    { id: 2, text: "바나나" },
  ]);

  const shuffle = () => {
    // 배열 순서를 뒤집음
    setItems([...items].reverse());
  };

  return (
    <div>
      <h1>재조정과 key</h1>
      <button onClick={shuffle}>순서 바꾸기</button>
      <ul>
        {items.map((it) => (
          // 안정적인 key 사용
          <ListItem key={it.id} item={it} />
        ))}
      </ul>
    </div>
  );
}
```

### 잘못된 예시 (index를 key로 사용)

```jsx
<ul>
  {items.map((it, idx) => (
    <ListItem key={idx} item={it} />
  ))}
</ul>
```

* 순서가 바뀌면 React는 같은 key(index)를 가진 다른 항목을 **같은 컴포넌트**로 인식 → UI 꼬임 발생.

---

**핵심 키워드 리마인드**
재조정 / 가상 DOM / diffing / 얕은 비교 / React.memo / key 프롭스 / 리스트 렌더링

---

넥스트스탭님, 이어서 **09장 리액트 렌더링 규칙**을 정리해드릴까요, 아니면 지금 08장을 조금 더 코드 중심으로 깊게 파고들까요?
