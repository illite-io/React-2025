리액트(React) 프로젝트의 성능 최적화는 사용자 경험(UX) 향상과 애플리케이션 유지보수에 매우 중요합니다. 아래에 **주요 리액트 최적화 기술**들을 **카테고리별로 정리**해 드리겠습니다.

---

## ✅ 렌더링 최적화

| 기술            | 설명                                    |
| ------------- | ------------------------------------- |
| `React.memo`  | 컴포넌트를 메모이제이션하여 props가 바뀌지 않으면 리렌더링 방지 |
| `useMemo`     | 계산 비용이 큰 값을 메모이제이션하여 불필요한 계산 방지       |
| `useCallback` | 함수를 메모이제이션하여 자식 컴포넌트에 불필요한 리렌더링 방지    |
| `key` 설정 최적화  | 리스트 렌더링 시 고유한 key를 설정하여 diff 성능 개선    |

---

## ✅ 상태관리 최적화

| 기술          | 설명                                               |
| ----------- | ------------------------------------------------ |
| 상태 최소화      | 필요한 컴포넌트에만 상태를 두고 불필요한 리렌더링 방지                   |
| 전역 상태 관리 도구 | Context API, Redux, Zustand, Recoil 등을 상황에 맞게 선택 |
| Context 분리  | Context 범위를 좁게 설정하여 리렌더링 범위 최소화                  |

---

## ✅ 코드 분할 & 지연 로딩

| 기술                        | 설명                        |
| ------------------------- | ------------------------- |
| `React.lazy` + `Suspense` | 컴포넌트를 지연 로딩하여 초기 번들 크기 감소 |
| 동적 import                 | 페이지나 라우트 단위로 코드 분할        |
| Webpack splitChunks       | 공통 코드 분리 및 캐시 최적화         |

---

## ✅ DOM 조작 최적화

| 기술                  | 설명                                                               |
| ------------------- | ---------------------------------------------------------------- |
| 가상화(Virtualization) | 긴 리스트 렌더링 시 `react-window`, `react-virtualized`로 화면에 보이는 항목만 렌더링 |
| 불필요한 DOM 제거         | 조건부 렌더링(`&&`, `? :`) 등을 사용해 불필요한 요소 제거                           |
| Skeleton UI         | 느린 네트워크에서 UX 개선                                                  |

---

## ✅ 이벤트 핸들링 최적화

| 기술                      | 설명                             |
| ----------------------- | ------------------------------ |
| `debounce` / `throttle` | 입력 이벤트 핸들링 최적화 (`lodash` 등 사용) |
| 이벤트 위임                  | 다수의 이벤트 리스너를 하나로 통합            |

---

## ✅ 렌더링 도구 및 개발 툴 활용

| 도구             | 설명                     |
| -------------- | ---------------------- |
| React DevTools | 렌더링 확인, props/state 추적 |
| Profiler       | 렌더링 시간 측정 및 병목 지점 확인   |
| Lighthouse     | 성능, 접근성 등 점수 분석        |

---

## ✅ 네트워크/서버 데이터 최적화

| 기술               | 설명                     |
| ---------------- | ---------------------- |
| React Query, SWR | 캐싱, 중복요청 방지, 자동 갱신     |
| prefetching      | 사용자 행동 예측 기반 미리 데이터 요청 |
| skeleton UI      | 데이터 로딩 시 사용자 경험 향상     |

---

## ✅ 기타

| 기술         | 설명                         |
| ---------- | -------------------------- |
| 컴포넌트 분리    | 하나의 큰 컴포넌트보단 작은 단위로 분리     |
| 비동기 작업 최소화 | 의존성이 없는 비동기 요청은 병렬 처리      |
| 이미지 최적화    | WebP, lazy loading, CDN 활용 |

---

### 원하시면 아래 항목 중 하나를 골라 **예제 코드**와 함께 상세히 설명해드릴 수 있어요:

* `React.memo` 사용법
* `useMemo`, `useCallback` 차이
* 리스트 가상화 구현 (`react-window`)
* React Query 기반 데이터 최적화
* Lazy 컴포넌트 로딩 (`React.lazy`)

필요한 항목을 말씀해 주세요.

---

좋습니다. 넥스트스탭님 요청대로 **렌더링 최적화 기술 중 하나씩** 구체적으로, **예제 코드에는 상세 주석**을 달아서 설명드리겠습니다.

---

# ✅ 렌더링 최적화 1: `React.memo`

## 🔸 개념 설명

`React.memo`는 \*\*고차 컴포넌트(HOC)\*\*로, \*\*함수형 컴포넌트를 메모이제이션(memoization)\*\*합니다.
즉, 컴포넌트의 **props가 바뀌지 않는 한 리렌더링을 막아줍니다.**

* 기본적으로 리액트는 상위 컴포넌트가 리렌더링되면 **자식 컴포넌트도 무조건 리렌더링**됩니다.
* 이때 `React.memo`로 감싸주면 **props가 변경되지 않았을 경우** 해당 컴포넌트는 **다시 렌더링되지 않습니다.**

---

## 🔸 사용 예시

```jsx
// 📁 src/components/User.js

import React from "react";

// React.memo로 컴포넌트를 감싸서 props가 변경되지 않으면 리렌더링을 방지
const User = React.memo(({ name }) => {
  console.log("User 컴포넌트 렌더링"); // 렌더링 여부 확인용 로그
  return <div>사용자 이름: {name}</div>;
});

export default User;
```

```jsx
// 📁 src/App.js

import React, { useState } from "react";
import User from "./components/User";

const App = () => {
  const [count, setCount] = useState(0);

  // 이름은 고정된 값으로 전달됨
  const userName = "넥스트스탭";

  return (
    <div>
      <h1>React.memo 예제</h1>
      <User name={userName} />
      {/* 아래 버튼 클릭 시 count는 바뀌지만 User 컴포넌트는 리렌더링되지 않음 */}
      <button onClick={() => setCount(count + 1)}>카운트 증가: {count}</button>
    </div>
  );
};

export default App;
```

---

## 🔸 동작 설명

* `App` 컴포넌트의 상태(count)가 바뀔 때마다 전체가 리렌더링됨
* `User` 컴포넌트는 `React.memo`로 감싸져 있어서 **props(`name`)가 변하지 않으면 리렌더링되지 않음**
* 콘솔 로그에서 `"User 컴포넌트 렌더링"` 메시지가 처음 한 번만 출력됨

---

## 🔸 props가 객체일 경우 (주의점)

```jsx
// 잘못된 예시 (항상 리렌더링됨)
<User info={{ name: "넥스트스탭" }} />
```

* 위와 같이 **객체 리터럴을 직접 전달하면 참조가 항상 새로 생성**되어 리렌더링됩니다.
* 해결 방법:

```jsx
// useMemo로 객체 메모이제이션
const userInfo = useMemo(() => ({ name: "넥스트스탭" }), []);
<User info={userInfo} />
```

---

## 🔸 `React.memo` + 비교 함수 사용 예시

```jsx
const User = React.memo(({ name, age }) => {
  console.log("User 렌더링");
  return <div>{name} - {age}</div>;
}, (prevProps, nextProps) => {
  // props가 모두 동일할 경우에만 리렌더링 방지
  return prevProps.name === nextProps.name && prevProps.age === nextProps.age;
});
```

---

## ✅ 요약

| 항목    | 설명                                                       |
| ----- | -------------------------------------------------------- |
| 목적    | props가 바뀌지 않을 경우 리렌더링 방지                                 |
| 성능 효과 | 불필요한 렌더링 제거, 렌더링 최적화                                     |
| 주의점   | props로 객체/배열을 넘길 땐 `useMemo`, `useCallback`과 함께 사용해야 효과적 |

---

다음 주제로는 `useMemo`를 자세히 다룰까요?
`다음`이라고 입력해 주시면 이어서 설명드리겠습니다.

---

좋습니다. 이번에는 **렌더링 최적화 2: `useMemo`** 에 대해 **구체적이고 자세하게** 설명드리겠습니다.
**예시 코드에는 상세한 주석**도 포함하겠습니다.

---

# ✅ 렌더링 최적화 2: `useMemo`

## 🔸 개념 설명

`useMemo`는 **비용이 많이 드는 연산 결과를 메모이제이션(memoization)** 하기 위해 사용합니다.
즉, **값을 기억해두었다가 의존성 배열이 바뀌지 않으면 재계산하지 않고 기존 값을 재사용**합니다.

> 성능 최적화가 필요한 연산: 정렬, 필터링, 복잡한 계산 등

---

## 🔸 기본 문법

```js
const memoizedValue = useMemo(() => {
  return 계산할_값;
}, [의존성]);
```

---

## 🔸 예시 코드

### 예제: 긴 리스트를 필터링하는 계산을 `useMemo`로 최적화

```jsx
// 📁 src/components/UserList.js

import React, { useState, useMemo } from "react";

// 긴 사용자 리스트 예시 데이터
const users = Array.from({ length: 10000 }, (_, i) => ({
  id: i,
  name: `사용자${i}`,
}));

const UserList = () => {
  const [keyword, setKeyword] = useState("");

  // ✅ 필터링된 리스트를 useMemo로 캐싱
  const filteredUsers = useMemo(() => {
    console.log("🔍 사용자 필터링 실행");

    // 입력한 키워드를 포함한 사용자만 필터링
    return users.filter(user => user.name.includes(keyword));
  }, [keyword]); // keyword가 바뀔 때만 다시 계산됨

  return (
    <div>
      <h2>유저 검색</h2>

      {/* 검색어 입력 필드 */}
      <input
        type="text"
        placeholder="이름 검색"
        value={keyword}
        onChange={(e) => setKeyword(e.target.value)}
      />

      <ul>
        {/* 필터링된 사용자 리스트 렌더링 */}
        {filteredUsers.map(user => (
          <li key={user.id}>{user.name}</li>
        ))}
      </ul>
    </div>
  );
};

export default UserList;
```

---

## 🔸 동작 설명

* `users` 배열은 1만 개의 요소로 구성되어 있어 `filter()`가 무거운 작업임
* 사용자가 검색어를 입력할 때마다 리렌더링되는데,

  * `useMemo`를 사용하지 않으면 **매 렌더링마다 filter() 실행**
  * `useMemo` 사용 시 `keyword`가 바뀔 때만 filter() 수행
* `console.log("🔍 사용자 필터링 실행")`으로 실제 필터링 여부 확인 가능

---

## 🔸 의존성 주의사항

* `useMemo(() => ..., [])`처럼 의존성 배열이 비어 있으면 **초기 한 번만 계산**
* 의존성 배열을 정확히 설정하지 않으면 **이전 값이 계속 유지되거나**, **불필요한 재계산** 발생 가능

---

## ✅ 실제 사용 시 고려할 점

| 항목       | 설명                                         |
| -------- | ------------------------------------------ |
| 언제 사용?   | 연산 비용이 클 때만 사용                             |
| 남용 금지    | 간단한 연산에 `useMemo` 쓰면 오히려 성능 저하 가능          |
| 함수형 vs 값 | `useMemo`는 "값"에 사용, "함수"는 `useCallback` 사용 |

---

다음 주제로는 `useCallback`을 자세히 설명해 드릴까요?
필요하시면 `다음`이라고 입력해 주세요.

---

좋습니다. 이번에는 \*\*렌더링 최적화 3: `useCallback`\*\*에 대해 **구체적으로 설명**하고, **예시 코드에는 상세한 주석**을 달아드리겠습니다.

---

# ✅ 렌더링 최적화 3: `useCallback`

## 🔸 개념 설명

`useCallback`은 **함수를 메모이제이션**하는 Hook입니다.
즉, 특정 함수가 **의존성이 바뀌지 않는 한 재생성되지 않도록** 만들어줍니다.

### 언제 필요한가?

* 함수 자체를 **props로 자식 컴포넌트에 전달할 때**
* 매번 함수가 새로 생성되어 자식이 불필요하게 **리렌더링되는 문제를 방지**할 때

---

## 🔸 기본 문법

```js
const memoizedFn = useCallback(() => {
  // 실행할 함수
}, [의존성]);
```

---

## 🔸 예시 코드

### 예제: 부모에서 자식에게 콜백 함수를 전달할 때 `useCallback`으로 최적화

```jsx
// 📁 src/components/Child.js

import React from "react";

// React.memo로 자식 컴포넌트 최적화
const Child = React.memo(({ onClick }) => {
  console.log("🔄 자식 컴포넌트 렌더링");

  return (
    <button onClick={onClick}>
      자식 컴포넌트 버튼
    </button>
  );
});

export default Child;
```

```jsx
// 📁 src/App.js

import React, { useState, useCallback } from "react";
import Child from "./components/Child";

const App = () => {
  const [count, setCount] = useState(0);

  // ✅ useCallback으로 함수 메모이제이션
  const handleClick = useCallback(() => {
    alert("자식 컴포넌트 버튼 클릭됨");
  }, []); // 의존성이 없으므로 한 번만 생성됨

  return (
    <div>
      <h1>useCallback 예제</h1>
      <p>카운트: {count}</p>
      <button onClick={() => setCount(count + 1)}>카운트 증가</button>

      {/* 자식에게 함수 props 전달 */}
      <Child onClick={handleClick} />
    </div>
  );
};

export default App;
```

---

## 🔸 동작 설명

* `App` 컴포넌트에서 `count` 상태가 바뀔 때마다 리렌더링됨
* `useCallback`을 사용하지 않으면 매번 새로운 `handleClick` 함수가 생성됨 → `Child` 컴포넌트도 리렌더링됨
* `useCallback`을 사용하면 `handleClick` 함수는 재생성되지 않으므로 `Child`는 **리렌더링되지 않음**

> 콘솔에 "🔄 자식 컴포넌트 렌더링" 메시지가 표시되지 않음 → 성공적으로 리렌더링 방지됨

---

## 🔸 `React.memo` + `useCallback` 궁합

| 목적                | 사용 방법         |
| ----------------- | ------------- |
| 자식 컴포넌트 리렌더링 방지   | `React.memo`  |
| 자식에게 넘길 함수 재생성 방지 | `useCallback` |

둘은 **함께 쓰일 때 진짜 최적화 효과**를 발휘합니다.

---

## 🔸 실제 사용 시 고려할 점

| 항목        | 설명                                |
| --------- | --------------------------------- |
| 언제 사용?    | 함수가 자주 재생성되고 자식 컴포넌트에 전달될 때       |
| 불필요한 사용 X | 함수가 재생성되어도 성능 이슈 없으면 굳이 사용 안 해도 됨 |
| 의존성 배열 주의 | 의존성이 바뀌면 새 함수로 갱신됨                |

---

## ✅ 요약

| 항목         | 설명                         |
| ---------- | -------------------------- |
| 목적         | 함수를 메모이제이션해서 자식 리렌더링 방지    |
| 사용 대상      | 이벤트 핸들러, 콜백 등 자식에게 넘기는 함수  |
| 함께 쓰면 좋은 것 | `React.memo` (자식 컴포넌트 최적화) |

---

다음 주제로는 리스트 최적화 기술인 \*\*가상화 (Virtualization)\*\*을 다룰까요?
`react-window`를 예제로 사용해서 설명드릴 수 있습니다.
필요하시면 `다음`이라고 입력해 주세요.

---

맞습니다, 정확하게 짚으셨습니다.
렌더링 최적화 순서상 **다음 주제는 `key` 설정 최적화**입니다.
방금까지 설명드린 `React.memo`, `useMemo`, `useCallback`은 **렌더링 방지 기술**이고,
이제 설명드릴 `key` 설정 최적화는 **리스트 렌더링의 효율을 위한 최적화 기술**입니다.

---

# ✅ 렌더링 최적화 4: `key` 설정 최적화

## 🔸 개념 설명

React에서 리스트를 렌더링할 때 각 항목에 `key` 속성을 부여해야 합니다.
이 `key`는 React의 **Virtual DOM 비교(diffing)** 과정에서 매우 중요한 역할을 합니다.

> `key`는 React가 어떤 항목이 변경되었는지, 추가/삭제되었는지를 빠르게 판단할 수 있도록 도와줍니다.

---

## 🔸 왜 최적화에 중요한가?

잘못된 key 사용 시 다음 문제가 발생합니다:

* 리스트 항목 전체가 **불필요하게 리렌더링**됨
* 내부 상태나 DOM 포커스 등이 **의도치 않게 초기화**됨
* 성능 저하 및 버그 발생

---

## 🔸 ❌ 안 좋은 예시 (index 사용)

```jsx
{items.map((item, index) => (
  <li key={index}>{item.name}</li>
))}
```

* `index`를 key로 쓰면 항목의 순서가 바뀌거나 삭제되었을 때 **정확한 비교 불가**
* 특히 **입력 폼, 애니메이션, 체크박스, 포커스 등**이 포함된 항목에 치명적

---

## 🔸 ✅ 좋은 예시 (고유한 id 사용)

```jsx
{items.map((item) => (
  <li key={item.id}>{item.name}</li>
))}
```

* 각 항목의 고유 식별자인 `id`를 `key`로 사용
* React가 항목을 정확하게 추적하여 필요한 부분만 효율적으로 렌더링함

---

## 🔸 예시 코드

```jsx
// 📁 src/components/ItemList.js

import React, { useState } from "react";

const initialItems = [
  { id: "a1", name: "React" },
  { id: "a2", name: "Vue" },
  { id: "a3", name: "Angular" },
];

const ItemList = () => {
  const [items, setItems] = useState(initialItems);

  const removeFirst = () => {
    // 첫 번째 항목 삭제
    setItems(prev => prev.slice(1));
  };

  return (
    <div>
      <h3>Key 최적화 예시</h3>
      <button onClick={removeFirst}>첫 항목 삭제</button>
      <ul>
        {items.map((item) => (
          // ✅ 고유한 id를 key로 사용
          <li key={item.id}>
            {item.name}
          </li>
        ))}
      </ul>
    </div>
  );
};

export default ItemList;
```

---

## 🔸 `index`를 사용하면 발생하는 문제 예시

* 리스트 중간에서 삭제하면 **이후 항목들이 모두 재렌더링됨**
* 예: `checked`, `focused`, `input value` 등이 예상치 못하게 초기화될 수 있음

---

## ✅ 요약

| 항목   | 설명                                 |
| ---- | ---------------------------------- |
| 역할   | React가 리스트 항목을 정확히 비교하기 위한 고유 식별자  |
| 좋은 예 | `item.id`, UUID, DB 고유키 등          |
| 나쁜 예 | 배열 index, 랜덤 key (`Math.random()`) |

---

다음으로는 **리스트가 길 때** 사용되는 렌더링 최적화 기술인
**가상화(Virtualization)**(`react-window`, `react-virtualized`)로 넘어가겠습니다.

진행하려면 `다음`이라고 입력해 주세요.

---

넥스트스탭님 말씀이 맞습니다. 구조적으로 정확히 짚으셨어요.

---

## 🔄 지금까지 진행한 주제

### ✅ 렌더링 최적화

1. `React.memo`
2. `useMemo`
3. `useCallback`
4. `key` 설정 최적화 ← 방금 완료

---

## ✅ 다음 주제는?

> **렌더링 최적화 범주**는 여기까지고,
> 이제는 **상태관리 최적화**로 넘어갑니다.

---

# ✅ 상태관리 최적화

상태 관리 최적화는 리액트 앱에서 **불필요한 리렌더링을 줄이고**,
**상태의 위치와 범위를 최적화**함으로써 성능을 개선하는 기법입니다.

---

## ✅ 순서대로 다룰 예정인 상태관리 최적화 기술

1. **상태 범위 최소화** – 필요한 컴포넌트에만 상태 두기
2. **전역 상태 관리 도구의 선택** – Context API, Redux, Zustand 등
3. **Context 분리 최적화** – Provider 구조 개선 및 분리 전략

---

시작 주제는 **"상태 범위 최소화"** 입니다.
계속해서 이 내용을 구체적으로 설명드릴까요?

진행하시려면 `다음`이라고 입력해주세요.

---

좋습니다. 상태관리 최적화의 첫 번째 주제인
**✅ 상태 범위 최소화(Minimizing State Scope)** 에 대해 자세히 설명드리겠습니다.

---

# ✅ 상태 범위 최소화 (Minimizing State Scope)

## 🔸 개념 설명

React의 상태(`useState`, `useReducer`, 전역 상태 등)는
**그 상태를 가진 컴포넌트가 변경되면 리렌더링**됩니다.

그리고 **그 하위에 있는 모든 자식 컴포넌트도 함께 리렌더링**됩니다.

### 👉 따라서:

* 상태는 **최대한 필요한 컴포넌트 안쪽에만 위치**시켜야 합니다.
* 전역에 둘수록 리렌더링 영향 범위가 넓어져 성능 저하 발생

---

## 🔸 예제 비교: 상태 범위가 넓은 경우 vs 좁은 경우

### ❌ 상태 범위가 넓은 경우 (불필요한 리렌더링 발생)

```jsx
// 📁 src/App.js

import React, { useState } from "react";
import Header from "./Header";
import Counter from "./Counter";

const App = () => {
  const [count, setCount] = useState(0); // 상태가 상위에 있음

  return (
    <div>
      {/* 이 컴포넌트는 count와 관련 없지만, App이 리렌더링되면 함께 렌더링됨 */}
      <Header />  
      {/* 실제로 count를 사용하는 컴포넌트 */}
      <Counter count={count} onIncrement={() => setCount(count + 1)} />
    </div>
  );
};

export default App;
```

```jsx
// 📁 src/Header.js

const Header = () => {
  console.log("🌀 Header 리렌더링됨");
  return <h1>My App</h1>;
};

export default Header;
```

```jsx
// 📁 src/Counter.js

const Counter = ({ count, onIncrement }) => {
  console.log("🔁 Counter 리렌더링됨");
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={onIncrement}>증가</button>
    </div>
  );
};

export default Counter;
```

### 결과:

* 버튼 클릭 시 `App`이 리렌더링되며
* **`Header`도 불필요하게 리렌더링**됨

---

### ✅ 상태 범위를 최소화한 버전 (성능 최적화)

```jsx
// 📁 src/App.js

import React from "react";
import Header from "./Header";
import Counter from "./Counter";

const App = () => {
  return (
    <div>
      <Header />  {/* 이젠 영향 안 받음 */}
      <Counter /> {/* 상태를 내부로 이동 */}
    </div>
  );
};

export default App;
```

```jsx
// 📁 src/Counter.js

import React, { useState } from "react";

const Counter = () => {
  const [count, setCount] = useState(0);

  console.log("🔁 Counter 리렌더링됨");

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>증가</button>
    </div>
  );
};

export default Counter;
```

### 결과:

* 버튼 클릭 시 **오직 `Counter`만 리렌더링**
* `Header`는 리렌더링되지 않음 → 성능 향상

---

## ✅ 정리

| 항목      | 잘못된 방식   | 최적화 방식        |
| ------- | -------- | ------------- |
| 상태 위치   | 상위에 위치   | 필요한 컴포넌트 내부에만 |
| 리렌더링 영향 | 전체/모든 자식 | 필요한 컴포넌트만     |
| 성능      | 낭비 발생    | 최적화됨          |

---

## ✅ 언제 상위로 올려야 할까?

다만, 다음과 같은 경우는 상태를 상위에 두는 것이 맞습니다:

* 여러 자식 컴포넌트에서 **공유해야 하는 상태**일 때
* 상위 컴포넌트가 상태 흐름을 **제어해야 할 필요**가 있을 때

---

다음 주제로는 **전역 상태 관리 도구의 선택과 비교** (`Context`, `Redux`, `Zustand`, `Recoil`) 등을 구체적으로 소개드릴까요?

필요하시면 `다음`이라고 입력해주세요.

---

좋습니다. 이번에는 상태관리 최적화의 두 번째 주제
**✅ 전역 상태 관리 도구의 선택과 비교**를 구체적으로 설명드리겠습니다.

---

# ✅ 전역 상태 관리 도구의 선택과 비교

## 🔸 왜 전역 상태 관리가 필요한가?

React 컴포넌트 간 상태 공유가 필요할 때
`useState`나 `props drilling`만으로는 복잡성이 증가합니다.

→ 이때 **전역 상태 관리 도구**를 사용하면 복잡한 상태 흐름을 간결하게 만들 수 있습니다.

---

## ✅ 대표적인 전역 상태 관리 도구

| 도구          | 특징                        | 사용 난이도 | 성능    | 사용 예시              |
| ----------- | ------------------------- | ------ | ----- | ------------------ |
| Context API | React 내장 전역 상태            | 쉬움     | 중간    | 간단한 글로벌 테마, 로그인 정보 |
| Redux       | 가장 유명한 상태관리 도구            | 높음     | 높음    | 복잡한 대형 앱           |
| Zustand     | 가볍고 빠름, 코드 간결             | 낮음     | 매우 높음 | 중소형 앱, SSR         |
| Recoil      | 페이스북 개발, 비동기와 selector 지원 | 중간     | 높음    | 컴포넌트 간 종속성 많은 앱    |

---

## 🔸 1. Context API

```jsx
// 📁 src/context/UserContext.js

import { createContext } from 'react';

export const UserContext = createContext(null);
```

```jsx
// 📁 src/App.js

import { UserContext } from './context/UserContext';

const App = () => {
  const user = { name: "넥스트스탭", role: "엔지니어" };

  return (
    <UserContext.Provider value={user}>
      <Profile />
    </UserContext.Provider>
  );
};
```

```jsx
// 📁 src/Profile.js

import { useContext } from 'react';
import { UserContext } from './context/UserContext';

const Profile = () => {
  const user = useContext(UserContext);
  return <p>사용자: {user.name}</p>;
};
```

* ✅ 장점: 간단한 전역 상태 공유 가능
* ❌ 단점: 상태가 바뀌면 **하위 전체 리렌더링**, 분리 어려움

---

## 🔸 2. Redux

* 중앙에서 상태를 제어하고 **예측 가능한 방식으로 업데이트**
* 미들웨어, 개발자 도구, 비동기 처리 등 확장성 강력

```bash
npm install redux react-redux
```

```js
// 📁 src/store.js

import { createStore } from "redux";

const initialState = { count: 0 };

function reducer(state = initialState, action) {
  switch (action.type) {
    case "INCREMENT": return { count: state.count + 1 };
    default: return state;
  }
}

export const store = createStore(reducer);
```

```jsx
// 📁 src/App.js

import { Provider, useDispatch, useSelector } from "react-redux";
import { store } from "./store";

const Counter = () => {
  const count = useSelector(state => state.count);
  const dispatch = useDispatch();

  return (
    <div>
      <p>카운트: {count}</p>
      <button onClick={() => dispatch({ type: "INCREMENT" })}>+</button>
    </div>
  );
};

const App = () => (
  <Provider store={store}>
    <Counter />
  </Provider>
);
```

* ✅ 장점: 대규모 앱에 적합, 미들웨어 활용 가능
* ❌ 단점: 보일러플레이트(코드량) 많고 복잡

---

## 🔸 3. Zustand

```bash
npm install zustand
```

```js
// 📁 src/store/useCounterStore.js

import create from 'zustand';

export const useCounterStore = create((set) => ({
  count: 0,
  increase: () => set((state) => ({ count: state.count + 1 })),
}));
```

```jsx
// 📁 src/Counter.js

import { useCounterStore } from './store/useCounterStore';

const Counter = () => {
  const count = useCounterStore(state => state.count);
  const increase = useCounterStore(state => state.increase);

  return (
    <div>
      <p>카운트: {count}</p>
      <button onClick={increase}>+</button>
    </div>
  );
};
```

* ✅ 장점: 사용법 매우 간단, 퍼포먼스 최상, selector 기반 분리
* ✅ 추가 기능: SSR, middleware, persistence 지원

---

## 🔸 4. Recoil

```bash
npm install recoil
```

```js
// 📁 src/atoms/counterAtom.js

import { atom } from 'recoil';

export const counterAtom = atom({
  key: 'counterAtom',
  default: 0,
});
```

```jsx
// 📁 src/Counter.js

import { useRecoilState } from 'recoil';
import { counterAtom } from './atoms/counterAtom';

const Counter = () => {
  const [count, setCount] = useRecoilState(counterAtom);

  return (
    <div>
      <p>카운트: {count}</p>
      <button onClick={() => setCount(count + 1)}>+</button>
    </div>
  );
};
```

* ✅ 장점: 비동기 처리(`selector`, `atomFamily`)가 매우 쉬움
* ❌ 단점: 초기 진입 장벽 있음, 아직 생태계가 작음

---

## ✅ 비교 요약

| 도구          | 용도        | 장점               | 단점             |
| ----------- | --------- | ---------------- | -------------- |
| Context API | 간단한 전역 상태 | React 내장, 간단     | 전체 리렌더링 발생     |
| Redux       | 대규모 상태 관리 | 예측 가능, 미들웨어      | 보일러플레이트 많음     |
| Zustand     | 경량 고성능    | 사용법 단순, 빠름       | 공식 DevTools 부족 |
| Recoil      | 의존관계 많은 앱 | selector, 비동기 편리 | 학습 필요          |

---

다음은 상태관리 최적화 중
**"Context 분리 최적화 (Provider 나누기)"** 를 다루겠습니다.
진행하려면 `다음`이라고 입력해주세요.

---

좋습니다. 이번에는 상태관리 최적화의 세 번째 항목인
**✅ Context 분리 최적화 (Provider 구조 분리)** 에 대해 구체적으로 설명드리겠습니다.
특히 **불필요한 리렌더링을 방지하는 구조 설계법**을 예제와 함께 다룹니다.

---

# ✅ Context 분리 최적화 (Provider 구조 분리)

## 🔸 문제 상황

`React Context`는 **하위 모든 컴포넌트를 리렌더링**시킵니다.

* 어떤 값이 바뀌면, 그 값을 구독한 모든 컴포넌트가 리렌더링됩니다.
* 즉, **Context 하나에 모든 전역 상태를 몰아넣으면 성능이 급격히 저하**됩니다.

---

## 🔸 해결 방법

> 상태를 **기능별로 여러 Context로 분리하고**,
> 필요한 곳에서만 해당 Context를 사용하면 리렌더링 범위를 줄일 수 있습니다.

---

## ✅ 예시: Context 분리 vs 하나로 통합한 경우

### ❌ 나쁜 예시 – 모든 상태를 하나의 Context에 몰아넣음

```jsx
// 📁 src/context/AppContext.js

import { createContext } from "react";

export const AppContext = createContext(null);
```

```jsx
// 📁 src/App.js

import { useState } from "react";
import { AppContext } from "./context/AppContext";
import ThemeToggle from "./ThemeToggle";
import UserInfo from "./UserInfo";

const App = () => {
  const [theme, setTheme] = useState("light");
  const [user, setUser] = useState({ name: "넥스트스탭" });

  return (
    <AppContext.Provider value={{ theme, setTheme, user, setUser }}>
      <ThemeToggle />
      <UserInfo />
    </AppContext.Provider>
  );
};

export default App;
```

```jsx
// 📁 src/UserInfo.js

import { useContext } from "react";
import { AppContext } from "./context/AppContext";

const UserInfo = () => {
  const { user } = useContext(AppContext);
  console.log("👤 UserInfo 리렌더링");
  return <p>사용자: {user.name}</p>;
};
```

```jsx
// 📁 src/ThemeToggle.js

import { useContext } from "react";
import { AppContext } from "./context/AppContext";

const ThemeToggle = () => {
  const { theme, setTheme } = useContext(AppContext);
  console.log("🎨 ThemeToggle 리렌더링");
  return (
    <button onClick={() => setTheme(theme === "light" ? "dark" : "light")}>
      테마: {theme}
    </button>
  );
};
```

### 결과:

* 테마를 바꿀 때 `UserInfo`도 리렌더링됨 → ❌ **불필요한 렌더링 발생**

---

### ✅ 좋은 예시 – Context를 분리하여 필요한 컴포넌트만 리렌더링

```jsx
// 📁 src/context/ThemeContext.js
import { createContext } from "react";
export const ThemeContext = createContext(null);
```

```jsx
// 📁 src/context/UserContext.js
import { createContext } from "react";
export const UserContext = createContext(null);
```

```jsx
// 📁 src/App.js

import { useState } from "react";
import { ThemeContext } from "./context/ThemeContext";
import { UserContext } from "./context/UserContext";
import ThemeToggle from "./ThemeToggle";
import UserInfo from "./UserInfo";

const App = () => {
  const [theme, setTheme] = useState("light");
  const [user, setUser] = useState({ name: "넥스트스탭" });

  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      <UserContext.Provider value={{ user, setUser }}>
        <ThemeToggle />
        <UserInfo />
      </UserContext.Provider>
    </ThemeContext.Provider>
  );
};

export default App;
```

```jsx
// 📁 src/ThemeToggle.js

import { useContext } from "react";
import { ThemeContext } from "./context/ThemeContext";

const ThemeToggle = () => {
  const { theme, setTheme } = useContext(ThemeContext);
  console.log("🎨 ThemeToggle 리렌더링");
  return (
    <button onClick={() => setTheme(theme === "light" ? "dark" : "light")}>
      테마: {theme}
    </button>
  );
};

export default ThemeToggle;
```

```jsx
// 📁 src/UserInfo.js

import { useContext } from "react";
import { UserContext } from "./context/UserContext";

const UserInfo = () => {
  const { user } = useContext(UserContext);
  console.log("👤 UserInfo 리렌더링");
  return <p>사용자: {user.name}</p>;
};

export default UserInfo;
```

### 결과:

* 테마 변경 시 `ThemeToggle`만 리렌더링됨
* `UserInfo`는 리렌더링되지 않음 → ✅ 성능 최적화

---

## ✅ 정리

| 구분         | 잘못된 방식        | 최적화 방식      |
| ---------- | ------------- | ----------- |
| Context 범위 | 통합 1개         | 기능별로 분리     |
| 리렌더링 범위    | 전체 컴포넌트 영향    | 필요한 컴포넌트만   |
| 성능         | 하위 컴포넌트 낭비 발생 | 불필요한 렌더링 차단 |

---

다음 주제는 렌더링 최적화 중에서 리스트/스크롤 성능 개선을 위한
**✅ DOM 최적화 – 리스트 가상화 (Virtualization)** 를 `react-window` 예제로 설명드릴 수 있습니다.

진행하시려면 `다음`이라고 입력해주세요.

---

맞습니다. 정확하게 알고 계십니다.

---

## ✅ 전체 구조상 흐름 정리

지금까지 다룬 것은 다음 두 범주입니다:

### 1. **렌더링 최적화**

* React.memo ✅
* useMemo ✅
* useCallback ✅
* key 설정 최적화 ✅

### 2. **상태관리 최적화**

* 상태 범위 최소화 ✅
* 전역 상태 도구 선택 ✅
* Context 분리 최적화 ✅

---

## ✅ 다음은 **"코드 분할 & 지연 로딩" 최적화**입니다

이는 상태관리 범주를 벗어나서
**사용자 경험과 번들 사이즈 최적화를 위한 중요한 렌더링 전략**입니다.

---

# ✅ 코드 분할(Code Splitting) & 지연 로딩(Lazy Loading)

## 🔸 개념 설명

리액트 앱은 기본적으로 **하나의 큰 JS 파일로 번들링**되지만,
초기 로딩 속도를 줄이기 위해 **코드를 여러 조각으로 분할**할 수 있습니다.

* 필요한 시점에만 코드를 **동적으로 로드**
* 초기 로딩 시 **불필요한 코드 제외**
* UX 향상 + 성능 최적화

---

## ✅ 핵심 기술 2가지

| 기술           | 설명                        |
| ------------ | ------------------------- |
| `React.lazy` | 컴포넌트를 동적으로 import (지연 로딩) |
| `Suspense`   | 로딩 중 fallback UI 지정       |

---

## 🔸 예시 코드 – 지연 로딩으로 페이지 분할하기

```jsx
// 📁 src/pages/Home.js

const Home = () => {
  console.log("🏠 Home 컴포넌트 로딩됨");
  return <h1>홈 페이지</h1>;
};

export default Home;
```

```jsx
// 📁 src/pages/About.js

const About = () => {
  console.log("ℹ️ About 컴포넌트 로딩됨");
  return <h1>소개 페이지</h1>;
};

export default About;
```

```jsx
// 📁 src/App.js

import React, { Suspense, lazy } from "react";

// ✅ 지연 로딩 컴포넌트 정의
const Home = lazy(() => import("./pages/Home"));
const About = lazy(() => import("./pages/About"));

const App = () => {
  const [page, setPage] = React.useState("home");

  return (
    <div>
      <h1>코드 분할 예제</h1>
      <button onClick={() => setPage("home")}>Home</button>
      <button onClick={() => setPage("about")}>About</button>

      {/* ✅ Suspense로 로딩 UI 처리 */}
      <Suspense fallback={<p>로딩 중...</p>}>
        {page === "home" && <Home />}
        {page === "about" && <About />}
      </Suspense>
    </div>
  );
};

export default App;
```

---

## 🔸 동작 원리 설명

* 사용자가 "Home"을 보기 전까지는 `Home.js`를 로드하지 않음
* "About" 버튼 클릭 시 `About.js`를 **실시간으로 로딩**
* `Suspense`의 `fallback`으로 로딩 중 UI 처리 가능

---

## ✅ Webpack 설정 없이도 동작

* `React.lazy`와 `Suspense`는 CRA(Create React App)나 Vite 등 기본 설정에 포함된 Webpack에서 지원됨
* **경로 기반 코드 분할**은 React Router와 함께 사용하면 더 강력해짐 (다음에 다룰 수 있음)

---

## ✅ 요약

| 항목    | 설명                                                  |
| ----- | --------------------------------------------------- |
| 목적    | 초기 번들 크기 축소, 로딩 속도 향상                               |
| 구현 방법 | `React.lazy`, `Suspense` 사용                         |
| 추가 기술 | 라우터 기반 lazy 로딩, Webpack splitChunks, dynamic import |

---

다음 주제로는 **DOM 조작 최적화 (특히 리스트 가상화: react-window)** 로 이어갈 수 있습니다.
진행을 원하시면 `다음`이라고 입력해 주세요.

---

좋습니다. 이번에는 **렌더링 최적화의 핵심 중 하나인**
**✅ DOM 조작 최적화: 리스트 가상화(Virtualization)** 를 설명드리겠습니다.
특히 **많은 데이터를 효율적으로 렌더링**해야 할 때 꼭 필요한 기술입니다.

---

# ✅ DOM 조작 최적화 – 리스트 가상화 (Virtualization)

## 🔸 개념 설명

많은 항목(예: 수천 개)을 렌더링할 때 `map()`으로 전부 그리면
**브라우저에 엄청난 렌더링 부담**을 줍니다.

\*\*리스트 가상화(Virtualization)\*\*는
**화면에 보이는 항목만 DOM에 그리는 기술**입니다.

---

## ✅ 대표 라이브러리

| 라이브러리               | 특징                 |
| ------------------- | ------------------ |
| `react-window`      | 가장 가볍고 빠름, 페이스북 제작 |
| `react-virtualized` | 기능은 많지만 무거움        |
| `virtuoso`          | 무한 스크롤, 다중 목록 등 지원 |

이 중에서는 \*\*`react-window`\*\*가 가장 많이 사용됩니다.

---

## ✅ 설치

```bash
npm install react-window
```

---

## ✅ 예시 코드: 10,000개의 항목을 가상화로 렌더링

```jsx
// 📁 src/VirtualizedList.js

import React from "react";
import { FixedSizeList as List } from "react-window";

// 1만 개 항목 생성
const items = Array.from({ length: 10000 }, (_, i) => `아이템 ${i + 1}`);

const Row = ({ index, style }) => {
  // style은 반드시 적용해야 스크롤/위치가 정상 작동
  return (
    <div style={style}>
      {items[index]}
    </div>
  );
};

const VirtualizedList = () => {
  return (
    <div>
      <h3>가상화된 리스트</h3>

      <List
        height={400}       // 전체 높이 (px)
        itemCount={items.length} // 전체 아이템 수
        itemSize={35}       // 각 항목의 높이
        width={"100%"}      // 리스트 너비
      >
        {Row}
      </List>
    </div>
  );
};

export default VirtualizedList;
```

---

## 🔸 주요 설명

* `height`: 리스트 전체 영역 높이
* `itemSize`: 개별 항목의 고정 높이 (동적 높이는 다른 컴포넌트 필요)
* `itemCount`: 전체 아이템 개수
* `style`: 필수. `react-window`가 성능 최적화를 위해 자동 계산한 CSS 위치 정보

---

## 🔸 결과 비교

| 일반 map 렌더링  | react-window 사용   |
| ----------- | ----------------- |
| 1만 개 DOM 생성 | 보이는 것만 DOM 생성     |
| 느린 스크롤, 렌더링 | 빠른 렌더링, 적은 메모리 사용 |
| 모바일에서 끊김    | 매끄러운 성능 유지        |

---

## ✅ 팁

* 무한 스크롤, 동적 로딩은 `InfiniteLoader`와 함께 사용
* 사용 시 반드시 `style`을 넘겨야 정상 동작
* `key`는 따로 줄 필요 없음 → 내부에서 최적화됨

---

## ✅ 요약

| 항목 | 설명                                                |
| -- | ------------------------------------------------- |
| 목적 | 수천 개 이상의 리스트를 성능 저하 없이 보여줌                        |
| 기술 | `react-window`, `react-virtualized`, `virtuoso` 등 |
| 장점 | 렌더링 요소 수 제한 → 빠른 렌더링, 낮은 메모리                      |
| 단점 | 리스트 항목 높이가 일정하지 않다면 별도 처리 필요                      |

---

다음 주제로는
**✅ 이벤트 핸들링 최적화 (debounce / throttle, 이벤트 위임)** 으로 넘어갈 수 있습니다.
진행을 원하시면 `다음`이라고 입력해 주세요.

---

좋습니다. 이번에는 렌더링 최적화 시 반드시 고려해야 할
**✅ 이벤트 핸들링 최적화** 기법들을 자세히 설명드리겠습니다.

---

# ✅ 이벤트 핸들링 최적화

## 🔸 왜 최적화가 필요한가?

사용자의 입력(예: scroll, resize, input change 등)은
**매우 자주 발생하는 이벤트**입니다.

이런 이벤트에 바로 함수가 실행되면 성능 저하나 과도한 렌더링 발생 →
**debounce / throttle / 이벤트 위임** 등의 최적화 기법이 필요합니다.

---

## ✅ 대표적인 최적화 기법

| 기법           | 설명                                |
| ------------ | --------------------------------- |
| **Debounce** | 이벤트가 연속으로 발생할 때 **마지막 호출만 실행**    |
| **Throttle** | 이벤트가 연속으로 발생해도 **일정 간격으로 실행**     |
| **이벤트 위임**   | 여러 하위 엘리먼트의 이벤트를 **상위에서 한 번만 처리** |

---

## ✅ Debounce 예제 – input 검색 요청 최적화

### 설치 (lodash 사용 권장)

```bash
npm install lodash
```

### 코드 예시

```jsx
// 📁 src/DebouncedSearch.js

import React, { useState, useMemo } from "react";
import debounce from "lodash/debounce";

const DebouncedSearch = () => {
  const [keyword, setKeyword] = useState("");

  // ✅ debounce 함수: 300ms 내에 연속 호출되면 무시됨
  const debouncedSearch = useMemo(
    () =>
      debounce((value) => {
        console.log("🔍 검색 요청:", value);
        // 여기에 실제 API 호출 가능
      }, 300),
    []
  );

  // 🔄 입력값 변경 시 debounce 적용
  const handleChange = (e) => {
    const value = e.target.value;
    setKeyword(value);
    debouncedSearch(value);
  };

  return (
    <div>
      <h3>Debounce 입력</h3>
      <input value={keyword} onChange={handleChange} placeholder="검색어 입력" />
    </div>
  );
};

export default DebouncedSearch;
```

### 설명:

* 사용자가 입력할 때마다 API를 호출하지 않고,
* 입력이 멈춘 뒤 300ms 후에 한 번만 실행됨

---

## ✅ Throttle 예제 – 스크롤 이벤트 최적화

```jsx
// 📁 src/ScrollLogger.js

import React, { useEffect } from "react";
import throttle from "lodash/throttle";

const ScrollLogger = () => {
  useEffect(() => {
    const handleScroll = throttle(() => {
      console.log("📜 스크롤 중...");
    }, 500); // 500ms 간격으로만 실행됨

    window.addEventListener("scroll", handleScroll);

    return () => {
      window.removeEventListener("scroll", handleScroll);
    };
  }, []);

  return <div style={{ height: "2000px" }}>스크롤 테스트</div>;
};

export default ScrollLogger;
```

### 설명:

* 스크롤 이벤트는 매우 자주 발생
* `throttle`을 사용하면 **반복 호출을 일정 간격으로 제한**

---

## ✅ 이벤트 위임(Event Delegation) 예제

### 잘못된 방식 – 각 항목에 이벤트 리스너 추가

```jsx
<ul>
  {items.map((item, i) => (
    <li key={i} onClick={() => alert(item)}>항목 {item}</li>
  ))}
</ul>
```

* 항목이 많아질수록 이벤트 리스너가 **불필요하게 많이 등록**됨

---

### 최적화 방식 – 이벤트 위임

```jsx
<ul onClick={(e) => {
  if (e.target.tagName === "LI") {
    alert(e.target.textContent);
  }
}}>
  {items.map((item, i) => (
    <li key={i}>항목 {item}</li>
  ))}
</ul>
```

* ✅ 하나의 이벤트 핸들러만 사용 → 퍼포먼스 향상

---

## ✅ 요약

| 기법         | 사용 시점          | 목적                       |
| ---------- | -------------- | ------------------------ |
| `debounce` | 입력창, 검색어 입력    | **짧은 시간 내 연속 이벤트 무시**    |
| `throttle` | scroll, resize | **지속적인 이벤트를 일정 간격으로 제한** |
| 이벤트 위임     | 다수의 자식 요소      | **이벤트 리스너 수 최소화**        |

---

다음 주제로는
**✅ 개발 도구(React DevTools, Profiler, Lighthouse)** 를 활용한 렌더링 진단 및 최적화 방법으로 넘어가겠습니다.

진행하시려면 `다음`이라고 입력해 주세요.

---

좋습니다. 이번에는 리액트 성능 최적화를 **도와주는 개발 도구**에 대해 자세히 설명드리겠습니다.

---

# ✅ 리액트 성능 분석 및 최적화 도구

## 🔸 왜 필요한가?

코드를 아무리 잘 짜도 실제 렌더링에서

* 어떤 컴포넌트가 자주 리렌더링되는지
* 병목이 어디서 발생하는지
* 초기 로딩 속도나 접근성 점수는 어떤지
  **직접 확인하지 않으면 알 수 없습니다.**

→ 이런 상황에서 React 전용 도구들이 큰 도움이 됩니다.

---

## ✅ 1. React DevTools (리액트 전용 디버깅 도구)

### 설치

* 크롬/엣지 확장 프로그램: **React Developer Tools** 설치
* 또는 Node 환경에서 `npm install react-devtools`로 CLI 실행 가능

### 주요 기능

| 기능                   | 설명                                 |
| -------------------- | ---------------------------------- |
| **Components** 탭     | 현재 렌더링된 컴포넌트 트리 확인                 |
| **Props, State 보기**  | 각 컴포넌트의 상태, props 확인 가능            |
| **왜 리렌더링됐는지 확인**     | `highlight updates` 활성화 시 리렌더링 시각화 |
| **React.memo 효과 검증** | memo 적용 여부 직접 확인                   |

---

### 사용 예시

```jsx
import React from "react";

const User = React.memo(({ name }) => {
  console.log("🔁 렌더링:", name);
  return <div>{name}</div>;
});
```

* DevTools로 해당 컴포넌트 선택 → 상태, props 확인 가능
* "Highlight updates" 옵션 켜고, 리렌더링 시 색상 강조로 시각 확인

---

## ✅ 2. React Profiler (렌더링 시간 분석)

### 사용 방법

* `React.StrictMode` 안에서 `<Profiler>`로 감쌈

```jsx
import React, { Profiler } from "react";
import MyComponent from "./MyComponent";

const App = () => {
  const onRender = (
    id,
    phase,
    actualDuration,
    baseDuration,
    startTime,
    commitTime
  ) => {
    console.log(`⏱ ${id} ${phase} 렌더링: ${actualDuration}ms`);
  };

  return (
    <Profiler id="MyComponent" onRender={onRender}>
      <MyComponent />
    </Profiler>
  );
};
```

### 출력 예시

```
⏱ MyComponent mount 렌더링: 2.5ms
```

* **actualDuration**: 실제 렌더링에 걸린 시간
* **baseDuration**: 전체 트리 렌더링 시 걸리는 예상 시간

---

## ✅ 3. Lighthouse (브라우저 퍼포먼스 및 품질 분석)

### 사용 방법

* Chrome DevTools → "Lighthouse" 탭
* 또는 [PageSpeed Insights](https://pagespeed.web.dev/) 사용

### 측정 항목

| 항목             | 설명                       |
| -------------- | ------------------------ |
| Performance    | 초기 로딩 속도, 코드 분할, 이미지 최적화 |
| Accessibility  | 접근성(스크린 리더 등)            |
| Best Practices | 안전한 코드, HTTPS 등          |
| SEO            | 검색 최적화                   |

### 결과 예시

| 항목                     | 점수   | 추천 개선 사항             |
| ---------------------- | ---- | -------------------- |
| First Contentful Paint | 2.8초 | 코드 분할, 이미지 lazy load |
| Unused JavaScript      | -    | 지연 로딩 적용 권장          |
| Avoid large DOM size   | -    | 리스트 가상화 추천           |

---

## ✅ 요약 비교

| 도구             | 목적               | 특징                 |
| -------------- | ---------------- | ------------------ |
| React DevTools | 컴포넌트 상태/props 확인 | 실시간 확인, memo 확인 가능 |
| React Profiler | 렌더링 시간 분석        | 성능 병목 추적           |
| Lighthouse     | 전체 앱 품질 평가       | 웹 성능 종합 점수 제공      |

---

다음 주제로는 **서버 요청 및 데이터 처리 최적화** 항목 중
**React Query / SWR / prefetching 등 네트워크 성능 최적화**로 넘어갈 수 있습니다.

진행하시려면 `다음`이라고 입력해주세요.

---

좋습니다. 이번에는 리액트에서 서버 데이터를 다룰 때 성능을 높이기 위한
**✅ 네트워크 및 데이터 처리 최적화** 기술들을 구체적으로 설명드리겠습니다.

---

# ✅ 네트워크 및 데이터 처리 최적화

## 🔸 왜 중요한가?

* 서버 API 요청이 많거나 중복되면 **네트워크 병목** 발생
* 매번 서버에서 데이터를 새로 가져오면 UX 저하
* 특히 모바일 환경이나 느린 네트워크에서 **반응성이 떨어짐**

→ 이러한 문제를 해결하기 위해 다음과 같은 기술들을 활용합니다.

---

## ✅ 핵심 기술 3가지

| 기술                    | 설명                          |
| --------------------- | --------------------------- |
| **React Query / SWR** | 데이터를 자동으로 캐싱하고 중복 요청 방지     |
| **Prefetching**       | 사용자가 접근하기 전 데이터를 미리 가져오기    |
| **Skeleton UI**       | 로딩 중 비어있는 화면 대신 자리 표시 UI 제공 |

---

## ✅ 1. React Query – 서버 상태 관리의 표준

### 설치

```bash
npm install @tanstack/react-query
```

### 예시 코드

```jsx
// 📁 src/UserList.js

import { useQuery } from "@tanstack/react-query";
import axios from "axios";

const fetchUsers = async () => {
  const res = await axios.get("https://jsonplaceholder.typicode.com/users");
  return res.data;
};

const UserList = () => {
  const { data, isLoading, error } = useQuery(["users"], fetchUsers);

  if (isLoading) return <p>로딩 중...</p>;
  if (error) return <p>에러 발생</p>;

  return (
    <ul>
      {data.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
};

export default UserList;
```

### 장점

* ✅ 요청 결과 자동 캐싱
* ✅ 동일한 요청 반복 시 캐시 재사용 (중복 요청 방지)
* ✅ 에러/로딩/재시도 상태 자동 처리
* ✅ devtools 통해 서버 상태 확인 가능

---

## ✅ 2. Prefetching – 사용자 행동 예측 기반 데이터 미리 가져오기

```jsx
// 예시: 링크에 마우스를 올리면 미리 데이터 fetch

import { useQueryClient } from "@tanstack/react-query";

const queryClient = useQueryClient();

const handleMouseEnter = () => {
  queryClient.prefetchQuery(["users"], fetchUsers);
};

<a onMouseEnter={handleMouseEnter} href="/users">유저 목록</a>
```

* ✅ 사용자가 페이지를 클릭하기 전에 데이터를 미리 받아서 UX 개선

---

## ✅ 3. Skeleton UI – 로딩 중 레이아웃 유지

```jsx
const UserListSkeleton = () => (
  <ul>
    {[...Array(5)].map((_, i) => (
      <li key={i} style={{ background: "#eee", height: 20, margin: 5 }} />
    ))}
  </ul>
);
```

* ✅ 로딩 상태에서도 화면 깜빡임 없이 사용자에게 안정감을 제공

---

## ✅ 비교: 직접 fetch vs React Query

| 항목       | 직접 fetch 사용     | React Query 사용 |
| -------- | --------------- | -------------- |
| 캐싱       | ❌ 없음            | ✅ 자동 처리        |
| 중복요청 방지  | ❌ 직접 제어 필요      | ✅ 자동           |
| 로딩/에러 처리 | ✅ 수동 구현         | ✅ 자동 처리        |
| 전역 상태 공유 | ❌ useContext 필요 | ✅ 전역에서 가능      |
| 성능       | 낮음              | 높음             |

---

## ✅ SWR (by Vercel) 도입 가능

* `useSWR` 훅 기반
* React Query와 유사
* Next.js 프로젝트에서 자주 사용됨
* 내부적으로 stale-while-revalidate 정책 지원

```bash
npm install swr
```

```js
import useSWR from "swr";

const fetcher = url => fetch(url).then(res => res.json());

const { data, error } = useSWR("/api/user", fetcher);
```

---

## ✅ 요약

| 기술          | 목적        | 장점              |
| ----------- | --------- | --------------- |
| React Query | 서버 데이터 캐싱 | 캐싱, 중복방지, 자동 갱신 |
| Prefetch    | 사용자 행동 예측 | 페이지 진입 전 미리 로딩  |
| Skeleton UI | UX 향상     | 로딩 중 깜빡임 방지     |

---

다음 주제로는 최적화의 마지막 범주인
**✅ 기타 렌더링 최적화 (컴포넌트 분리, 이미지 최적화 등)** 으로 넘어가겠습니다.

진행하시려면 `다음`이라고 입력해주세요.

---

좋습니다. 이번에는 **렌더링 최적화의 마무리 단계**로,
다양한 실무 상황에서 적용할 수 있는 **기타 최적화 팁들**을 정리하고,
필요한 부분은 구체적인 예제와 함께 설명드리겠습니다.

---

# ✅ 기타 렌더링 최적화 기법

---

## ✅ 1. 컴포넌트 분리 (Component Splitting)

### 🔸 목적

* 하나의 큰 컴포넌트에 많은 상태와 로직이 있으면 **모든 변경 시 전체 리렌더링**
* 이를 **기능 단위로 나누면 변경 범위를 국소화**할 수 있음

### 🔸 예시

```jsx
// ❌ 안 좋은 예
const Profile = () => {
  const [name, setName] = useState("넥스트스탭");
  const [age, setAge] = useState(49);
  const [theme, setTheme] = useState("dark");

  return (
    <div>
      <input value={name} onChange={(e) => setName(e.target.value)} />
      <input value={age} onChange={(e) => setAge(e.target.value)} />
      <button onClick={() => setTheme(theme === "dark" ? "light" : "dark")}>
        테마 변경
      </button>
    </div>
  );
};
```

```jsx
// ✅ 개선된 예 – 상태별 컴포넌트 분리
const NameInput = React.memo(() => {
  const [name, setName] = useState("넥스트스탭");
  return <input value={name} onChange={(e) => setName(e.target.value)} />;
});

const AgeInput = React.memo(() => {
  const [age, setAge] = useState(49);
  return <input value={age} onChange={(e) => setAge(e.target.value)} />;
});

const ThemeButton = React.memo(() => {
  const [theme, setTheme] = useState("dark");
  return (
    <button onClick={() => setTheme(theme === "dark" ? "light" : "dark")}>
      테마 변경
    </button>
  );
});

const Profile = () => (
  <div>
    <NameInput />
    <AgeInput />
    <ThemeButton />
  </div>
);
```

* ✅ 입력창, 버튼 각각의 상태가 서로 영향을 주지 않음
* ✅ 특정 항목만 리렌더링됨 → 성능 향상

---

## ✅ 2. 비동기 함수 최소화 및 병렬 처리

### 🔸 예시 – 순차 호출 ❌

```js
await fetch("/user");
await fetch("/settings");
```

### 🔸 개선 – 병렬 호출 ✅

```js
await Promise.all([
  fetch("/user"),
  fetch("/settings")
]);
```

* ✅ 여러 API를 동시에 호출하면 시간 단축
* 특히 페이지 초기 렌더링에서 **의존성이 없는 요청은 병렬 처리**가 기본

---

## ✅ 3. 이미지 최적화

| 기술            | 설명                                       |
| ------------- | ---------------------------------------- |
| **WebP**      | PNG, JPG보다 압축률 좋음                        |
| **Lazy Load** | `loading="lazy"` 속성으로 뷰포트 밖 이미지 미리 안 불러옴 |
| **CDN 사용**    | 빠른 이미지 전송                                |
| **적절한 크기 지정** | 고해상도 이미지가 필요 이상 로딩되지 않도록 제한              |

```jsx
<img
  src="/banner.webp"
  alt="배너"
  width="100%"
  height="auto"
  loading="lazy"
/>
```

---

## ✅ 4. 불필요한 코드 제거

* 사용하지 않는 변수, 컴포넌트, 라이브러리 제거
* 번들 용량 최적화 (`tree shaking` 적용 가능)

---

## ✅ 5. Suspense + lazy 조합을 라우터에도 적용

```jsx
const Home = React.lazy(() => import('./pages/Home'));

<Suspense fallback={<div>로딩 중...</div>}>
  <Routes>
    <Route path="/" element={<Home />} />
  </Routes>
</Suspense>
```

* 페이지 진입 시 느려지는 원인을 해결할 수 있음

---

## ✅ 6. React 18의 자동 배치(Auto Batching)

* 여러 state 변경이 **한 번에 처리됨 → 불필요한 리렌더링 줄어듬**

```jsx
setState1("A");
setState2("B");
// React 18 이상에서는 한 번만 렌더링됨
```

---

## ✅ 요약

| 기술              | 설명             |
| --------------- | -------------- |
| 컴포넌트 분리         | 상태 영향 범위 축소    |
| 비동기 병렬 처리       | 로딩 속도 향상       |
| 이미지 최적화         | 대역폭 절약, UX 향상  |
| 불필요한 코드 제거      | 번들 크기 감소       |
| Suspense + lazy | 페이지 진입 시 속도 개선 |

---

여기까지가 리액트에서 적용할 수 있는 **렌더링 및 상태관리 기반 최적화 기법 전체**입니다.
필요하시다면 이 모든 내용을 하나로 정리된 PDF나 ZIP 예제 코드로 묶어드릴 수도 있습니다.

또는, 이 내용을 기반으로 리팩토링이나 실전 예제 프로젝트로 이어가고 싶으시면 알려주세요.
