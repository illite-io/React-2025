좋습니다.
그럼 **React Hooks 시작하기 100제 – 54번 `useLongPress` (길게 누르기 감지)** 예제로 넘어가겠습니다.

---

## 54. `useLongPress` – 길게 누르기 감지

### 목적

* 마우스/터치 입력을 **일정 시간 이상 유지**했을 때만 동작 수행
* 컨텍스트 메뉴, 재정렬, 툴팁 고정 등 제스처 UX에 활용

---

### 파일 경로: `src/hooks/useLongPress.js`

```javascript
import { useCallback, useMemo, useRef } from 'react';

/**
 * useLongPress
 * @param {Function} onLongPress - 길게 누르기 성공 시 호출
 * @param {Object}   options
 * @param {number}   options.delay=500 - 길게 누르기로 인정할 지연(ms)
 * @param {Function} options.onStart - 누르기 시작 시 콜백(옵션)
 * @param {Function} options.onFinish - 누르기 끝났을 때(성공/실패 관계없이) 콜백(옵션)
 * @param {boolean}  options.preventContextMenu=true - 길게 눌러 생기는 컨텍스트 메뉴 방지
 * @returns {object} 바인딩용 props: { onMouseDown, onTouchStart, onMouseUp, onMouseLeave, onTouchEnd, onTouchCancel, onContextMenu }
 */
export default function useLongPress(onLongPress, options = {}) {
  const {
    delay = 500,
    onStart,
    onFinish,
    preventContextMenu = true,
  } = options;

  const timerRef = useRef(null);
  const triggeredRef = useRef(false);

  const clear = useCallback((shouldTriggerFinish = true) => {
    if (timerRef.current) {
      clearTimeout(timerRef.current);
      timerRef.current = null;
    }
    if (shouldTriggerFinish) onFinish?.();
    triggeredRef.current = false;
  }, [onFinish]);

  const start = useCallback((e) => {
    onStart?.(e);
    triggeredRef.current = false;

    // 모바일에서 스크롤 제스처 등과 충돌 방지: 수동으로만 필요 시 e.preventDefault를 넣어 사용자가 결정
    timerRef.current = setTimeout(() => {
      triggeredRef.current = true;
      onLongPress?.(e);
    }, delay);
  }, [delay, onLongPress, onStart]);

  const end = useCallback(() => {
    // 길게 누르기가 이미 발동했다면 onFinish에서 후처리, 아니면 타이머만 제거
    clear(true);
  }, [clear]);

  const cancel = useCallback(() => {
    // 이동/캔슬 등으로 실패한 경우 finish 콜백은 호출하되 타이머만 정리
    clear(true);
  }, [clear]);

  // 마우스/터치 이벤트 바인딩 세트
  return useMemo(() => {
    const props = {
      onMouseDown: start,
      onTouchStart: start,
      onMouseUp: end,
      onMouseLeave: cancel,
      onTouchEnd: end,
      onTouchCancel: cancel,
    };

    if (preventContextMenu) {
      props.onContextMenu = (e) => e.preventDefault();
    }

    return props;
  }, [start, end, cancel, preventContextMenu]);
}
```

---

### 사용 예시

**파일 경로:** `src/App.js`

```javascript
import React, { useState } from 'react';
import useLongPress from './hooks/useLongPress';

export default function App() {
  const [logs, setLogs] = useState([]);

  const append = (msg) =>
    setLogs((prev) => [new Date().toLocaleTimeString() + ' ' + msg, ...prev]);

  const bind = useLongPress(
    () => append('길게 누르기 성공 → 액션 실행'),
    {
      delay: 700,
      onStart: () => append('누르기 시작'),
      onFinish: () => append('누르기 종료'),
      preventContextMenu: true,
    }
  );

  return (
    <div style={{ padding: 24 }}>
      <h1>useLongPress – 길게 누르기 감지</h1>

      <button
        {...bind}
        style={{
          padding: '12px 16px',
          borderRadius: 10,
          border: '1px solid #e5e7eb',
          background: '#111827',
          color: '#fff',
          cursor: 'pointer',
          userSelect: 'none',
        }}
      >
        이 버튼을 0.7초 이상 길게 누르세요
      </button>

      <ul style={{ marginTop: 16 }}>
        {logs.map((l, i) => (
          <li key={i} style={{ color: '#4b5563' }}>{l}</li>
        ))}
      </ul>
    </div>
  );
}
```

---

### 구현 포인트

* **타이머 기반 인식**: `setTimeout`으로 지연 후 콜백 실행, 중간에 손을 떼면 취소
* **마우스/터치 모두 지원**: `onMouseDown/Up/Leave`, `onTouchStart/End/Cancel`
* **컨텍스트 메뉴 방지**: 길게 누를 때 모바일 컨텍스트 메뉴가 뜨는 것을 옵션으로 차단
* **콜백 세분화**: 시작(`onStart`), 성공(`onLongPress`), 종료(`onFinish`)를 분리해 다양한 UX 연출 가능

---

다음은 **55번 `useDrag` – 드래그 상태 관리** 예제로 이어가겠습니다. 계속 진행할까요?
