좋습니다.
그럼 **React Hooks 시작하기 100제 – 58번 `useSwipe` (스와이프 감지)** 예제로 넘어가겠습니다.

---

## 58. `useSwipe` – 스와이프 감지

### 목적

* 터치/마우스 제스처로 **좌/우/상/하 스와이프**를 간단히 감지
* 캐러셀 넘김, 사이드 패널 열기/닫기, 카드 스택 등에서 활용

---

### 파일 경로: `src/hooks/useSwipe.js`

```javascript
import { useCallback, useMemo, useRef, useState } from 'react';

/**
 * useSwipe
 * 방향/거리/시간 기준으로 스와이프 제스처를 판정합니다.
 *
 * @param {object} options
 * @param {number} options.threshold=50   // 최소 이동 거리(px)
 * @param {number} options.restraint=40   // 수직(또는 수평) 허용 편차(px)
 * @param {number} options.allowedTime=500 // 허용 시간(ms) 내 이동해야 스와이프로 인정
 * @param {boolean} options.mouse=true    // 마우스 드래그도 스와이프로 처리할지
 * @param {(dir:'left'|'right'|'up'|'down', meta)=>void} options.onSwipe
 *
 * meta: { dx, dy, absX, absY, duration, startX, startY, endX, endY }
 */
export default function useSwipe(options = {}) {
  const {
    threshold = 50,
    restraint = 40,
    allowedTime = 500,
    mouse = true,
    onSwipe,
  } = options;

  const [direction, setDirection] = useState(null);
  const startRef = useRef({ x: 0, y: 0, t: 0 });
  const activeRef = useRef(false);

  const start = useCallback((x, y) => {
    activeRef.current = true;
    startRef.current = { x, y, t: Date.now() };
    setDirection(null);
  }, []);

  const move = useCallback(() => {
    // 필요 시 실시간 이동 처리 가능
  }, []);

  const end = useCallback((x, y) => {
    if (!activeRef.current) return;
    activeRef.current = false;

    const sx = startRef.current.x;
    const sy = startRef.current.y;
    const t0 = startRef.current.t;

    const dx = x - sx;
    const dy = y - sy;
    const absX = Math.abs(dx);
    const absY = Math.abs(dy);
    const duration = Date.now() - t0;

    let dir = null;

    if (duration <= allowedTime) {
      if (absX >= threshold && absY <= restraint) {
        dir = dx < 0 ? 'left' : 'right';
      } else if (absY >= threshold && absX <= restraint) {
        dir = dy < 0 ? 'up' : 'down';
      }
    }

    if (dir) {
      setDirection(dir);
      onSwipe?.(dir, { dx, dy, absX, absY, duration, startX: sx, startY: sy, endX: x, endY: y });
    }
  }, [allowedTime, threshold, restraint, onSwipe]);

  // 포인터 좌표 얻기
  const getXY = (e) => {
    if ('touches' in e && e.touches.length > 0) {
      return { x: e.touches[0].clientX, y: e.touches[0].clientY };
    }
    if ('changedTouches' in e && e.changedTouches.length > 0) {
      return { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };
    }
    return { x: e.clientX, y: e.clientY };
  };

  const onTouchStart = useCallback((e) => {
    const { x, y } = getXY(e);
    start(x, y);
  }, [start]);

  const onTouchMove = useCallback((e) => {
    move();
  }, [move]);

  const onTouchEnd = useCallback((e) => {
    const { x, y } = getXY(e);
    end(x, y);
  }, [end]);

  const onMouseDown = useCallback((e) => start(e.clientX, e.clientY), [start]);
  const onMouseMove = useCallback((e) => activeRef.current && move(), [move]);
  const onMouseUp = useCallback((e) => end(e.clientX, e.clientY), [end]);

  // 바인딩 세트
  const bind = useMemo(() => {
    const base = {
      onTouchStart,
      onTouchMove,
      onTouchEnd,
      onTouchCancel: onTouchEnd,
    };
    if (mouse) {
      return {
        ...base,
        onMouseDown,
        onMouseMove,
        onMouseUp,
      };
    }
    return base;
  }, [mouse, onTouchStart, onTouchMove, onTouchEnd, onMouseDown, onMouseMove, onMouseUp]);

  return { direction, bind };
}
```

---

### 사용 예시

**파일 경로:** `src/App.js`

```javascript
import React, { useState } from 'react';
import useSwipe from './hooks/useSwipe';

export default function App() {
  const [last, setLast] = useState('-');

  const { direction, bind } = useSwipe({
    threshold: 60,
    restraint: 50,
    allowedTime: 500,
    mouse: true,
    onSwipe: (dir, meta) => {
      setLast(`${dir} (dx:${Math.round(meta.dx)}, dy:${Math.round(meta.dy)})`);
    },
  });

  return (
    <div style={{ padding: 24 }}>
      <h1>useSwipe – 스와이프 감지</h1>

      <div
        {...bind}
        style={{
          height: 220,
          borderRadius: 12,
          border: '2px dashed #94a3b8',
          background: '#f8fafc',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          userSelect: 'none',
          touchAction: 'none',
        }}
      >
        이 영역을 스와이프하세요 (마우스 드래그도 가능)
      </div>

      <div style={{ marginTop: 12, color: '#334155' }}>
        <p>마지막 스와이프: <strong>{last}</strong></p>
        <p>실시간 판정 값: <code>{String(direction)}</code></p>
      </div>
    </div>
  );
}
```

---

### 구현/튜닝 포인트

* **threshold**: 최소 거리. 작게 할수록 민감해짐(오작동 증가 가능).
* **restraint**: 스와이프 축 이외 방향 허용 편차. 직선성 제어.
* **allowedTime**: 허용 시간 내에 이동해야 스와이프로 인정(느린 드래그는 제외).
* 마우스 지원이 필요 없으면 `mouse:false`.
* CSS에 `touch-action: none`을 지정해 브라우저 기본 제스처(스크롤/뒤로가기 스와이프)와의 충돌을 줄임.
* 캐러셀과 조합 시, `onSwipe('left'|'right')`를 슬라이드 이동 트리거로 연결하면 바로 활용 가능.

---

다음은 **59번 `useFocus` – 포커스 상태 관리** 또는 예정된 목록대로 **60번 `useMousePosition`** 중 어떤 것으로 이어갈까요?
