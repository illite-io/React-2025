좋습니다.
그럼 **React Hooks 시작하기 100제 – 48번 `useEffect` (비동기 요청 취소)** 예제로 넘어가겠습니다.

---

## 48. `useEffect` – 비동기 요청 취소

### 목적

* 검색/필터 입력이 빠르게 바뀔 때, **이전 fetch 요청을 취소**하여 레이스 컨디션과 불필요한 네트워크 낭비 방지
* `AbortController`를 사용해 `fetch`를 안전하게 취소하고, `useEffect`의 **클린업**에서 해제

---

### 파일 경로: `src/App.js`

```javascript
import React, { useEffect, useState } from 'react';

export default function App() {
  const [query, setQuery] = useState('react'); // 검색어
  const [results, setResults] = useState([]);
  const [loading, setLoading] = useState(false);
  const [errMsg, setErrMsg] = useState('');

  useEffect(() => {
    if (!query.trim()) {
      setResults([]);
      return;
    }

    const controller = new AbortController(); // 요청 취소용 컨트롤러
    const { signal } = controller;

    const fetchSearch = async () => {
      setLoading(true);
      setErrMsg('');
      try {
        // 데모용 공개 API (GitHub 검색)
        const url = `https://api.github.com/search/repositories?q=${encodeURIComponent(
          query
        )}&per_page=10`;
        const res = await fetch(url, { signal });

        if (!res.ok) {
          throw new Error(`HTTP ${res.status}`);
        }
        const json = await res.json();

        // signal.aborted 상태일 때는 결과 반영하지 않음
        if (!signal.aborted) {
          setResults(json.items ?? []);
        }
      } catch (err) {
        // 사용자가 취소한 경우는 에러 표시하지 않음
        if (err.name !== 'AbortError') {
          setErrMsg(String(err.message || err));
        }
      } finally {
        // 취소된 경우에도 로딩 해제
        if (!signal.aborted) {
          setLoading(false);
        }
      }
    };

    fetchSearch();

    // 의존성(query)이 바뀌거나 언마운트되면 이전 요청 취소
    return () => {
      controller.abort();
    };
  }, [query]);

  return (
    <div style={{ padding: 20 }}>
      <h1>useEffect – 비동기 요청 취소</h1>

      <input
        type="text"
        placeholder="레포지토리 검색어 입력"
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        style={{ padding: 8, width: '100%', maxWidth: 480 }}
      />

      {loading && <p>검색 중...</p>}
      {errMsg && <p style={{ color: 'crimson' }}>에러: {errMsg}</p>}

      <ul style={{ marginTop: 12 }}>
        {results.map((r) => (
          <li key={r.id}>
            <a href={r.html_url} target="_blank" rel="noreferrer">
              {r.full_name}
            </a>
            <span style={{ color: '#6b7280' }}> ★ {r.stargazers_count}</span>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

---

### 핵심 포인트

1. **`AbortController`로 요청 취소**

   ```javascript
   const controller = new AbortController();
   fetch(url, { signal: controller.signal });
   // 클린업에서
   controller.abort();
   ```

   * `useEffect`의 반환 함수에서 이전 요청을 취소해 레이스 컨디션 방지

2. **취소된 요청과 일반 에러 구분**

   ```javascript
   if (err.name !== 'AbortError') { setErrMsg(...); }
   ```

   * 사용자가 입력을 바꿔서 취소된 경우는 에러로 취급하지 않음

3. **로딩 상태 처리 주의**

   * 취소 직후에는 결과 반영을 생략해야 하므로 `signal.aborted` 체크로 이중 반영 방지

4. **디바운스와 병행 사용 가능**

   * 입력 변경이 매우 잦다면 `useDeferredValue`나 디바운스 훅(예: `useDebounce`)과 함께 사용하면 네트워크 트래픽을 더 줄일 수 있음

---

다음은 **49번 `useRef` – 캐러셀 구현** 예제로 이어가겠습니다. 계속 진행할까요?
