좋습니다.
그럼 **React Hooks 시작하기 100제 – 50번 `useLayoutEffect` (레이아웃 측정)** 예제로 넘어가겠습니다.

---

## 50. `useLayoutEffect` – 레이아웃 측정

### 목적

* DOM이 \*\*그려지기 직전(페인트 전)\*\*에 동기적으로 레이아웃(크기/위치)을 측정하고 상태를 반영
* 깜빡임 없이 정확한 레이아웃 기반 계산(예: 스켈레톤 높이 맞추기, 고정 헤더 오프셋 계산 등)

---

### 파일 경로: `src/hooks/useMeasure.js`

```javascript
import { useLayoutEffect, useRef, useState } from 'react';

/**
 * useMeasure
 * - 대상 요소의 크기/위치를 측정해 반환
 * - 첫 렌더 직후(페인트 전) 동기적으로 상태를 갱신해 FOUC를 줄임
 * - ResizeObserver 지원 시 크기 변경도 자동 추적
 *
 * @returns [ref, rect]
 *   - ref: 측정할 요소에 부착할 ref
 *   - rect: { width, height, top, left }
 */
export default function useMeasure() {
  const ref = useRef(null);
  const [rect, setRect] = useState({
    width: 0,
    height: 0,
    top: 0,
    left: 0,
  });

  // 초기 측정 + 의존 요소 변화 시 즉시 측정
  useLayoutEffect(() => {
    if (!ref.current) return;

    const measureNow = () => {
      const r = ref.current.getBoundingClientRect();
      setRect({
        width: Math.round(r.width),
        height: Math.round(r.height),
        top: Math.round(r.top + window.scrollY),
        left: Math.round(r.left + window.scrollX),
      });
    };

    // 1) 초기 동기 측정 (페인트 전)
    measureNow();

    // 2) ResizeObserver로 크기 변경 감지(지원 브라우저)
    let ro;
    if ('ResizeObserver' in window) {
      ro = new ResizeObserver(() => measureNow());
      ro.observe(ref.current);
    }

    // 3) 폰트 로딩·스크롤 등 외부 요인 보조
    window.addEventListener('scroll', measureNow, { passive: true });
    window.addEventListener('orientationchange', measureNow);
    window.addEventListener('load', measureNow);

    return () => {
      ro && ro.disconnect();
      window.removeEventListener('scroll', measureNow);
      window.removeEventListener('orientationchange', measureNow);
      window.removeEventListener('load', measureNow);
    };
  }, []);

  return [ref, rect];
}
```

---

### 파일 경로: `src/App.js`

```javascript
import React, { useState } from 'react';
import useMeasure from './hooks/useMeasure';

export default function App() {
  const [ref, rect] = useMeasure();
  const [content, setContent] = useState('이 박스의 크기와 위치를 측정합니다.');

  return (
    <div style={{ padding: 24, minHeight: '120vh', background: '#f8fafc' }}>
      <h1>useLayoutEffect – 레이아웃 측정</h1>

      <div
        ref={ref}
        style={{
          width: '60%',
          minWidth: 280,
          padding: 16,
          background: '#fff',
          border: '1px solid #e5e7eb',
          borderRadius: 12,
          boxShadow: '0 8px 24px rgba(0,0,0,0.08)',
          lineHeight: 1.6,
          transition: 'transform 120ms ease',
        }}
      >
        <strong>측정 대상 박스</strong>
        <p style={{ marginTop: 8 }}>{content}</p>
        <button onClick={() => setContent((s) => s + ' 더 긴 텍스트를 추가합니다.')}>
          내용 늘리기
        </button>
      </div>

      <div
        style={{
          marginTop: 16,
          padding: 12,
          background: '#eef2ff',
          border: '1px solid #c7d2fe',
          borderRadius: 10,
        }}
      >
        <strong>측정값(rect)</strong>
        <ul style={{ marginTop: 8 }}>
          <li>width: {rect.width}px</li>
          <li>height: {rect.height}px</li>
          <li>top(문서 기준): {rect.top}px</li>
          <li>left(문서 기준): {rect.left}px</li>
        </ul>
        <p style={{ marginTop: 6, color: '#475569' }}>
          스크롤/창 회전/내용 변경 시에도 값이 최신으로 유지됩니다.
        </p>
      </div>
    </div>
  );
}
```

---

### 핵심 포인트

* `useLayoutEffect`는 **페인트 전 실행** → `getBoundingClientRect()`로 측정 후 즉시 상태 반영하므로 깜빡임 최소화
* `ResizeObserver`로 크기 변화 자동 감지, 스크롤/회전/로드 이벤트로 보조 업데이트
* `top/left`는 문서 기준 좌표가 실무에서 유용해 `window.scrollY/X`를 더해 반환

---

다음은 **51번 `useKeyPress` – 키 입력 감지** 예제로 이어가겠습니다. 계속 진행할까요?
