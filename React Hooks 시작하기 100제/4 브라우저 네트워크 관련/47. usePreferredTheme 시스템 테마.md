좋습니다.
그럼 **React Hooks 시작하기 100제 – 47번 `useDeferredValue` (입력 지연 처리)** 예제로 넘어가겠습니다.

---

## 47. `useDeferredValue` – 입력 지연 처리

### 목적

* 사용자의 **빠른 입력**에 즉각 반응하면서, 무거운 연산/렌더링은 지연 처리
* 실시간 검색, 자동완성, 그래프 필터링 등에서 성능 최적화 가능
* `useTransition`과 달리, **값** 자체를 지연시켜 제공

---

### 파일 경로: `src/App.js`

```javascript
import React, { useState, useDeferredValue } from 'react';

export default function App() {
  const [input, setInput] = useState('');
  const deferredInput = useDeferredValue(input); // 지연된 값

  // 가짜 데이터 5000개
  const bigList = Array.from({ length: 5000 }, (_, i) => `아이템 ${i + 1}`);

  const filteredList = bigList.filter((item) =>
    item.toLowerCase().includes(deferredInput.toLowerCase())
  );

  return (
    <div style={{ padding: 20 }}>
      <h1>useDeferredValue – 입력 지연 처리</h1>
      <input
        type="text"
        placeholder="검색어 입력"
        value={input}
        onChange={(e) => setInput(e.target.value)}
        style={{ padding: 8, width: '100%', marginBottom: 12 }}
      />

      <p>
        즉시 값: <strong>{input}</strong> / 지연 값: <strong>{deferredInput}</strong>
      </p>

      <ul>
        {filteredList.map((item, idx) => (
          <li key={idx}>{item}</li>
        ))}
      </ul>
    </div>
  );
}
```

---

### 동작 설명

1. **즉시 값 vs 지연 값**

   * `input` → 사용자가 입력한 값 즉시 반영
   * `deferredInput` → React가 여유가 있을 때 업데이트
     (무거운 렌더링이 `input` 타이핑을 막지 않음)

2. **사용 사례**

   * 실시간 검색 결과 표시
   * 대규모 DOM 렌더링 최적화
   * 입력과 데이터 연산을 분리해 UX 개선

3. **`useTransition`과 차이**

   * `useTransition`: **상태 업데이트**를 지연
   * `useDeferredValue`: **값** 자체를 지연 제공

---

다음은 **48번 `usePrevious` – 이전 상태값 저장** 예제로 넘어가겠습니다.
계속 진행할까요?
