좋습니다.
그럼 **React Hooks 시작하기 100제 – 16번 `useCallback` (자식 컴포넌트 렌더링 최적화)** 예제로 넘어가겠습니다.

---

## 16. `useCallback` – 자식 컴포넌트 렌더링 최적화

### 목적

* 부모 컴포넌트의 상태 변경이 자식 컴포넌트의 불필요한 리렌더링을 유발하는 문제를 해결
* `useCallback` + `React.memo` 조합으로 최적화

---

### 파일 경로: `src/App.js`

```javascript
import React, { useState, useCallback } from 'react';

// 자식 컴포넌트
const TodoItem = React.memo(({ todo, onToggle }) => {
  console.log(`TodoItem 렌더링: ${todo.text}`);
  return (
    <li>
      <span
        style={{
          textDecoration: todo.completed ? 'line-through' : 'none',
          cursor: 'pointer'
        }}
        onClick={() => onToggle(todo.id)}
      >
        {todo.text}
      </span>
    </li>
  );
});

export default function App() {
  const [todos, setTodos] = useState([
    { id: 1, text: 'React 공부하기', completed: false },
    { id: 2, text: '운동하기', completed: false }
  ]);
  const [count, setCount] = useState(0);

  // useCallback으로 메모이제이션 → todos가 바뀔 때만 새 함수 생성
  const toggleTodo = useCallback((id) => {
    setTodos((prevTodos) =>
      prevTodos.map((todo) =>
        todo.id === id ? { ...todo, completed: !todo.completed } : todo
      )
    );
  }, []);

  return (
    <div style={{ padding: 20 }}>
      <h1>카운터: {count}</h1>
      <button onClick={() => setCount(count + 1)}>카운터 증가</button>

      <h2>Todo 리스트</h2>
      <ul>
        {todos.map((todo) => (
          <TodoItem key={todo.id} todo={todo} onToggle={toggleTodo} />
        ))}
      </ul>
    </div>
  );
}
```

---

### 코드 설명

1. **문제**

   * 부모의 다른 상태(`count`)가 변경되면 todos와 관련 없는 자식(`TodoItem`)도 리렌더링
   * 이유: 매번 새로운 `onToggle` 함수가 생성되어 props 변경으로 인식

2. **해결**

   ```javascript
   const toggleTodo = useCallback((id) => { ... }, []);
   ```

   * `useCallback`으로 감싸면 동일한 함수 객체를 재사용
   * `React.memo`가 props 변화가 없다고 판단 → 불필요한 렌더링 방지

3. **의존성 배열 주의**

   * 상태를 직접 참조하면 의존성에 포함시켜야 함
   * 위 예제는 `setTodos` 함수형 업데이트를 사용했기 때문에 의존성 배열이 `[]` 가능

---

다음은 **17번 `useMemo` – 계산 결과 메모이제이션** 예제로 넘어가겠습니다.
계속 진행할까요?
