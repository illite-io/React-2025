좋습니다.
그럼 **React Hooks 시작하기 100제 – 17번 `useMemo` (계산 결과 메모이제이션)** 예제로 넘어가겠습니다.

---

## 17. `useMemo` – 계산 결과 메모이제이션

### 목적

* 비용이 큰 계산(정렬, 필터, 집계 등)을 **입력값이 변할 때만** 다시 계산하여 렌더링 성능 최적화

---

### 파일 경로: `src/App.js`

```javascript
import React, { useMemo, useState } from 'react';

// 비용이 큰 연산을 흉내 내는 함수 (의도적으로 지연)
function heavySum(numbers) {
  // 큰 반복으로 CPU 연산을 유발 (데모용)
  let total = 0;
  for (let i = 0; i < 10_000_00; i++) {
    total += i % 10;
  }
  // 실제 합 계산
  return numbers.reduce((acc, n) => acc + n, 0) + total;
}

export default function App() {
  const [numbers, setNumbers] = useState([1, 2, 3]);
  const [text, setText] = useState('');

  // useMemo 없을 때: 렌더링마다 heavySum 실행 → 느려짐
  // useMemo 사용: numbers가 바뀔 때만 재계산
  const memoizedSum = useMemo(() => {
    return heavySum(numbers);
  }, [numbers]);

  const addNumber = () => {
    const next = Math.floor(Math.random() * 100);
    setNumbers((prev) => [...prev, next]);
  };

  return (
    <div style={{ padding: 20 }}>
      <h1>useMemo – 계산 결과 메모이제이션</h1>

      <section style={{ marginBottom: 16 }}>
        <h2>입력 배열</h2>
        <p>numbers: [{numbers.join(', ')}]</p>
        <button onClick={addNumber}>난수 추가</button>
      </section>

      <section style={{ marginBottom: 16 }}>
        <h2>무거운 합계</h2>
        <p>합계(heavySum + 데모용 오버헤드): {memoizedSum}</p>
        <small>numbers가 바뀔 때만 heavySum을 다시 계산합니다.</small>
      </section>

      <section>
        <h2>관계없는 state</h2>
        <input
          value={text}
          placeholder="여기에 타이핑해보세요"
          onChange={(e) => setText(e.target.value)}
        />
        <p>text: {text}</p>
        <small>
          텍스트만 바뀌면 <code>memoizedSum</code>은 재계산되지 않습니다.
        </small>
      </section>
    </div>
  );
}
```

---

### 코드 설명

1. **비용 큰 계산을 메모이제이션**

   ```javascript
   const memoized = useMemo(() => heavySum(numbers), [numbers]);
   ```

   * `numbers`가 변하지 않으면 이전 계산값을 재사용 → 렌더링 가벼움

2. **언제 `useMemo`를 쓰나**

   * 정렬/필터/집계/복잡한 파생 데이터 생성 등 **CPU 부담이 있는 계산**
   * 계산 결과를 **props로 자식에 전달**해 불필요한 리렌더링을 막고 싶을 때

3. **주의점**

   * **모든 계산에 과도하게 사용 X**: 관리 비용이 성능 이득보다 크면 오히려 역효과
   * 의존성 배열은 **계산에 사용되는 값만** 넣기
   * 함수 내부에서 외부 변수를 캡처하면 그 변수도 의존성에 반영

---

다음은 **18번 `useMemo` – 무거운 연산 최적화 (필터/정렬 실전)** 예제로 이어가겠습니다. 계속 진행할게요.
