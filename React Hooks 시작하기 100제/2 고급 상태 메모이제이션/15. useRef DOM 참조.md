좋습니다.
그럼 **React Hooks 시작하기 100제 – 15번 `useCallback` (함수 메모이제이션)** 예제로 넘어가겠습니다.

---

## 15. `useCallback` – 함수 메모이제이션

### 목적

* 컴포넌트가 리렌더링될 때 **같은 함수 객체를 재사용**해 불필요한 자식 컴포넌트 리렌더링 방지
* 특히, **props로 함수를 전달**할 때 유용

---

### 파일 경로: `src/App.js`

```javascript
import React, { useState, useCallback } from 'react';

// 자식 컴포넌트
const Child = React.memo(({ onClick }) => {
  console.log('Child 렌더링');
  return <button onClick={onClick}>자식 버튼 클릭</button>;
});

export default function App() {
  const [count, setCount] = useState(0);

  // useCallback으로 함수 메모이제이션
  const handleClick = useCallback(() => {
    console.log('자식 버튼 클릭됨');
  }, []); // 의존성 배열이 비면 컴포넌트 마운트 시 1회 생성

  return (
    <div style={{ padding: 20 }}>
      <h1>카운터: {count}</h1>
      <button onClick={() => setCount(count + 1)}>+1</button>

      {/* Child에 함수 전달 */}
      <Child onClick={handleClick} />
    </div>
  );
}
```

---

### 코드 설명

1. **문제 상황**

   * 부모가 리렌더링되면 **새로운 함수 객체**가 생성되어 자식도 리렌더링됨
   * 불필요한 렌더링 발생

2. **해결: `useCallback` 사용**

   ```javascript
   const handleClick = useCallback(() => { ... }, []);
   ```

   * 의존성 배열이 비어 있으면 **항상 같은 함수 객체 재사용**
   * 자식에서 `React.memo`를 사용하면 props가 바뀌지 않는 한 재렌더링 안 함

3. **활용 예**

   * 이벤트 핸들러, API 호출 함수, 필터 함수 등을 자식에 전달할 때

---

다음은 **16번 `useCallback` – 자식 컴포넌트 렌더링 최적화** 예제로 넘어가겠습니다.
계속 진행할까요?
