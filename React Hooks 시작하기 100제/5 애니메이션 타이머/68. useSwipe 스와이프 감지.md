좋습니다.
그럼 **React Hooks 시작하기 100제 – 68번 `useMutationObserver` (DOM 변경 감지)** 예제로 넘어가겠습니다.
(37번에서 `useOnClickOutside`를 이미 다뤘으므로, 중복을 피해 DOM 변화 감지 훅을 진행합니다.)

---

## 68. `useMutationObserver` – DOM 변경 감지

### 목적

* 자식 노드 추가/삭제, 텍스트 변경, 속성 변화 등 **DOM 변화**를 관찰
* 외부 스크립트가 DOM을 수정하는 경우, 변경사항에 반응해 UI/상태를 동기화

---

### 파일 경로: `src/hooks/useMutationObserver.js`

```javascript
import { useEffect, useRef } from 'react';

/**
 * useMutationObserver
 * @param {React.RefObject<Node>} targetRef 관찰 대상 요소 ref
 * @param {MutationCallback} callback 변경 발생 시 호출 (entries, observer)
 * @param {MutationObserverInit} options MutationObserver 옵션
 */
export default function useMutationObserver(targetRef, callback, options) {
  const callbackRef = useRef(callback);
  callbackRef.current = callback;

  useEffect(() => {
    const node = targetRef.current;
    if (!node) return;

    const observer = new MutationObserver((entries, obs) => {
      callbackRef.current?.(entries, obs);
    });

    observer.observe(
      node,
      options || {
        childList: true,
        subtree: true,
        characterData: true,
        attributes: true,
      }
    );

    return () => observer.disconnect();
  }, [targetRef, options]);
}
```

---

### 사용 예시

**파일 경로:** `src/App.js`

```javascript
import React, { useEffect, useRef, useState } from 'react';
import useMutationObserver from './hooks/useMutationObserver';

export default function App() {
  const boxRef = useRef(null);
  const [log, setLog] = useState([]);

  const push = (msg) =>
    setLog((prev) => [new Date().toLocaleTimeString() + ' ' + msg, ...prev].slice(0, 6));

  useMutationObserver(
    boxRef,
    (entries) => {
      for (const e of entries) {
        if (e.type === 'childList') {
          if (e.addedNodes.length) push(`자식 추가: ${e.addedNodes.length}개`);
          if (e.removedNodes.length) push(`자식 제거: ${e.removedNodes.length}개`);
        }
        if (e.type === 'attributes') {
          push(`속성 변경: ${e.attributeName}`);
        }
        if (e.type === 'characterData') {
          push(`텍스트 변경`);
        }
      }
    },
    {
      childList: true,
      subtree: true,
      attributes: true,
      characterData: true,
    }
  );

  // 데모용: 1초마다 자식 노드 토글
  useEffect(() => {
    const id = setInterval(() => {
      const el = boxRef.current;
      if (!el) return;
      if (el.querySelector('.dyn')) el.querySelector('.dyn').remove();
      else {
        const p = document.createElement('p');
        p.className = 'dyn';
        p.textContent = '동적으로 추가된 노드';
        el.appendChild(p);
      }
    }, 1000);
    return () => clearInterval(id);
  }, []);

  return (
    <div style={{ padding: 24 }}>
      <h1>useMutationObserver – DOM 변경 감지</h1>

      <div
        ref={boxRef}
        style={{
          border: '1px solid #e5e7eb',
          borderRadius: 8,
          padding: 12,
          minHeight: 80,
          background: '#fff',
        }}
      >
        <strong data-role="label">관찰 대상</strong>
      </div>

      <div style={{ marginTop: 12, background: '#f8fafc', padding: 12, borderRadius: 8 }}>
        <strong>최근 이벤트</strong>
        <ul style={{ marginTop: 8, color: '#475569' }}>
          {log.map((l, i) => (
            <li key={i}>{l}</li>
          ))}
        </ul>
      </div>
    </div>
  );
}
```

---

### 핵심 포인트

* `MutationObserver`는 **DOM 변화 이벤트 스트림**을 제공하므로, 외부 요인(서드파티 위젯, 마크다운 렌더러 등)에 반응하기 좋음
* `options`로 감지 범위를 세밀하게 제어: `childList`, `attributes`, `characterData`, `subtree`
* 콜백 최신성을 유지하려고 내부에서 `callbackRef`로 래핑
* 과도한 관찰은 비용이 크므로 **필요한 범위만** 켜두고, 컴포넌트 언마운트 시 `disconnect()`로 정리

---

다음은 **69번 `useEventListener` – 안전한 이벤트 리스너 훅** 예제로 이어가겠습니다. 계속 진행할까요?
