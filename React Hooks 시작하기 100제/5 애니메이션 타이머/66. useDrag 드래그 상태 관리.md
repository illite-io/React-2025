좋습니다.
그럼 **React Hooks 시작하기 100제 – 66번 `useElementSize` (ResizeObserver 기반 요소 크기 추적)** 예제로 넘어가겠습니다.
(참고: 38번에서 윈도우 크기를 다뤘으므로, 이번에는 특정 DOM 요소의 크기를 추적합니다.)

---

## 66. `useElementSize` – 요소 크기 추적 (ResizeObserver)

### 목적

* 특정 DOM 요소의 `width/height`가 변할 때마다 즉시 상태 업데이트
* 반응형 카드, 가변 콘텐츠(이미지/텍스트) 레이아웃, 캔버스 리사이징 등에 활용

---

### 파일 경로: `src/hooks/useElementSize.js`

```javascript
import { useCallback, useLayoutEffect, useRef, useState } from 'react';

/**
 * useElementSize
 * @returns {[callbackRef, size]}
 *  - callbackRef: 측정 대상 요소에 붙일 ref (콜백 ref)
 *  - size: { width, height }
 */
export default function useElementSize() {
  const nodeRef = useRef(null);
  const [size, setSize] = useState({ width: 0, height: 0 });

  // 콜백 ref: 마운트/언마운트 시점에 관찰자 연결/해제
  const ref = useCallback((node) => {
    if (nodeRef.current === node) return;
    nodeRef.current = node;
  }, []);

  useLayoutEffect(() => {
    const el = nodeRef.current;
    if (!el) return;

    // 초기 측정
    const measure = () => {
      const r = el.getBoundingClientRect();
      setSize({ width: Math.round(r.width), height: Math.round(r.height) });
    };
    measure();

    // ResizeObserver로 크기 변화 감지
    let ro;
    if ('ResizeObserver' in window) {
      ro = new ResizeObserver(() => measure());
      ro.observe(el);
    } else {
      // 폴백: 윈도우 리사이즈에만 반응
      window.addEventListener('resize', measure);
    }

    return () => {
      ro ? ro.disconnect() : window.removeEventListener('resize', measure);
    };
  }, [nodeRef.current]); // 콜백 ref가 가리키는 노드 변경 시 재바인딩

  return [ref, size];
}
```

---

### 사용 예시

**파일 경로:** `src/App.js`

```javascript
import React, { useState } from 'react';
import useElementSize from './hooks/useElementSize';

export default function App() {
  const [ref, size] = useElementSize();
  const [text, setText] = useState('이 영역의 크기를 실시간으로 추적합니다.');

  return (
    <div style={{ padding: 24 }}>
      <h1>useElementSize – 요소 크기 추적</h1>

      <textarea
        rows={3}
        value={text}
        onChange={(e) => setText(e.target.value)}
        style={{ width: '100%', maxWidth: 640, marginBottom: 12 }}
      />

      <div
        ref={ref}
        style={{
          resize: 'both',
          overflow: 'auto',
          width: '60%',
          minWidth: 260,
          minHeight: 120,
          padding: 16,
          border: '1px solid #e5e7eb',
          borderRadius: 10,
          background: '#fff',
        }}
      >
        <strong>대상 박스</strong>
        <p style={{ marginTop: 8 }}>{text}</p>
        <p style={{ color: '#64748b' }}>오른쪽 하단을 드래그하여 크기를 바꿔보세요.</p>
      </div>

      <div style={{ marginTop: 12, background: '#f1f5f9', padding: 12, borderRadius: 8 }}>
        <span>현재 크기 → </span>
        <strong>{size.width} × {size.height}px</strong>
      </div>
    </div>
  );
}
```

---

### 핵심 포인트

* **콜백 ref**를 사용하면 대상 노드 교체 시 자동으로 옵저버를 재연결
* `ResizeObserver`가 지원되지 않는 환경을 위해 **윈도우 리사이즈 폴백** 제공
* `useLayoutEffect`로 초기 측정 타이밍을 앞당겨 레이아웃 깜빡임 최소화
* 스크롤/폰트 로딩 등 외부 요인으로 인한 잦은 호출에 대비해, 필요한 경우 결과를 **쓰로틀/디바운스**(65/64번 훅)와 조합 가능

---

다음은 **67번 `useIntersectionObserver` – 뷰포트 진입/이탈 감지(무한 스크롤 트리거)** 예제로 이어가겠습니다. 계속 진행할까요?
