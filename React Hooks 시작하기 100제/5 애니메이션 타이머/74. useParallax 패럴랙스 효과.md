좋습니다.
**React Hooks 시작하기 100제 – 74번 `usePrevious` (고급: 변경 시에만 저장·히스토리 지원)** 예제로 넘어가겠습니다.
(36번 기본 버전을 확장해 실전 옵션을 추가합니다.)

---

## 74. `usePrevious` – 고급 버전

### 목적

* 값이 **실제로 바뀔 때만** 이전 값을 저장하거나,
* **히스토리**(과거 N개 값)까지 보관하고,
* **커스텀 비교 함수**로 동일성 판단을 제어

---

### 파일 경로: `src/hooks/usePreviousEx.js`

```javascript
import { useEffect, useRef } from 'react';

/**
 * usePreviousEx
 * @param {any} value             추적할 값
 * @param {object} [options]
 * @param {(a:any,b:any)=>boolean} [options.isEqual] 같음 비교(기본: Object.is)
 * @param {number} [options.history=1] 보관할 과거 개수(1이면 직전 값만)
 * @returns {{
 *   prev: any | undefined,   // 직전 값
 *   history: any[],           // 오래된→최신 순서의 히스토리(길이<=history)
 *   changed: boolean          // 이번 렌더에서 값이 변했는가
 * }}
 */
export default function usePreviousEx(value, { isEqual = Object.is, history = 1 } = {}) {
  const lastRef = useRef();
  const historyRef = useRef([]);

  const changed = !isEqual(lastRef.current, value);

  useEffect(() => {
    if (!changed) return;
    // 직전 값을 히스토리에 밀어넣고 길이 제한
    if (history > 0) {
      const next = historyRef.current.concat(
        lastRef.current !== undefined ? [lastRef.current] : []
      );
      if (next.length > history) next.splice(0, next.length - history);
      historyRef.current = next;
    }
    lastRef.current = value;
  }, [value, changed, history]);

  return {
    prev: historyRef.current.length ? historyRef.current[historyRef.current.length - 1] : lastRef.current,
    history: historyRef.current.slice(), // 방어적 복사
    changed
  };
}
```

---

### 사용 예시

**파일 경로:** `src/App.js`

```javascript
import React, { useMemo, useState } from 'react';
import usePreviousEx from './hooks/usePreviousEx';

const shallowEqual = (a, b) => {
  if (Object.is(a, b)) return true;
  if (typeof a !== 'object' || typeof b !== 'object' || !a || !b) return false;
  const ak = Object.keys(a), bk = Object.keys(b);
  if (ak.length !== bk.length) return false;
  for (const k of ak) if (!Object.is(a[k], b[k])) return false;
  return true;
};

export default function App() {
  const [profile, setProfile] = useState({ name: 'kim', age: 20 });

  // 얕은 비교 + 히스토리 3개 보관
  const { prev, history, changed } = usePreviousEx(profile, {
    isEqual: shallowEqual,
    history: 3
  });

  const bumpAge = () => setProfile(p => ({ ...p, age: p.age + 1 }));
  const sameRefNoChange = () => setProfile(p => ({ ...p })); // 값 동일 → changed=false
  const rename = () => setProfile(p => ({ ...p, name: p.name === 'kim' ? 'lee' : 'kim' }));

  const summary = useMemo(() => ({
    current: profile,
    prev,
    history,
    changed
  }), [profile, prev, history, changed]);

  return (
    <div style={{ padding: 24 }}>
      <h1>usePrevious (고급) – 변경 시만 저장 · 히스토리</h1>

      <div style={{ display: 'flex', gap: 8, marginBottom: 12 }}>
        <button onClick={bumpAge}>나이 +1</button>
        <button onClick={rename}>이름 토글</button>
        <button onClick={sameRefNoChange}>동일 값 설정(변경 없음)</button>
      </div>

      <pre style={{ background: '#f8fafc', padding: 12, borderRadius: 8 }}>
{JSON.stringify(summary, null, 2)}
      </pre>
    </div>
  );
}
```

---

### 핵심 포인트

* `isEqual` 옵션으로 “같음”의 기준을 커스터마이즈

  * 원시값: 기본 `Object.is`로 충분
  * 객체: 얕은 비교(shallow)나 키 서브셋 비교로 불필요한 “변경” 판정 방지
* `history` 개수로 과거 값을 N개까지 보관해 **되돌리기(undo)**·변경 추이를 UI에 표시 가능
* `changed` 플래그로 이번 렌더에서 값이 실제로 달라졌는지 즉시 분기 가능

---

다음은 **75번 `useTimeout` – 타임아웃 제어(취소 가능)** 예제로 이어가겠습니다. 계속 진행할까요?
