좋습니다.
그럼 **React Hooks 시작하기 100제 – 72번 `useLockBodyScroll` (바디 스크롤 잠금)** 예제로 넘어가겠습니다.

---

## 72. `useLockBodyScroll` – 바디 스크롤 잠금

### 목적

* 모달/사이드패널이 열렸을 때 **배경 문서 스크롤을 잠가** 스크롤 점프·이탈을 방지
* 모바일에서 주소창 높이 변화로 인한 **레이아웃 튐**을 줄이기 위해 body 폭 고정 처리

---

### 파일 경로: `src/hooks/useLockBodyScroll.js`

```javascript
import { useEffect } from 'react';

/**
 * useLockBodyScroll
 * @param {boolean} locked - true면 body 스크롤 잠금, false면 해제
 * @param {HTMLElement} [root=document.documentElement] - 스크롤 잠글 루트(기본 html/body)
 */
export default function useLockBodyScroll(locked, root = typeof document !== 'undefined' ? document.documentElement : undefined) {
  useEffect(() => {
    if (!root) return;

    // 현재 스크롤바 너비 계산 → 레이아웃 밀림 방지용 패딩
    const hasScrollbar = () => {
      const doc = document.documentElement;
      return doc.scrollHeight > doc.clientHeight;
    };

    // 기존 스타일 백업
    const prevOverflow = root.style.overflow;
    const prevPaddingRight = document.body.style.paddingRight;

    if (locked) {
      const scrollbarWidth = hasScrollbar() ? window.innerWidth - document.documentElement.clientWidth : 0;
      root.style.overflow = 'hidden';
      // 배경이 고정될 때 수직 스크롤바가 사라지면 콘텐츠가 오른쪽으로 튀므로 보정
      if (scrollbarWidth > 0) {
        document.body.style.paddingRight = `${scrollbarWidth}px`;
      }
    } else {
      root.style.overflow = prevOverflow || '';
      document.body.style.paddingRight = prevPaddingRight || '';
    }

    // 언마운트/상태 전환 시 복원
    return () => {
      root.style.overflow = prevOverflow || '';
      document.body.style.paddingRight = prevPaddingRight || '';
    };
  }, [locked, root]);
}
```

---

### 사용 예시 – 모달 열릴 때 잠금

**파일 경로:** `src/App.js`

```javascript
import React, { useState } from 'react';
import useLockBodyScroll from './hooks/useLockBodyScroll';

function Modal({ open, onClose }) {
  useLockBodyScroll(open); // 열릴 때 스크롤 잠금

  if (!open) return null;
  return (
    <div
      onClick={onClose}
      style={{
        position: 'fixed', inset: 0, background: 'rgba(0,0,0,0.4)',
        display: 'flex', alignItems: 'center', justifyContent: 'center'
      }}
    >
      <div
        onClick={(e) => e.stopPropagation()}
        style={{
          width: 420, maxWidth: '90vw', background: '#fff', borderRadius: 12,
          padding: 20, boxShadow: '0 20px 60px rgba(0,0,0,0.25)'
        }}
      >
        <h2>모달</h2>
        <p>모달이 열린 동안 배경 스크롤이 잠깁니다.</p>
        <button onClick={onClose}>닫기</button>
      </div>
    </div>
  );
}

export default function App() {
  const [open, setOpen] = useState(false);

  return (
    <div style={{ padding: 24, minHeight: '200vh' }}>
      <h1>useLockBodyScroll – 바디 스크롤 잠금</h1>
      <p>스크롤을 아래로 내려본 후 모달을 열어보세요. 배경 스크롤이 멈춥니다.</p>
      <button onClick={() => setOpen(true)}>모달 열기</button>
      <Modal open={open} onClose={() => setOpen(false)} />
    </div>
  );
}
```

---

### 구현 포인트

* 스크롤 잠금 시 스크롤바가 사라져 **콘텐츠가 좌우로 흔들리는 것**을 `padding-right`로 보정
* 기본 대상은 `document.documentElement`(html). 특정 스크롤 컨테이너를 잠그려면 두 번째 인자로 해당 요소 전달
* 여러 컴포넌트에서 동시에 잠글 수 있는 상황이라면, ref-count(잠금 카운트)를 도입해 마지막 해제 때만 풀도록 확장 가능

---

다음은 **73번 `usePrefersReducedMotion` – 사용자의 모션 축소 선호 감지** 예제로 이어가겠습니다. 계속 진행할까요?
