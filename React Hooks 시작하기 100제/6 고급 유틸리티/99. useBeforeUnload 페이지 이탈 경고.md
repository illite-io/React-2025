좋습니다.
그럼 **React Hooks 시작하기 100제 – 99번 `useBeforeUnload` (페이지 이탈 경고)** 예제로 넘어가겠습니다.
(70번에서 `usePageVisibility`를 다뤘으므로, 중복을 피해 “이탈 방지/경고” 훅을 구현합니다.)

---

## 99. `useBeforeUnload` – 페이지 이탈(새로고침/닫기/다른 URL 이동) 경고

### 목적

* 저장되지 않은 변경사항이 있을 때 사용자에게 **이탈 경고**를 표시
* 폼/에디터/캔버스 등에서 실수로 작업을 잃지 않도록 보호

---

### 파일 경로: `src/hooks/useBeforeUnload.js`

```javascript
import { useEffect } from 'react';

/**
 * useBeforeUnload
 * @param {boolean} enabled - true면 beforeunload 경고 활성화
 * @param {string}  [message] - 일부 브라우저에서 무시되지만, 표준 메시지 자리에 사용
 */
export default function useBeforeUnload(enabled, message = '변경사항이 저장되지 않을 수 있습니다.') {
  useEffect(() => {
    if (!enabled) return;

    const handler = (e) => {
      // 대부분의 최신 브라우저는 커스텀 텍스트를 무시하고 기본 문구를 표시
      e.preventDefault();
      e.returnValue = message;
      return message;
    };

    window.addEventListener('beforeunload', handler);

    // SPA 내부 라우팅 이탈도 막고 싶다면 추가: (선택)
    const onClick = (e) => {
      // a[href] 클릭 시 확인 (Ctrl/Meta+클릭, target=_blank 등은 제외)
      const a = e.target?.closest?.('a[href]');
      if (!a) return;
      const isNewTab = a.target === '_blank' || e.metaKey || e.ctrlKey;
      const isSameOrigin = a.origin === window.location.origin;
      if (!isNewTab && isSameOrigin) {
        const ok = window.confirm(message);
        if (!ok) {
          e.preventDefault();
          e.stopPropagation();
        }
      }
    };

    document.addEventListener('click', onClick);

    return () => {
      window.removeEventListener('beforeunload', handler);
      document.removeEventListener('click', onClick);
    };
  }, [enabled, message]);
}
```

---

### 사용 예시 – 폼이 수정됐을 때만 경고

**파일 경로:** `src/App.js`

```javascript
import React, { useEffect, useState } from 'react';
import useBeforeUnload from './hooks/useBeforeUnload';

export default function App() {
  const [value, setValue] = useState('');
  const [dirty, setDirty] = useState(false);

  useEffect(() => {
    setDirty(value.trim().length > 0);
  }, [value]);

  useBeforeUnload(dirty, '작성 중인 내용이 사라질 수 있습니다. 나가시겠습니까?');

  return (
    <div style={{ padding: 24 }}>
      <h1>useBeforeUnload – 이탈 경고</h1>
      <textarea
        value={value}
        onChange={(e) => setValue(e.target.value)}
        placeholder="내용을 입력하면 이탈 시 경고가 표시됩니다."
        style={{ width: '100%', height: 140 }}
      />
      <div style={{ marginTop: 8 }}>
        <button onClick={() => setValue('')}>초기화</button>
        <span style={{ marginLeft: 8, color: '#475569' }}>
          상태: {dirty ? '수정됨' : '깨끗함'}
        </span>
      </div>
    </div>
  );
}
```

---

### 구현 포인트

* `beforeunload`는 **브라우저 기본 다이얼로그**를 띄우며, 커스텀 문구는 대부분 무시됨
* SPA 내부 링크 이탈도 막고 싶다면 선택적으로 `click` 가드(확인창)를 추가
* 너무 공격적으로 경고하면 UX가 나빠지므로, **dirty 상태**일 때만 활성화 권장
* 모바일/일부 브라우저는 동작이 제한될 수 있음

---

다음은 마지막으로 **100번 `useHotkeys` – 다중 단축키 매핑/스코프 관리**로 마무리하겠습니다. 계속 진행할까요?
