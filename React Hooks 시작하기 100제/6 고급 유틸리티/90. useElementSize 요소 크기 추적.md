좋습니다.
그럼 **React Hooks 시작하기 100제 – 90번 `useScrollPosition` (스크롤 위치/방향 추적)** 예제로 넘어가겠습니다.
(38번 윈도우 크기, 65번 쓰로틀링을 활용해 스크롤 상태를 효율적으로 관리합니다.)

---

## 90. `useScrollPosition` – 스크롤 위치/방향 추적

### 목적

* 현재 스크롤 위치(`x`, `y`)와 **스크롤 방향**(up/down/left/right/idle)을 상태로 제공
* 헤더 숨김/노출, 무한스크롤 트리거, “맨 위로” 버튼 표시 등에 활용

---

### 파일 경로: `src/hooks/useScrollPosition.js`

```javascript
import { useEffect, useRef, useState } from 'react';

/**
 * useScrollPosition
 * @param {Object} [options]
 * @param {Element|Window} [options.target=window] 감지 대상 스크롤 컨테이너
 * @param {number} [options.throttleMs=100] 이벤트 처리 간격(ms)
 * @param {number} [options.directionThreshold=4] 방향 판정 최소 이동(px)
 * @returns {{
 *   x: number,
 *   y: number,
 *   direction: 'up'|'down'|'left'|'right'|'idle'
 * }}
 */
export default function useScrollPosition({
  target = typeof window !== 'undefined' ? window : undefined,
  throttleMs = 100,
  directionThreshold = 4,
} = {}) {
  const [pos, setPos] = useState({ x: 0, y: 0, direction: 'idle' });
  const lastRef = useRef({ x: 0, y: 0, t: 0 });
  const rafRef = useRef(null);
  const tickingRef = useRef(false);

  useEffect(() => {
    if (!target || !target.addEventListener) return;

    // 현재 좌표 읽기 (window vs element)
    const readXY = () => {
      if (target === window) {
        return { x: window.scrollX, y: window.scrollY };
      }
      const el = /** @type {Element} */ (target);
      return { x: el.scrollLeft, y: el.scrollTop };
    };

    // 쓰로틀링 + rAF 결합
    const onScroll = () => {
      const now = Date.now();
      if (now - lastRef.current.t < throttleMs) return;
      lastRef.current.t = now;

      if (tickingRef.current) return;
      tickingRef.current = true;
      rafRef.current = requestAnimationFrame(() => {
        tickingRef.current = false;
        const { x, y } = readXY();
        const { x: px, y: py } = lastRef.current;

        // 방향 판정
        const dx = x - px;
        const dy = y - py;
        let direction = 'idle';
        if (Math.abs(dy) >= Math.abs(dx)) {
          if (Math.abs(dy) >= directionThreshold) {
            direction = dy > 0 ? 'down' : 'up';
          }
        } else {
          if (Math.abs(dx) >= directionThreshold) {
            direction = dx > 0 ? 'right' : 'left';
          }
        }

        lastRef.current = { x, y, t: now };
        setPos({ x, y, direction });
      });
    };

    // 초기값 동기화
    const { x, y } = (function init() {
      const v = readXY();
      lastRef.current = { x: v.x, y: v.y, t: Date.now() };
      setPos({ x: v.x, y: v.y, direction: 'idle' });
      return v;
    })();

    target.addEventListener('scroll', onScroll, { passive: true });

    return () => {
      target.removeEventListener('scroll', onScroll);
      if (rafRef.current) cancelAnimationFrame(rafRef.current);
    };
  }, [target, throttleMs, directionThreshold]);

  return pos;
}
```

---

### 사용 예시 – 헤더 자동 숨김/노출

**파일 경로:** `src/App.js`

```javascript
import React, { useRef } from 'react';
import useScrollPosition from './hooks/useScrollPosition';

export default function App() {
  const listRef = useRef(null);
  // 특정 스크롤 컨테이너를 감지하려면 target에 ref.current 전달
  const { y, direction } = useScrollPosition({ target: window, throttleMs: 120 });

  const headerHidden = direction === 'down' && y > 40;

  return (
    <div style={{ minHeight: '200vh' }}>
      <header
        style={{
          position: 'sticky',
          top: 0,
          transition: 'transform 160ms ease',
          transform: headerHidden ? 'translateY(-100%)' : 'translateY(0)',
          background: '#111827',
          color: '#fff',
          padding: '12px 16px',
          zIndex: 10,
        }}
      >
        스크롤 방향: {direction} / Y: {Math.round(y)}
      </header>

      <main ref={listRef} style={{ padding: 24 }}>
        <h1>useScrollPosition – 스크롤 위치/방향 추적</h1>
        <p>아래로 스크롤하면 헤더가 숨겨지고, 위로 스크롤하면 다시 나타납니다.</p>
        {[...Array(50)].map((_, i) => (
          <p key={i} style={{ borderBottom: '1px solid #e5e7eb', padding: '12px 0' }}>
            콘텐츠 라인 {i + 1}
          </p>
        ))}
      </main>
    </div>
  );
}
```

---

### 구현 포인트

* `window`뿐 아니라 **임의의 스크롤 컨테이너**를 `target`으로 지원
* rAF + 간단 쓰로틀로 **부하를 줄이면서** 스크롤 상태를 부드럽게 반영
* `directionThreshold`로 미세 흔들림을 필터링
* 헤더 숨김/노출, “맨 위로” 버튼, 섹션 하이라이트(현재 섹션 추적) 등과 결합 용이

---

다음은 **91번 `useScrollToTop` – 조건부 맨 위로 버튼/스크롤** 예제로 이어가겠습니다. 계속 진행할까요?
