좋습니다.
그럼 **React Hooks 시작하기 100제 – 86번 `useUndoRedo` (되돌리기 / 다시하기 스택)** 예제로 넘어가겠습니다.

---

## 86. `useUndoRedo` – 상태 이력 관리 (Undo / Redo)

### 목적

* 상태 변경 이력을 저장하고, **되돌리기(Undo)** 와 **다시하기(Redo)** 기능 제공
* 텍스트 에디터, 그림판, 폼 입력 이력, 디자인 툴 등에 활용 가능
* `useState`와 배열 스택 로직으로 구현

---

### 파일 경로: `src/hooks/useUndoRedo.js`

```javascript
import { useState, useCallback } from 'react';

/**
 * useUndoRedo
 * @param {*} initialState - 초기 상태 값
 * @returns {{
 *   state: any,             // 현재 상태
 *   set: Function,          // 상태 변경
 *   undo: Function,         // 이전 상태로 되돌리기
 *   redo: Function,         // 다음 상태로 복원
 *   canUndo: boolean,       // 되돌리기 가능 여부
 *   canRedo: boolean        // 다시하기 가능 여부
 * }}
 */
export default function useUndoRedo(initialState) {
  const [past, setPast] = useState([]); // 과거 상태들
  const [present, setPresent] = useState(initialState); // 현재 상태
  const [future, setFuture] = useState([]); // 되돌린 이후 상태들

  const set = useCallback((newState) => {
    setPast((prev) => [...prev, present]);
    setPresent(newState);
    setFuture([]); // 새로운 상태 변경 시 미래 이력 삭제
  }, [present]);

  const undo = useCallback(() => {
    if (past.length === 0) return;
    const previous = past[past.length - 1];
    setPast((prev) => prev.slice(0, prev.length - 1));
    setFuture((next) => [present, ...next]);
    setPresent(previous);
  }, [past, present]);

  const redo = useCallback(() => {
    if (future.length === 0) return;
    const next = future[0];
    setFuture((prev) => prev.slice(1));
    setPast((prev) => [...prev, present]);
    setPresent(next);
  }, [future, present]);

  return {
    state: present,
    set,
    undo,
    redo,
    canUndo: past.length > 0,
    canRedo: future.length > 0
  };
}
```

---

### 사용 예시 – 간단한 텍스트 에디터

**파일 경로:** `src/App.js`

```javascript
import React from 'react';
import useUndoRedo from './hooks/useUndoRedo';

export default function App() {
  const { state, set, undo, redo, canUndo, canRedo } = useUndoRedo('');

  return (
    <div style={{ padding: 24 }}>
      <h1>useUndoRedo – 되돌리기 / 다시하기</h1>
      <textarea
        value={state}
        onChange={(e) => set(e.target.value)}
        placeholder="여기에 입력하세요..."
        style={{ width: '100%', height: 120, marginBottom: 12 }}
      />
      <div>
        <button onClick={undo} disabled={!canUndo}>되돌리기</button>
        <button onClick={redo} disabled={!canRedo}>다시하기</button>
      </div>
      <p>현재 값: {state}</p>
    </div>
  );
}
```

---

### 구현 포인트

* **past / present / future** 3개의 상태로 Undo/Redo 관리
* 새로운 값 입력 시 future를 삭제하여 이력 꼬임 방지
* 객체나 배열 상태도 관리 가능 (단, 불변성 유지 필수)
* 입력 폼, 캔버스 그림판, 코드 에디터, 드래그 앤 드롭 작업 등 다양하게 응용 가능

---

다음은 **87번 `useLocalStorageState` – 로컬 스토리지 동기화 상태** 예제로 진행할까요?
이 훅은 새로고침해도 데이터가 유지되는 기능을 만듭니다.
