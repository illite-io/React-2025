좋습니다.
그럼 **React Hooks 시작하기 100제 – 82번 `useFullscreen` (전체화면 모드 제어)** 예제로 넘어가겠습니다.

---

## 82. `useFullscreen` – 전체화면 모드 제어

### 목적

* 특정 DOM 요소를 **전체화면으로 전환/해제/토글**
* 전체화면 상태 변화를 **실시간 추적**
* 동영상 플레이어, 이미지 뷰어, 차트, 프레젠테이션에 활용

---

### 파일 경로: `src/hooks/useFullscreen.js`

```javascript
import { useCallback, useEffect, useRef, useState } from 'react';

/**
 * useFullscreen
 * @returns {{
 *   ref: (node: HTMLElement|null) => void, // 전체화면 대상 요소에 연결할 ref
 *   isFullscreen: boolean,                 // 현재 전체화면 여부
 *   enter: () => Promise<boolean>,         // 전체화면 진입
 *   exit: () => Promise<boolean>,          // 전체화면 종료
 *   toggle: () => Promise<boolean>,        // 상태에 따른 토글
 *   error: string | null                   // 최근 에러 메시지
 * }}
 */
export default function useFullscreen() {
  const nodeRef = useRef(null);
  const [isFullscreen, setIsFullscreen] = useState(false);
  const [error, setError] = useState(null);

  // 대상 요소 연결용 콜백 ref
  const ref = useCallback((node) => {
    nodeRef.current = node || null;
  }, []);

  // 현재 문서의 전체화면 요소 얻기 (브라우저 차이 최소화)
  const getFsElement = () =>
    document.fullscreenElement ||
    document.webkitFullscreenElement ||
    document.mozFullScreenElement ||
    document.msFullscreenElement ||
    null;

  const request = async (el) => {
    try {
      setError(null);
      if (!el) throw new Error('대상 요소가 없습니다.');
      const req =
        el.requestFullscreen ||
        el.webkitRequestFullscreen ||
        el.mozRequestFullScreen ||
        el.msRequestFullscreen;
      if (!req) throw new Error('전체화면 API를 지원하지 않습니다.');
      const p = req.call(el);
      if (p && typeof p.then === 'function') await p;
      return true;
    } catch (e) {
      setError(e?.message || String(e));
      return false;
    }
  };

  const exitFs = async () => {
    try {
      setError(null);
      const exit =
        document.exitFullscreen ||
        document.webkitExitFullscreen ||
        document.mozCancelFullScreen ||
        document.msExitFullscreen;
      if (!exit) throw new Error('전체화면 종료 API를 지원하지 않습니다.');
      const p = exit.call(document);
      if (p && typeof p.then === 'function') await p;
      return true;
    } catch (e) {
      setError(e?.message || String(e));
      return false;
    }
  };

  const enter = useCallback(async () => {
    if (getFsElement()) return true; // 이미 전체화면
    return request(nodeRef.current);
  }, []);

  const exit = useCallback(async () => {
    if (!getFsElement()) return true; // 이미 해제됨
    return exitFs();
  }, []);

  const toggle = useCallback(async () => {
    const el = getFsElement();
    return el ? exitFs() : request(nodeRef.current);
  }, []);

  // 상태 동기화: fullscreenchange 이벤트 감지
  useEffect(() => {
    const sync = () => setIsFullscreen(!!getFsElement());

    ['fullscreenchange', 'webkitfullscreenchange', 'mozfullscreenchange', 'MSFullscreenChange']
      .forEach((evt) => document.addEventListener(evt, sync));
    // 초기 동기화
    sync();

    return () => {
      ['fullscreenchange', 'webkitfullscreenchange', 'mozfullscreenchange', 'MSFullscreenChange']
        .forEach((evt) => document.removeEventListener(evt, sync));
    };
  }, []);

  return { ref, isFullscreen, enter, exit, toggle, error };
}
```

---

### 사용 예시

**파일 경로:** `src/App.js`

```javascript
import React, { useRef } from 'react';
import useFullscreen from './hooks/useFullscreen';

export default function App() {
  const { ref, isFullscreen, enter, exit, toggle, error } = useFullscreen();
  const videoRef = useRef(null);

  return (
    <div style={{ padding: 24 }}>
      <h1>useFullscreen – 전체화면 제어</h1>

      <div
        ref={ref}
        style={{
          position: 'relative',
          width: 'min(720px, 100%)',
          background: '#0b1020',
          borderRadius: 12,
          overflow: 'hidden',
          border: '1px solid #1f2937'
        }}
      >
        <video
          ref={videoRef}
          controls
          style={{ width: '100%', display: 'block' }}
          src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4"
        />
        <div style={{ position: 'absolute', right: 8, bottom: 8, display: 'flex', gap: 6 }}>
          <button onClick={enter}>전체화면</button>
          <button onClick={exit}>종료</button>
          <button onClick={toggle}>{isFullscreen ? '토글: 종료' : '토글: 진입'}</button>
        </div>
      </div>

      <p style={{ marginTop: 8 }}>
        상태: <strong>{isFullscreen ? '전체화면' : '일반'}</strong>
      </p>
      {error && <p style={{ color: 'crimson' }}>에러: {error}</p>}
    </div>
  );
}
```

---

### 구현 포인트

* 브라우저 간 벤더 프리픽스(`webkit`, `moz`, `ms`)에 대응
* `fullscreenchange` 이벤트로 상태를 동기화해 버튼/레이아웃을 즉시 갱신
* 전체화면 대상으로 **특정 요소**를 지정하려면 그 요소에 `ref`를 부착
* 전체화면 진입은 사용자 제스처(클릭 등) 직후에만 허용되는 경우가 많음

### 주의 사항

* iOS Safari는 과거에 비디오 요소만 네이티브 전체화면을 지원하거나 동작 제약이 있었습니다. 최신 버전에선 요소 전체화면이 점진적으로 개선되었지만, 환경별 동작 편차를 고려해 폴백 UI(줌 레이아웃 등)를 준비하는 것이 안전합니다.
* 전체화면 중 스타일은 뷰포트가 바뀐 것으로 간주되므로, `position: fixed` 요소나 리사이즈 연동 로직이 있다면 재계산을 권장합니다.

---

다음은 **83번 `useClipboardFiles` – 파일을 클립보드에서 붙여넣기 읽기** 또는 **84번 `useSelection` – 텍스트 선택 영역 추적** 중 어떤 것으로 이어갈까요?
