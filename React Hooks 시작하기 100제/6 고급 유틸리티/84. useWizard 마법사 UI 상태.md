좋습니다.
그럼 **React Hooks 시작하기 100제 – 84번 `useSelection` (텍스트 선택 영역 추적)** 예제로 넘어가겠습니다.

---

## 84. `useSelection` – 텍스트 선택 영역 추적

### 목적

* 사용자가 드래그로 선택한 **텍스트/범위/좌표**를 추적
* 인라인 퀵툴바(복사/강조/주석), 사전 검색, 컨텍스트 메뉴 표시 등에 활용

---

### 파일 경로: `src/hooks/useSelection.js`

```javascript
import { useCallback, useEffect, useState } from 'react';

/**
 * useSelection
 * @param {HTMLElement | Document} [root=document] 관찰 대상(문서 전체 또는 특정 컨테이너)
 * @returns {{
 *   text: string,                          // 선택된 텍스트
 *   rect: {top:number,left:number,width:number,height:number} | null, // 선택 경계 박스(뷰포트 기준)
 *   range: Range | null,                   // 현재 선택 Range
 *   clear: () => void                      // 선택 해제
 * }}
 */
export default function useSelection(root = typeof document !== 'undefined' ? document : undefined) {
  const [text, setText] = useState('');
  const [rect, setRect] = useState(null);
  const [range, setRange] = useState(null);

  const readSelection = useCallback(() => {
    if (!root || !window.getSelection) return;

    const sel = window.getSelection();
    if (!sel || sel.rangeCount === 0 || String(sel).trim() === '') {
      setText('');
      setRect(null);
      setRange(null);
      return;
    }

    // 첫 번째 Range 기준 (멀티 셀렉션 미지원 브라우저가 많음)
    const r = sel.getRangeAt(0);
    const textValue = sel.toString();
    let box = null;

    // getBoundingClientRect가 0일 수 있어 getClientRects 폴백
    const br = r.getBoundingClientRect?.();
    if (br && (br.width || br.height)) {
      box = { top: br.top, left: br.left, width: br.width, height: br.height };
    } else {
      const cr = r.getClientRects?.();
      if (cr && cr.length > 0) {
        const first = cr[0];
        box = { top: first.top, left: first.left, width: first.width, height: first.height };
      }
    }

    setText(textValue);
    setRect(box);
    setRange(r.cloneRange());
  }, [root]);

  const clear = useCallback(() => {
    if (!window.getSelection) return;
    const sel = window.getSelection();
    sel?.removeAllRanges();
    setText('');
    setRect(null);
    setRange(null);
  }, []);

  useEffect(() => {
    if (!root?.addEventListener) return;

    // 마우스/키보드로 선택이 완료되는 타이밍에 동기화
    const events = ['mouseup', 'keyup', 'selectionchange', 'touchend'];
    const handler = () => readSelection();

    events.forEach((e) => root.addEventListener(e, handler));
    return () => {
      events.forEach((e) => root.removeEventListener(e, handler));
    };
  }, [root, readSelection]);

  return { text, rect, range, clear };
}
```

---

### 사용 예시 – 선택 시 퀵 툴바 표시

**파일 경로:** `src/App.js`

```javascript
import React, { useEffect, useRef, useState } from 'react';
import useSelection from './hooks/useSelection';

function QuickToolbar({ rect, onCopy, onClear }) {
  if (!rect) return null;
  const style = {
    position: 'fixed',
    top: Math.max(8, rect.top - 40),
    left: rect.left,
    transform: 'translateX(-0%)',
    background: '#111827',
    color: '#fff',
    borderRadius: 6,
    padding: '6px 8px',
    fontSize: 12,
    display: 'flex',
    gap: 6,
    boxShadow: '0 10px 24px rgba(0,0,0,0.15)',
    zIndex: 1000,
  };
  return (
    <div style={style}>
      <button onClick={onCopy} style={{ color: '#fff' }}>복사</button>
      <button onClick={onClear} style={{ color: '#fff' }}>선택 해제</button>
    </div>
  );
}

export default function App() {
  const containerRef = useRef(null);
  const { text, rect, clear } = useSelection(document); // 문서 전체 감지
  const [lastCopied, setLastCopied] = useState('');

  useEffect(() => {
    // 선택이 갱신될 때 퀵툴바가 재배치됨
  }, [rect, text]);

  const copySelected = async () => {
    if (text) {
      try {
        await navigator.clipboard.writeText(text);
        setLastCopied(text.slice(0, 80));
        clear();
      } catch {
        // 권한 문제 등으로 실패할 수 있음
      }
    }
  };

  return (
    <div ref={containerRef} style={{ padding: 24, lineHeight: 1.7 }}>
      <h1>useSelection – 텍스트 선택 추적</h1>
      <p>
        문단 일부를 드래그로 선택하면 상단에 퀵툴바가 나타납니다. 복사 또는 선택 해제를 눌러보세요.
        이 훅은 선택 텍스트, Range, 선택 영역의 뷰포트 좌표(rect)를 제공합니다.
      </p>
      <p>
        Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer ut orci at erat
        facilisis ultrices. Suspendisse potenti. Sed non lectus a justo auctor luctus. Cras
        gravida, dui a dictum hendrerit, libero purus rhoncus leo, vitae fringilla erat lacus
        et mi.
      </p>

      <QuickToolbar rect={rect} onCopy={copySelected} onClear={clear} />

      {lastCopied && (
        <div style={{ marginTop: 12, padding: 10, background: '#f1f5f9', borderRadius: 8 }}>
          마지막 복사: <code>{lastCopied}{text && text.length > 80 ? '…' : ''}</code>
        </div>
      )}
    </div>
  );
}
```

---

### 구현 포인트

* `selectionchange`는 자주 발생하므로 필요한 경우 디바운싱(64번 `useDebounce`)을 조합
* 일부 브라우저/폰트에서는 `getBoundingClientRect`가 빈 박스를 반환할 수 있어 `getClientRects` 폴백 제공
* 컨테이너 내부만 추적하려면 `useSelection(containerEl)`처럼 특정 엘리먼트를 전달
* 도큐먼트 스크롤과 함께 퀵툴바가 자연스럽게 따라오도록 **뷰포트 좌표**를 그대로 사용

---

다음은 **85번 `useClipboardImage` – 캔버스/이미지 클립보드 복사** 또는 **86번 `useUndoRedo` – 되돌리기/다시하기 스택** 중 어떤 것으로 이어갈까요?
