좋습니다.
그럼 **React Hooks 시작하기 100제 – 22번 `useLayoutEffect` (DOM 변경 직후 실행)** 예제로 넘어가겠습니다.

---

## 22. `useLayoutEffect` – DOM 변경 직후 실행

### 목적

* DOM이 변경된 **직후**에 동기적으로 실행되는 Hook
* `useEffect`는 비동기로 실행되지만, `useLayoutEffect`는 레이아웃 계산 전에 실행됨
* DOM 크기, 위치 측정이나 스타일 계산이 필요한 경우 유용

---

### 파일 경로: `src/App.js`

```javascript
import React, { useState, useRef, useLayoutEffect } from 'react';

export default function App() {
  const [width, setWidth] = useState(0);
  const boxRef = useRef(null);

  useLayoutEffect(() => {
    if (boxRef.current) {
      // DOM 요소의 실제 렌더링 크기 읽기
      const rect = boxRef.current.getBoundingClientRect();
      setWidth(rect.width);
      console.log('useLayoutEffect 실행:', rect.width);
    }
  }, []);

  return (
    <div style={{ padding: 20 }}>
      <h1>useLayoutEffect 예제</h1>
      <div
        ref={boxRef}
        style={{
          width: '50%',
          height: 100,
          backgroundColor: 'lightblue',
          resize: 'horizontal',
          overflow: 'auto'
        }}
      >
        박스 영역
      </div>
      <p>박스의 너비: {width}px</p>
    </div>
  );
}
```

---

### 코드 설명

1. **실행 시점 차이**

   * `useEffect`: 브라우저가 화면을 그린 **후** 실행 (비동기)
   * `useLayoutEffect`: 브라우저가 화면을 그리기 **직전** 실행 (동기)

2. **활용 예**

   * DOM 크기 측정 (`getBoundingClientRect`)
   * 스크롤 위치 조정
   * 애니메이션 초기 위치 설정

3. **주의사항**

   * 동기 실행이므로 너무 무거운 작업은 UI 블로킹 가능
   * 대부분은 `useEffect`로 충분하고, 정말 필요한 경우에만 사용

---

다음은 **23번 `useDebugValue` – 커스텀 Hook 디버깅** 예제로 넘어가겠습니다.
바로 진행할까요?
