좋습니다.
그럼 **React Hooks 시작하기 100제 – 30번 `useEffect` (타이머 사용 및 정리)** 예제로 넘어가겠습니다.

---

## 30. `useEffect` – 타이머 사용 및 정리

### 목적

* `setInterval`, `setTimeout` 같은 타이머를 안전하게 사용하고 해제
* 컴포넌트가 사라질 때 타이머 정리로 메모리 누수 방지

---

### 파일 경로: `src/App.js`

```javascript
import React, { useState, useEffect } from 'react';

export default function App() {
  const [count, setCount] = useState(0);
  const [running, setRunning] = useState(false);

  useEffect(() => {
    if (!running) return; // 동작 중일 때만 실행

    console.log('타이머 시작');
    const timerId = setInterval(() => {
      setCount((prev) => prev + 1);
    }, 1000);

    // 클린업: 언마운트되거나 running이 false로 바뀌면 타이머 해제
    return () => {
      clearInterval(timerId);
      console.log('타이머 정리');
    };
  }, [running]);

  return (
    <div style={{ padding: 20 }}>
      <h1>useEffect – 타이머 사용 및 정리</h1>
      <p>카운트: {count}</p>
      <button onClick={() => setRunning(true)}>시작</button>
      <button onClick={() => setRunning(false)}>정지</button>
      <button onClick={() => setCount(0)}>초기화</button>
    </div>
  );
}
```

---

### 코드 설명

1. **타이머 생성**

   ```javascript
   const timerId = setInterval(() => {
     setCount((prev) => prev + 1);
   }, 1000);
   ```

   * 매 1초마다 `count` 증가
   * 함수형 업데이트 사용 → 의존성 배열에 `count` 불필요

2. **클린업 필수**

   ```javascript
   return () => clearInterval(timerId);
   ```

   * 타이머를 해제하지 않으면 계속 동작
   * 언마운트 시나 의존성 값 변경 시 반드시 정리

3. **활용 예**

   * 시계, 카운트다운, 슬라이드 쇼
   * API 폴링(주기적 데이터 요청)

---

다음은 **31번 `useToggle` – 불리언 값 토글** 예제로 넘어가겠습니다.
계속 진행할까요?
