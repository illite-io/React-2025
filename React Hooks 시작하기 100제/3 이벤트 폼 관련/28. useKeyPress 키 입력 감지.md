좋습니다.
그럼 **React Hooks 시작하기 100제 – 28번 `useInsertionEffect` (스타일 삽입 타이밍 제어)** 예제로 넘어가겠습니다.

---

## 28. `useInsertionEffect` – 스타일 삽입 타이밍 제어

### 목적

* DOM **변경 전에** 스타일을 삽입해 FOUC(스타일 깜빡임) 최소화
* 주 사용처: **CSS-in-JS** 라이브러리에서 런타임 스타일을 주입할 때
* 실행 순서: `useInsertionEffect` → DOM 변경 → `useLayoutEffect` → 그 후 `useEffect`

---

### 파일 경로: `src/App.js`

```javascript
import React, { useState, useRef, useInsertionEffect, useLayoutEffect } from 'react';

/**
 * StyleInjector
 * - 전달받은 CSS 문자열을 <style> 엘리먼트로 head에 삽입
 * - useInsertionEffect로 DOM 변경 전에 스타일을 먼저 준비 → FOUC 방지
 */
function StyleInjector({ cssText }) {
  const styleRef = useRef(null);

  // 1) 스타일 엘리먼트를 head에 보장 (DOM 붙이기 자체는 동기로 안전)
  useLayoutEffect(() => {
    if (!styleRef.current) {
      const styleEl = document.createElement('style');
      styleEl.setAttribute('data-app-style', 'dynamic');
      document.head.appendChild(styleEl);
      styleRef.current = styleEl;
    }
    return () => {
      if (styleRef.current) {
        styleRef.current.remove();
        styleRef.current = null;
      }
    };
  }, []);

  // 2) CSS 텍스트 삽입: DOM 변경(페인트) 전에 실행되어 깜빡임 최소화
  useInsertionEffect(() => {
    if (styleRef.current) {
      styleRef.current.textContent = cssText;
    }
  }, [cssText]);

  return null; // 실제로 렌더링할 UI 없음
}

export default function App() {
  const [theme, setTheme] = useState('light');

  const cssText =
    theme === 'light'
      ? `
      :root { --bg: #ffffff; --fg: #111111; --card: #f5f5f5; }
      `
      : `
      :root { --bg: #0f1115; --fg: #e6e6e6; --card: #191b22; }
      `;

  return (
    <div style={{ minHeight: '100vh' }}>
      {/* DOM 변경 전에 스타일을 먼저 삽입 */}
      <StyleInjector cssText={cssText} />

      <main
        style={{
          background: 'var(--bg)',
          color: 'var(--fg)',
          minHeight: '100vh',
          padding: 24,
          transition: 'background 120ms ease, color 120ms ease',
        }}
      >
        <h1>useInsertionEffect – 런타임 스타일 주입</h1>
        <p>테마가 바뀔 때 스타일이 먼저 삽입되어 화면 깜빡임을 줄입니다.</p>

        <button
          onClick={() => setTheme((t) => (t === 'light' ? 'dark' : 'light'))}
          style={{
            padding: '8px 12px',
            borderRadius: 8,
            border: '1px solid var(--fg)',
            background: 'transparent',
            color: 'var(--fg)',
            cursor: 'pointer',
          }}
        >
          테마 전환 ({theme})
        </button>

        <section
          style={{
            marginTop: 16,
            padding: 16,
            borderRadius: 12,
            background: 'var(--card)',
          }}
        >
          <h2>카드 섹션</h2>
          <p>CSS 변수로 색상을 제어합니다.</p>
        </section>
      </main>
    </div>
  );
}
```

---

### 코드 설명

1. **왜 `useInsertionEffect`인가**

   * 런타임에서 **CSS 텍스트를 생성/갱신**해야 할 때, DOM 페인트 전에 스타일을 주입해 깜빡임을 줄임
   * CSS-in-JS 라이브러리가 내부적으로 사용하는 패턴을 순수 React로 재현

2. **`useInsertionEffect` vs `useLayoutEffect` vs `useEffect`**

   * `useInsertionEffect`: DOM 변경 전에 실행 → 스타일 삽입 타이밍 보장
   * `useLayoutEffect`: DOM 변경 직후(페인트 전) 동기 실행 → 레이아웃 측정/조정
   * `useEffect`: 페인트 후 비동기 실행 → UI 확정 이후 부수효과

3. **주의사항**

   * 일반 앱 로직에 남용 금지. **스타일 시스템**을 구현하거나 CSS-in-JS 내부에서만 사용 권장
   * 서버 렌더링 시에는 스타일 선반영(SSR 스타일 태그) 전략과 함께 고려

---

다음은 **29번 `useEffect` – 이벤트 리스너 등록/해제** 예제로 이어가겠습니다.
계속 진행할까요?
