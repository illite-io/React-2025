

# 4장. 집약과 자르기

## 4-1. 집약(집계, Aggregation)

SQL에서 집계 함수는 데이터를 그룹별로 합산·평균·최대·최소 등을 계산할 때 사용됩니다.

대표 집계 함수

* `COUNT(*)` → 행 개수
* `SUM(컬럼)` → 합계
* `AVG(컬럼)` → 평균
* `MAX(컬럼)` / `MIN(컬럼)` → 최댓값 / 최솟값

---

### 예제 1: 고객별 총 주문액

```sql
SELECT customer_id, SUM(total_amount) AS total_sum
FROM orders
GROUP BY customer_id;
-- 주석:
-- GROUP BY로 customer_id별로 묶고 SUM으로 합계 계산
```

---

### 예제 2: 상태별 주문 수

```sql
SELECT status, COUNT(*) AS order_count
FROM orders
GROUP BY status;
-- 주석:
-- status 값(PAID, SHIP, CANCEL)별 주문 건수
```

---

### 예제 3: 조건 집계

```sql
SELECT
  COUNT(*) AS total_orders,
  SUM(CASE WHEN status = 'PAID' THEN 1 ELSE 0 END) AS paid_orders,
  SUM(CASE WHEN status = 'SHIP' THEN 1 ELSE 0 END) AS shipped_orders
FROM orders;
-- 주석:
-- 조건에 맞는 건만 합산하여 별도의 통계 컬럼 생성
```

---

### 예제 4: 집계 + HAVING

```sql
SELECT customer_id, SUM(total_amount) AS total_sum
FROM orders
GROUP BY customer_id
HAVING SUM(total_amount) >= 1000;
-- 주석:
-- GROUP BY 결과에 조건(HAVING)을 걸어 1000 이상인 고객만 표시
```

---

## 4-2. 자르기(데이터 페이징, LIMIT/OFFSET)

대량 데이터에서 일부만 조회할 때 자르기(Paging)를 사용합니다.

---

### 예제 5: LIMIT (상위 N개)

```sql
SELECT *
FROM orders
ORDER BY total_amount DESC
LIMIT 5;
-- 주석:
-- 금액 기준 상위 5건만 표시
```

---

### 예제 6: LIMIT + OFFSET (페이지네이션)

```sql
-- 2페이지(페이지당 5건) 조회
SELECT *
FROM orders
ORDER BY order_date DESC
LIMIT 5 OFFSET 5;
-- 주석:
-- OFFSET은 시작 행 건너뛰기
-- LIMIT은 가져올 건수
```

---

### 예제 7: 효율적인 페이징 (Keyset Pagination)

```sql
-- OFFSET은 데이터가 많아질수록 느려질 수 있음 → Keyset 방식
-- 최근 주문 5건을 가져오되, 마지막 주문일 기준으로 그 이후만 가져오기
SELECT *
FROM orders
WHERE order_date < DATE '2025-06-30'
ORDER BY order_date DESC
LIMIT 5;
-- 주석:
-- "마지막 기준값"을 WHERE로 제한하여 불필요한 스캔 방지
```

---

### 예제 8: GROUP BY + LIMIT 조합

```sql
-- 고객별 주문 합계 상위 3명
SELECT customer_id, SUM(total_amount) AS total_sum
FROM orders
GROUP BY customer_id
ORDER BY total_sum DESC
LIMIT 3;
```

---

## 4-3. 주의할 점

* `LIMIT`/`OFFSET`은 간단하지만, 데이터가 많을수록 느려질 수 있음 → Keyset 방식 고려
* `GROUP BY` 시 불필요한 컬럼 포함 시 성능 저하 가능 → 필요한 컬럼만
* 집계에 조건을 여러 번 걸면 반복 스캔이 일어날 수 있으니 `CASE`로 묶어서 처리

---

## 요약

* 집계 함수와 `GROUP BY`를 활용하면 다양한 통계 데이터를 한 번에 계산 가능
* `HAVING`은 그룹화된 결과에 조건 적용
* 페이징 시 `LIMIT`/`OFFSET`은 간단하지만 성능 한계 존재 → Keyset 방식 활용 추천
