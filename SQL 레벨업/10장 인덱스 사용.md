
# 10장. 인덱스 사용

## 10-1. 인덱스와 B-tree

대부분의 RDBMS에서 기본 인덱스는 **B-tree** 구조입니다.

* 데이터는 **정렬된 형태**로 저장
* **루트 → 브랜치 → 리프** 노드로 탐색
* `O(log N)` 속도로 검색 가능
* 범위 검색, 정렬된 순회가 효율적

---

### 예제 1: 인덱스 생성

```sql
CREATE INDEX idx_orders_customer_date
ON orders(customer_id, order_date);
-- 주석:
-- customer_id → order_date 순으로 정렬된 인덱스
-- WHERE customer_id=... AND order_date BETWEEN ... 쿼리에 유리
```

---

### 예제 2: 실행 계획에서 인덱스 확인

```sql
EXPLAIN ANALYZE
SELECT *
FROM orders
WHERE customer_id = 1
  AND order_date >= DATE '2025-06-01';
-- 주석:
-- Index Scan 또는 Index Range Scan이면 인덱스를 사용 중
```

---

## 10-2. 인덱스를 잘 활용하려면

1. **선행 컬럼 활용**

   * 복합 인덱스의 첫 번째 컬럼부터 조건을 걸어야 효율적

2. **함수/연산 피하기**

   ```sql
   -- 나쁜 예: 인덱스 무시 가능성
   WHERE TO_CHAR(order_date, 'YYYY-MM') = '2025-06'

   -- 좋은 예:
   WHERE order_date >= DATE '2025-06-01'
     AND order_date < DATE '2025-07-01'
   ```

3. **선택도 높은 컬럼 먼저**

   * 조건으로 걸었을 때 걸러지는 데이터 비율이 높은 컬럼이 앞에 오도록

4. **커버링 인덱스 사용**

   * 쿼리에서 필요한 컬럼을 모두 인덱스에 포함시키면 테이블 접근 없이 처리 가능

---

### 예제 3: 커버링 인덱스

```sql
CREATE INDEX idx_orders_cov
ON orders(customer_id, order_date, status);

EXPLAIN ANALYZE
SELECT customer_id, order_date, status
FROM orders
WHERE customer_id = 1
ORDER BY order_date DESC;
-- 주석:
-- 필요한 컬럼이 전부 인덱스에 있으므로 Index Only Scan 가능
```

---

## 10-3. 인덱스로 성능 향상이 어려운 경우

* **데이터가 너무 작음** → 인덱스보다 Full Scan이 더 빠를 수 있음
* **선택도가 낮음** → 예: 성별(M/F)처럼 값이 몇 개 안 되는 컬럼
* **인덱스 파편화** → 데이터 변경이 잦으면 재구성 필요 (REINDEX)

---

## 10-4. 인덱스를 사용할 수 없는 경우 대처법

1. **조건을 인덱스 친화적으로 변경**

   * 함수/형변환 제거
2. **필요하다면 새로운 인덱스 생성**
3. **다른 접근 경로 고려** (JOIN, 서브쿼리, 통계 테이블)

---

### 예제 4: 함수 제거 전/후 비교

```sql
-- 인덱스 사용 어려움
WHERE LOWER(name) = 'alice'

-- 개선: 컬럼에 함수 적용 대신 값 가공
WHERE name = 'Alice'
```

---

### 예제 5: 부분 인덱스 (PostgreSQL)

```sql
CREATE INDEX idx_paid_orders
ON orders(order_date)
WHERE status = 'PAID';
-- 주석:
-- 조건부 인덱스로 특정 조건 쿼리를 빠르게
```

---

## 요약

* 인덱스는 B-tree 구조가 기본, 빠른 검색·정렬에 강점
* 복합 인덱스는 **선행 컬럼 조건**을 맞춰야 함
* 함수/형변환은 인덱스 사용을 막을 수 있음
* 선택도 낮거나 데이터가 적으면 효과 제한
* 조건부 인덱스, 커버링 인덱스 등으로 최적화 가능

