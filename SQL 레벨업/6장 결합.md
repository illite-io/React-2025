
# 6장. 결합(Join)

## 6-1. 기능적 관점으로 구분하는 결합의 종류

SQL에서 **JOIN**은 여러 테이블의 데이터를 결합하는 기능입니다.
기본적인 종류는 다음과 같습니다.

| JOIN 종류         | 설명                                                     |
| --------------- | ------------------------------------------------------ |
| INNER JOIN      | 양쪽 테이블 모두에서 조건에 맞는 행만 반환                               |
| LEFT JOIN       | 왼쪽 테이블은 모두 반환, 오른쪽은 조건 맞는 것만                           |
| RIGHT JOIN      | 오른쪽 테이블은 모두 반환, 왼쪽은 조건 맞는 것만                           |
| FULL OUTER JOIN | 양쪽 모두 포함 (PostgreSQL, Oracle 지원 / MySQL 8.0은 직접 구현 필요) |
| CROSS JOIN      | 모든 조합(곱집합) 생성                                          |

---

### 예제 1: INNER JOIN

```sql
SELECT o.order_id, c.name, o.total_amount
FROM orders o
INNER JOIN customers c ON o.customer_id = c.customer_id;
-- 주석:
-- 주문에 해당 고객이 있는 경우만 출력
```

---

### 예제 2: LEFT JOIN

```sql
SELECT c.name, o.order_id
FROM customers c
LEFT JOIN orders o ON c.customer_id = o.customer_id;
-- 주석:
-- 주문이 없는 고객도 NULL로 표시되어 나타남
```

---

### 예제 3: RIGHT JOIN

```sql
SELECT o.order_id, c.name
FROM orders o
RIGHT JOIN customers c ON o.customer_id = c.customer_id;
-- 주석:
-- MySQL/PostgreSQL에서 지원, 거의 LEFT JOIN과 같은 용도지만 방향 반대
```

---

### 예제 4: FULL OUTER JOIN (PostgreSQL)

```sql
SELECT c.name, o.order_id
FROM customers c
FULL OUTER JOIN orders o ON c.customer_id = o.customer_id;
-- 주석:
-- 양쪽 테이블에서 조건 불일치 행도 모두 표시
```

---

### 예제 5: CROSS JOIN

```sql
SELECT c.name, p.name
FROM customers c
CROSS JOIN products p;
-- 주석:
-- 고객 × 상품 모든 조합 출력
-- 실제 업무에서는 거의 사용 안 하지만, 테스트/통계에서 사용
```

---

## 6-2. 결합 알고리즘과 성능

DBMS는 조인을 실행할 때 다음 알고리즘 중 하나를 선택합니다.

1. **Nested Loop Join**

   * 작은 테이블 + 인덱스 있는 조건에 유리
2. **Hash Join**

   * 조인 키를 해시 테이블로 만들어 매칭 (대량 데이터에 적합)
3. **Merge Join**

   * 양쪽 테이블이 정렬되어 있으면 빠름

---

### 예제 6: 실행 계획 비교 (PostgreSQL)

```sql
EXPLAIN ANALYZE
SELECT o.order_id, c.name
FROM orders o
JOIN customers c ON o.customer_id = c.customer_id;
-- 주석:
-- 실행 계획에서 Nested Loop / Hash Join / Merge Join 중 하나 확인 가능
```

---

## 6-3. 결합이 느리다면

1. **조인 조건 컬럼에 인덱스 생성**

```sql
CREATE INDEX idx_orders_customer ON orders(customer_id);
```

2. **불필요한 조인 제거**

   * 필요한 컬럼만 가져오기

3. **서브쿼리 대신 조인, 또는 반대로**

   * 실행 계획을 보고 더 빠른 쪽 선택

4. **조인 순서 변경**

   * 옵티마이저가 자동으로 결정하지만, 힌트를 줄 수도 있음

---

### 예제 7: 불필요한 조인 제거 전/후

```sql
-- 불필요하게 products 조인
SELECT o.order_id, c.name
FROM orders o
JOIN customers c ON o.customer_id = c.customer_id
JOIN products p ON p.product_id = 1; -- 실제 사용 안 함

-- 개선: products 조인 삭제
SELECT o.order_id, c.name
FROM orders o
JOIN customers c ON o.customer_id = c.customer_id;
```

---

## 요약

* JOIN은 INNER, LEFT, RIGHT, FULL, CROSS 등 다양한 방식이 있음
* 실행 계획을 보고 Nested Loop / Hash / Merge 중 무엇을 쓰는지 확인
* 느릴 때는 인덱스 최적화, 불필요한 조인 제거, 조인 순서 조정
