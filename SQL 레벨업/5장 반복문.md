

# 5장. 반복문

## 5-1. 반복문 의존증

많은 초보 개발자가 프로그래밍 언어 습관 때문에 SQL에서도 “한 행씩” 처리하려고 합니다.
하지만 SQL은 **집합 전체를 한 번에 처리**하는 것이 훨씬 빠릅니다.

---

### 예제 1: 반복문 스타일(비효율)

```plpgsql
-- PostgreSQL 예시
DO $$
DECLARE
  r RECORD;
BEGIN
  FOR r IN SELECT customer_id FROM customers LOOP
    INSERT INTO orders(customer_id, order_date, status, total_amount)
    VALUES (r.customer_id, CURRENT_DATE, 'PAID', 100);
  END LOOP;
END;
$$;
-- 주석:
-- 각 고객마다 INSERT 한 번씩 실행 → 반복 I/O → 대량 데이터 시 매우 느림
```

---

### 예제 2: 집합 기반 방식(효율)

```sql
INSERT INTO orders(customer_id, order_date, status, total_amount)
SELECT customer_id, CURRENT_DATE, 'PAID', 100
FROM customers;
-- 주석:
-- 모든 고객에 대해 한 번에 INSERT → 반복 없이 대량 처리 가능
```

---

## 5-2. 반복계의 공포

**N+1 문제**가 대표적인 반복문 부작용입니다.

* 1번의 메인 쿼리 + N번의 하위 쿼리 실행
* ORM 사용 시 자주 발생 (Lazy Loading 주의)

---

### 예제 3: N+1 문제

```sql
-- 잘못된 패턴: 고객 목록 조회 후, 각 고객의 주문을 별도로 조회
SELECT * FROM customers;   -- 1번
-- 각 고객마다
SELECT * FROM orders WHERE customer_id = ?; -- N번
```

---

### 예제 4: 조인으로 해결

```sql
SELECT c.customer_id, c.name, o.order_id, o.total_amount
FROM customers c
LEFT JOIN orders o ON c.customer_id = o.customer_id;
-- 주석:
-- 한 번의 조인으로 모든 고객과 주문 정보 가져옴
```

---

## 5-3. SQL에서는 반복을 어떻게 표현할까?

SQL은 **반복문 대신 집합 연산**을 사용합니다.
필요하면 `WITH RECURSIVE` 같은 재귀 CTE(Common Table Expression)를 쓸 수 있지만, 대량 데이터엔 주의해야 합니다.

---

### 예제 5: 재귀 CTE (PostgreSQL)

```sql
WITH RECURSIVE seq(n) AS (
  SELECT 1
  UNION ALL
  SELECT n+1 FROM seq WHERE n < 5
)
SELECT * FROM seq;
-- 주석:
-- 1부터 5까지 생성
-- 반복문이 아니라, 자기 자신을 참조하는 쿼리
```

---

## 5-4. 바이어스의 공죄

프로그래머는 익숙한 언어 습관(예: for/while) 때문에 SQL도 절차적으로 작성하려고 함 → 성능 저하
→ **항상 "전체 집합"을 기준으로 생각**하는 습관이 필요함

---

## 요약

* SQL에서는 반복문보다 **집합 기반 처리**가 빠르고 효율적
* N+1 문제를 피하려면 조인으로 한 번에 가져오기
* 재귀 CTE는 반복이 필요한 경우 제한적으로 사용
* 절차형 사고 대신 선언형 사고로 전환
