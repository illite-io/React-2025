
# SQL 레벨업 요약본

## 1장. DBMS 아키텍처

* SQL 실행 과정: **파서 → 옵티마이저 → 실행기 → 버퍼 → 디스크**
* 실행 계획 확인: `EXPLAIN` / `EXPLAIN ANALYZE`

```sql
EXPLAIN ANALYZE
SELECT * FROM orders WHERE customer_id = 1;
```

---

## 2장. SQL 기초

* SELECT 기본 구조: `SELECT … FROM … WHERE … GROUP BY … HAVING … ORDER BY …`

```sql
SELECT name, city FROM customers WHERE city = 'Seoul' ORDER BY name;
```

* 조건 분기: `CASE`

```sql
SELECT order_id,
       CASE WHEN total_amount >= 300 THEN 'HIGH' ELSE 'LOW' END AS grade
FROM orders;
```

---

## 3장. SQL의 조건 분기

* 불필요한 UNION은 CASE로 대체

```sql
SELECT order_id,
       CASE WHEN total_amount >= 300 THEN 'HIGH' ELSE 'LOW' END AS grade
FROM orders;
```

* 집계+조건

```sql
SELECT customer_id,
       SUM(CASE WHEN status='PAID' THEN total_amount ELSE 0 END) AS sum_paid
FROM orders GROUP BY customer_id;
```

---

## 4장. 집약과 자르기

* 집계: `SUM`, `COUNT`, `AVG`, `MAX`, `MIN`

```sql
SELECT customer_id, SUM(total_amount) FROM orders GROUP BY customer_id;
```

* 페이징

```sql
SELECT * FROM orders ORDER BY order_date DESC LIMIT 5 OFFSET 10;
```

---

## 5장. 반복문

* 반복 대신 집합 처리

```sql
INSERT INTO orders(customer_id, order_date, status, total_amount)
SELECT customer_id, CURRENT_DATE, 'PAID', 100 FROM customers;
```

* N+1 문제 → 조인으로 해결

```sql
SELECT c.name, o.order_id FROM customers c LEFT JOIN orders o ON c.customer_id = o.customer_id;
```

---

## 6장. 결합(Join)

* INNER / LEFT / RIGHT / FULL / CROSS JOIN

```sql
SELECT o.order_id, c.name
FROM orders o INNER JOIN customers c ON o.customer_id = c.customer_id;
```

---

## 7장. 서브쿼리

* 상관 서브쿼리보다 조인 선호

```sql
-- 비효율
SELECT name, (SELECT SUM(total_amount) FROM orders WHERE customer_id=c.customer_id)
FROM customers c;
-- 효율
SELECT c.name, SUM(o.total_amount) FROM customers c
LEFT JOIN orders o ON c.customer_id=o.customer_id
GROUP BY c.name;
```

---

## 8장. SQL의 순서

* 순번 부여

```sql
SELECT ROW_NUMBER() OVER (ORDER BY order_date) AS rn, * FROM orders;
```

* 시퀀스(PostgreSQL)

```sql
CREATE SEQUENCE order_seq START 1000;
SELECT nextval('order_seq');
```

---

## 9장. 갱신과 데이터 모델

* 다중 UPDATE

```sql
UPDATE customers SET tier='A' WHERE customer_id IN (1,2,3);
```

* 자기 조인 UPDATE

```sql
UPDATE customers c
SET city = sub.city
FROM (SELECT tier, MIN(city) AS city FROM customers GROUP BY tier) sub
WHERE c.tier = sub.tier;
```

---

## 10장. 인덱스 사용

* 복합 인덱스 설계

```sql
CREATE INDEX idx_orders_customer_date ON orders(customer_id, order_date);
```

* 커버링 인덱스

```sql
CREATE INDEX idx_orders_cov ON orders(customer_id, order_date, status);
```

* 함수/형변환 회피

```sql
-- Bad
WHERE TO_CHAR(order_date,'YYYY-MM')='2025-06'
-- Good
WHERE order_date >= DATE '2025-06-01' AND order_date < DATE '2025-07-01';
```
