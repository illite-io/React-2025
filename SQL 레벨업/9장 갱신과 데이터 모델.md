

# 9장. 갱신과 데이터 모델

## 9-1. 갱신은 효율적으로

`UPDATE` 문을 남발하면 불필요한 디스크 I/O와 잠금(Lock)이 늘어나 성능이 떨어집니다.
가능하면 **한 번에, 조건에 맞춰, 필요한 컬럼만** 갱신하는 것이 좋습니다.

---

### 예제 1: 비효율적인 갱신

```sql
-- 고객 등급을 한 명씩 변경
UPDATE customers SET tier = 'A' WHERE customer_id = 1;
UPDATE customers SET tier = 'A' WHERE customer_id = 2;
UPDATE customers SET tier = 'A' WHERE customer_id = 3;
-- 주석:
-- 같은 작업을 여러 번 실행 → 불필요한 I/O와 Lock 발생
```

---

### 예제 2: 효율적인 갱신

```sql
UPDATE customers
SET tier = 'A'
WHERE customer_id IN (1, 2, 3);
-- 주석:
-- 한 번의 쿼리로 여러 건 갱신
```

---

## 9-2. 레코드에서 필드로의 갱신

데이터 형태가 **행(row)** 중심에서 **열(column)** 중심으로 바뀌는 경우가 있습니다.
예를 들어, 월별 매출을 한 행에 모으는 경우.

---

### 예제 3: 레코드 → 필드 변환 (Pivot)

```sql
-- 고객별 월별 주문 합계를 열로 변환 (PostgreSQL crosstab 예시)
-- crosstab 사용 전: tablefunc 확장 설치 필요
SELECT *
FROM crosstab(
  'SELECT customer_id, to_char(order_date, ''YYYY-MM'') AS month, SUM(total_amount)
   FROM orders
   GROUP BY customer_id, month
   ORDER BY customer_id, month',
  'SELECT DISTINCT to_char(order_date, ''YYYY-MM'') FROM orders ORDER BY 1'
) AS ct(customer_id INT, "2025-01" NUMERIC, "2025-02" NUMERIC, "2025-03" NUMERIC);
```

---

## 9-3. 필드에서 레코드로 변경 (Unpivot)

반대로 열(column)로 나눠져 있는 데이터를 행(row)으로 펼치는 경우입니다.

---

### 예제 4: 필드 → 레코드 변환

```sql
SELECT customer_id, month, amount
FROM monthly_sales
UNPIVOT (amount FOR month IN (jan_amount, feb_amount, mar_amount)) AS u;
-- 주석:
-- SQL Server에서 지원, PostgreSQL/MySQL은 UNION ALL로 구현
```

---

## 9-4. 같은 테이블의 다른 레코드로 갱신

---

### 예제 5: 자기 조인으로 갱신

```sql
-- 고객의 city를 같은 tier의 대표 도시로 맞추기
UPDATE customers c
SET city = sub.city
FROM (
  SELECT tier, MIN(city) AS city
  FROM customers
  GROUP BY tier
) sub
WHERE c.tier = sub.tier;
-- 주석:
-- 같은 테이블끼리 조인해 값 복사
```

---

## 9-5. 갱신이 초래하는 트레이드오프

* **인덱스 많은 테이블** → UPDATE/DELETE가 느려짐 (인덱스 갱신 필요)
* **트랜잭션 락** → 갱신 중 다른 트랜잭션 대기 가능성
* **로그 증가** → 대량 갱신 시 로그 파일 폭증

---

## 9-6. 모델 갱신의 주의점

데이터 모델(스키마) 변경 시, 기존 쿼리/프로그램/인덱스에 미치는 영향 고려해야 함.
가능하면 **점진적 변경** → 새 컬럼 추가 → 데이터 마이그레이션 → 구 컬럼 제거 순서로 진행.

---

## 9-7. 시야 협착 : 관련 문제

업무 단위로만 데이터 구조를 변경하다 보면 전체적인 시스템 설계 일관성을 해칠 수 있음 →
**데이터 모델링 원칙** 유지 + **정규화/비정규화 균형** 고려.

---

## 9-8. 데이터 모델을 지배하는 자가 시스템을 지배한다

SQL 성능 문제의 80%는 잘못된 데이터 모델에서 시작됩니다.

* 적절한 키(Primary / Foreign Key) 설계
* 인덱스 전략
* 컬럼 타입 일관성
* 데이터 중복 관리

---

## 요약

* 갱신은 가능하면 한 번에, 필요한 컬럼만
* 레코드 ↔ 필드 변환(Pivot/Unpivot)은 보고서, 통계 작성에 유용
* 자기 조인으로 같은 테이블 내 데이터 복사 가능
* 모델 변경은 전체 시스템 영향 고려
* 좋은 데이터 모델이 좋은 성능을 만든다

